#ifndef __ac_FIRST__usr_local_etc_transcallX453_5_1_orig_libos_3_13_11__
#define __ac_FIRST__usr_local_etc_transcallX453_5_1_orig_libos_3_13_11__
#define __ac_FIRST_FILE__usr_local_etc_transcallX453_5_1_orig_libos_3_13_11_lib_cpumask_cxx__
#endif // __ac_FIRST__usr_local_etc_transcallX453_5_1_orig_libos_3_13_11__
class Introspect;
class MyIntrospect;

#ifndef __ac_h_
#define __ac_h_
#ifdef __cplusplus
namespace AC {
  typedef const char* Type;
  enum JPType { CALL = 32768, EXECUTION = 65536, CONSTRUCTION = 131072, DESTRUCTION = 262144, GET = 33554432 };
  enum Protection { PROT_NONE, PROT_PRIVATE, PROT_PROTECTED, PROT_PUBLIC };
  enum Specifiers { SPEC_NONE = 0x0 , SPEC_STATIC = 0x1, SPEC_MUTABLE = 0x2, SPEC_VIRTUAL = 0x4 };
  struct Action {
    void **_args; void *_result; void *_target; void *_that; void *_fptr;
    void *_source;
    void (*_wrapper)(Action &);
    inline void trigger () { _wrapper (*this); }
  };
  struct AnyResultBuffer {};
  template <typename T> struct ResultBuffer : public AnyResultBuffer {
    struct { char _array[sizeof (T)]; } _data;
    ~ResultBuffer () { ((T&)_data).T::~T(); }
    operator T& () const { return (T&)_data; }
  };
  template <typename T, typename N> struct TL {
    typedef T type; typedef N next; enum { ARGS = next::ARGS + 1 };
  };
  struct TLE { enum { ARGS = 0 }; };
  template <typename T> struct Referred { typedef T type; };
  template <typename T> struct Referred<T &> { typedef T type; };
  template <typename TL, int I> struct Arg {
    typedef typename Arg<typename TL::next, I - 1>::Type Type;
    typedef typename Referred<Type>::type ReferredType;
  };
  template <typename TL> struct Arg<TL, 0> {
    typedef typename TL::type Type;
    typedef typename Referred<Type>::type ReferredType;
  };
  template <typename T> int ttest(...);
  template <typename T> char ttest(typename T::__TI const volatile *);
  template<typename T> struct HasTypeInfo {
    enum { RET=((sizeof(ttest<T>(0))==1)?1:0) };
  };
  template<typename T, int HAVE = HasTypeInfo<T>::RET> struct TypeInfo {
    enum { AVAILABLE = 0 };
  };
  template<typename T> struct TypeInfo<T, 1> : T::__TI {
    enum { AVAILABLE = 1 };
	 };
  template<typename T> struct RT {};
  template<typename T> RT<T> rt_deduce (const T&) { return RT<T>(); }
  struct Cnv { template<typename T> operator RT<T>() const { return RT<T>(); }};
  #define __AC_TYPEOF(expr) (1?AC::Cnv():AC::rt_deduce(expr))
  template <class Aspect, int Index>
  struct CFlow {
    static int &instance () {
      static int counter = 0;
      return counter;
    }
    CFlow () { instance ()++; }
    ~CFlow () { instance ()--; }
    static bool active () { return instance () > 0; }
  };
}
inline void * operator new (unsigned long int, AC::AnyResultBuffer *p) { return p; }
inline void operator delete (void *, AC::AnyResultBuffer *) { } // for VC++
#endif // __cplusplus
#endif // __ac_h_

#ifndef __ac_fwd_MyIntrospect__
#define __ac_fwd_MyIntrospect__
class MyIntrospect;
namespace AC {
  template <class JoinPoint>
  __attribute((always_inline)) inline void invoke_MyIntrospect_Introspect__a0_around (JoinPoint *tjp);
}
#endif

#ifndef __ac_need__usr_local_etc_transcallX453_5_1_orig_libos_3_13_11_MyIntrospect_ah__
#define __ac_need__usr_local_etc_transcallX453_5_1_orig_libos_3_13_11_MyIntrospect_ah__
#endif







extern "C" {


extern void g_pause(void);
extern void g_unpause(void);
extern void g_init(int domain_id);
extern void g_exit(void);
extern void *g_map(void *addr, unsigned long size);
extern void g_unmap(void *laddr);
extern void *g_proc_map(void *addr, unsigned long size, void *pgd);





}




extern int pid_max;
extern int ngroups_max;



struct seq_file;
struct dentry_operations;
struct dentry;
struct inode_operations;
struct nameidata;
struct super_operations;
struct kstatfs;
struct vfsmount;
struct statfs;

struct seq_file *seq_get(char *data, int size);
struct seq_file *seq_renew(struct seq_file *m);

char *dentry_op_dname(struct dentry_operations *op,
                      struct dentry *dentry, char *buffer, int buflen);
void *inode_op_getattr(struct inode_operations *op,
                       struct vfsmount *mnt, struct dentry *dentry,
                       struct kstat *stat);
void *inode_op_follow_link(struct inode_operations *op,
                           struct dentry *dentry, struct nameidata *nd);
int super_op_statfs(struct super_operations *op,
                    struct dentry *dentry, struct kstatfs *buf);


struct vfsmount *lookup_vfsmount(struct vfsmount *mnt, struct dentry *dentry);
int get_stat(struct vfsmount *mnt, struct dentry *dentry,
             struct kstat *stat);
int get_statfs(struct vfsmount *mnt, struct dentry *dentry,
               struct statfs *buf);












struct ftrace_branch_data {
  template <typename, int = 0> struct __BYPASSftrace_branch_data {};
  template <typename, int> friend struct __BYPASSftrace_branch_data;
 char *func;
 char *file;
 unsigned line;
 union {
  struct {
   unsigned long correct;
   unsigned long incorrect;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
};
  struct {
   unsigned long miss;
   unsigned long hit;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
};
  unsigned long miss_hit[2];
 };

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct kernel_symbol
{
  template <typename, int = 0> struct __BYPASSkernel_symbol {};
  template <typename, int> friend struct __BYPASSkernel_symbol;
 unsigned long value;
 char *name;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};





























typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;




typedef signed char s8;
typedef unsigned char u8;

typedef signed short s16;
typedef unsigned short u16;

typedef signed int s32;
typedef unsigned int u32;

typedef signed long long s64;
typedef unsigned long long u64;






enum {
 _false = 0,
 _true = 1
};
typedef struct {
 unsigned long fds_bits[1024 / (8 * sizeof(long))];

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __kernel_fd_set;


typedef void (*__kernel_sighandler_t)(int);


typedef int __kernel_key_t;
typedef int __kernel_mqd_t;




typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;


typedef unsigned long __kernel_old_dev_t;


typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;



typedef __kernel_ulong_t __kernel_ino_t;



typedef unsigned int __kernel_mode_t;



typedef int __kernel_pid_t;



typedef int __kernel_ipc_pid_t;



typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;



typedef __kernel_long_t __kernel_suseconds_t;



typedef int __kernel_daddr_t;



typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;




typedef struct {
 int val[2];

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __kernel_fsid_t;





typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_time_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;

typedef __u16 __sum16;
typedef __u32 __wsum;






typedef __u32 __kernel_dev_t;

typedef __kernel_fd_set fd_set;
typedef __kernel_dev_t dev_t;
typedef __kernel_ino_t ino_t;
typedef __kernel_mode_t mode_t;
typedef unsigned short umode_t;
typedef __u32 nlink_t;
typedef __kernel_off_t off_t;
typedef __kernel_pid_t pid_t;
typedef __kernel_daddr_t daddr_t;
typedef __kernel_key_t key_t;
typedef __kernel_suseconds_t suseconds_t;
typedef __kernel_timer_t timer_t;
typedef __kernel_clockid_t clockid_t;
typedef __kernel_mqd_t mqd_t;





typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_uid16_t uid16_t;
typedef __kernel_gid16_t gid16_t;

typedef unsigned long uintptr_t;



typedef __kernel_old_uid_t old_uid_t;
typedef __kernel_old_gid_t old_gid_t;



typedef __kernel_loff_t loff_t;
typedef __kernel_size_t size_t;




typedef __kernel_ssize_t ssize_t;




typedef __kernel_ptrdiff_t ptrdiff_t;




typedef __kernel_time_t time_t;




typedef __kernel_clock_t clock_t;




typedef __kernel_caddr_t caddr_t;



typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;


typedef unsigned char unchar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;




typedef __u8 u_int8_t;
typedef __s8 int8_t;
typedef __u16 u_int16_t;
typedef __s16 int16_t;
typedef __u32 u_int32_t;
typedef __s32 int32_t;



typedef __u8 uint8_t;
typedef __u16 uint16_t;
typedef __u32 uint32_t;


typedef __u64 uint64_t;
typedef __u64 u_int64_t;
typedef __s64 int64_t;
typedef unsigned long sector_t;
typedef unsigned long blkcnt_t;
typedef u64 dma_addr_t;
typedef unsigned gfp_t;
typedef unsigned fmode_t;
typedef unsigned oom_flags_t;


typedef u64 phys_addr_t;




typedef phys_addr_t resource_size_t;





typedef unsigned long irq_hw_number_t;




typedef struct _atomic {
  template <typename, int = 0> struct __BYPASS_atomic {};
  template <typename, int> friend struct __BYPASS_atomic;

 int counter;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} atomic_t;





typedef struct _atomic64 {
  template <typename, int = 0> struct __BYPASS_atomic64 {};
  template <typename, int> friend struct __BYPASS_atomic64;

 long counter;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} atomic64_t;


struct list_head {
  template <typename, int = 0> struct __BYPASSlist_head {};
  template <typename, int> friend struct __BYPASSlist_head;
 struct list_head *next, *prev;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct hlist_head {
  template <typename, int = 0> struct __BYPASShlist_head {};
  template <typename, int> friend struct __BYPASShlist_head;
 struct hlist_node *first;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct hlist_node {
  template <typename, int = 0> struct __BYPASShlist_node {};
  template <typename, int> friend struct __BYPASShlist_node;
 struct hlist_node *next, **pprev;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct ustat {
  template <typename, int = 0> struct __BYPASSustat {};
  template <typename, int> friend struct __BYPASSustat;
 __kernel_daddr_t f_tfree;
 __kernel_ino_t f_tinode;
 char f_fname[6];
 char f_fpack[6];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};






struct callback_head {
  template <typename, int = 0> struct __BYPASScallback_head {};
  template <typename, int> friend struct __BYPASScallback_head;
 struct callback_head *next;
 void (*func)(struct callback_head *head);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

static inline void INIT_LIST_HEAD(struct list_head *list)
{
 list->next = list;
 list->prev = list;
}
static inline void __list_add(struct list_head *_new,
         struct list_head *prev,
         struct list_head *next)
{
 next->prev = _new;
 _new->next = next;
 _new->prev = prev;
 prev->next = _new;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4nextE_0_0 {
  typedef TJP__ZN9list_head4nextE_0_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4nextE_0(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4nextE_0_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}
static inline void list_add(struct list_head *_new, struct list_head *head)
{
 __list_add(_new, head, __get__ZN9list_head4nextE_0(&head->next));
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4prevE_1_0 {
  typedef TJP__ZN9list_head4prevE_1_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4prevE_1(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4prevE_1_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}
static inline void list_add_tail(struct list_head *_new, struct list_head *head)
{
 __list_add(_new, __get__ZN9list_head4prevE_1(&head->prev), head);
}
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
 next->prev = prev;
 prev->next = next;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4prevE_2_0 {
  typedef TJP__ZN9list_head4prevE_2_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4prevE_2(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4prevE_2_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4nextE_3_0 {
  typedef TJP__ZN9list_head4nextE_3_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4nextE_3(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4nextE_3_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}
static inline void __list_del_entry(struct list_head *entry)
{
 __list_del(__get__ZN9list_head4prevE_2(&entry->prev), __get__ZN9list_head4nextE_3(&entry->next));
}


template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4prevE_4_0 {
  typedef TJP__ZN9list_head4prevE_4_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4prevE_4(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4prevE_4_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4nextE_5_0 {
  typedef TJP__ZN9list_head4nextE_5_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4nextE_5(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4nextE_5_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}
static inline void list_del(struct list_head *entry)
{
 __list_del(__get__ZN9list_head4prevE_4(&entry->prev), __get__ZN9list_head4nextE_5(&entry->next));
 entry->next = ((void *) 0x00100100 + (0xdead000000000000UL));
 entry->prev = ((void *) 0x00200200 + (0xdead000000000000UL));
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4nextE_6_0 {
  typedef TJP__ZN9list_head4nextE_6_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4nextE_6(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4nextE_6_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4prevE_7_0 {
  typedef TJP__ZN9list_head4prevE_7_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4prevE_7(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4prevE_7_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}
static inline void list_replace(struct list_head *old,
    struct list_head *_new)
{
 _new->next = __get__ZN9list_head4nextE_6(&old->next);
 _new->next->prev = _new;
 _new->prev = __get__ZN9list_head4prevE_7(&old->prev);
 _new->prev->next = _new;
}

static inline void list_replace_init(struct list_head *old,
     struct list_head *_new)
{
 list_replace(old, _new);
 INIT_LIST_HEAD(old);
}





static inline void list_del_init(struct list_head *entry)
{
 __list_del_entry(entry);
 INIT_LIST_HEAD(entry);
}






static inline void list_move(struct list_head *list, struct list_head *head)
{
 __list_del_entry(list);
 list_add(list, head);
}






static inline void list_move_tail(struct list_head *list,
      struct list_head *head)
{
 __list_del_entry(list);
 list_add_tail(list, head);
}







template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4nextE_8_0 {
  typedef TJP__ZN9list_head4nextE_8_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4nextE_8(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4nextE_8_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}
static inline int list_is_last( struct list_head *list,
    struct list_head *head)
{
 return __get__ZN9list_head4nextE_8(&list->next) == head;
}






template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4nextE_9_0 {
  typedef TJP__ZN9list_head4nextE_9_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4nextE_9(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4nextE_9_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}
static inline int list_empty( struct list_head *head)
{
 return __get__ZN9list_head4nextE_9(&head->next) == head;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4nextE_10_0 {
  typedef TJP__ZN9list_head4nextE_10_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4nextE_10(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4nextE_10_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4prevE_11_0 {
  typedef TJP__ZN9list_head4prevE_11_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4prevE_11(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4prevE_11_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}
static inline int list_empty_careful( struct list_head *head)
{
 struct list_head *next = __get__ZN9list_head4nextE_10(&head->next);
 return (next == head) && (next == __get__ZN9list_head4prevE_11(&head->prev));
}






template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4nextE_12_0 {
  typedef TJP__ZN9list_head4nextE_12_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4nextE_12(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4nextE_12_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}
static inline void list_rotate_left(struct list_head *head)
{
 struct list_head *first;

 if (!list_empty(head)) {
  first = __get__ZN9list_head4nextE_12(&head->next);
  list_move_tail(first, head);
 }
}






template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4nextE_13_0 {
  typedef TJP__ZN9list_head4nextE_13_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4nextE_13(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4nextE_13_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4prevE_14_0 {
  typedef TJP__ZN9list_head4prevE_14_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4prevE_14(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4prevE_14_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}
static inline int list_is_singular( struct list_head *head)
{
 return !list_empty(head) && (__get__ZN9list_head4nextE_13(&head->next) == __get__ZN9list_head4prevE_14(&head->prev));
}


template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4nextE_15_0 {
  typedef TJP__ZN9list_head4nextE_15_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4nextE_15(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4nextE_15_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4nextE_16_0 {
  typedef TJP__ZN9list_head4nextE_16_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4nextE_16(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4nextE_16_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}
static inline void __list_cut_position(struct list_head *list,
  struct list_head *head, struct list_head *entry)
{
 struct list_head *new_first = __get__ZN9list_head4nextE_15(&entry->next);
 list->next = __get__ZN9list_head4nextE_16(&head->next);
 list->next->prev = list;
 list->prev = entry;
 entry->next = list;
 head->next = new_first;
 new_first->prev = head;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4nextE_17_0 {
  typedef TJP__ZN9list_head4nextE_17_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4nextE_17(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4nextE_17_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}
static inline void list_cut_position(struct list_head *list,
  struct list_head *head, struct list_head *entry)
{
 if (list_empty(head))
  return;
 if (list_is_singular(head) &&
  (__get__ZN9list_head4nextE_17(&head->next) != entry && head != entry))
  return;
 if (entry == head)
  INIT_LIST_HEAD(list);
 else
  __list_cut_position(list, head, entry);
}


template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4nextE_18_0 {
  typedef TJP__ZN9list_head4nextE_18_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4nextE_18(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4nextE_18_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4prevE_19_0 {
  typedef TJP__ZN9list_head4prevE_19_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4prevE_19(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4prevE_19_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}
static inline void __list_splice( struct list_head *list,
     struct list_head *prev,
     struct list_head *next)
{
 struct list_head *first = __get__ZN9list_head4nextE_18(&list->next);
 struct list_head *last = __get__ZN9list_head4prevE_19(&list->prev);

 first->prev = prev;
 prev->next = first;

 last->next = next;
 next->prev = last;
}







template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4nextE_20_0 {
  typedef TJP__ZN9list_head4nextE_20_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4nextE_20(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4nextE_20_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}
static inline void list_splice( struct list_head *list,
    struct list_head *head)
{
 if (!list_empty(list))
  __list_splice(list, head, __get__ZN9list_head4nextE_20(&head->next));
}







template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4prevE_21_0 {
  typedef TJP__ZN9list_head4prevE_21_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4prevE_21(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4prevE_21_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}
static inline void list_splice_tail(struct list_head *list,
    struct list_head *head)
{
 if (!list_empty(list))
  __list_splice(list, __get__ZN9list_head4prevE_21(&head->prev), head);
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4nextE_22_0 {
  typedef TJP__ZN9list_head4nextE_22_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4nextE_22(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4nextE_22_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}
static inline void list_splice_init(struct list_head *list,
        struct list_head *head)
{
 if (!list_empty(list)) {
  __list_splice(list, head, __get__ZN9list_head4nextE_22(&head->next));
  INIT_LIST_HEAD(list);
 }
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4prevE_23_0 {
  typedef TJP__ZN9list_head4prevE_23_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4prevE_23(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4prevE_23_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}
static inline void list_splice_tail_init(struct list_head *list,
      struct list_head *head)
{
 if (!list_empty(list)) {
  __list_splice(list, __get__ZN9list_head4prevE_23(&head->prev), head);
  INIT_LIST_HEAD(list);
 }
}
static inline void INIT_HLIST_NODE(struct hlist_node *h)
{
 h->next = 0;
 h->pprev = 0;
}


template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN10hlist_node5pprevE_24_0 {
  typedef TJP__ZN10hlist_node5pprevE_24_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline hlist_node ** __get__ZN10hlist_node5pprevE_24(hlist_node ** *source) {
  ::hlist_node **__result_buffer;
  typedef TJP__ZN10hlist_node5pprevE_24_0< ::hlist_node **, ::hlist_node , ::hlist_node ** > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::hlist_node **&)__result_buffer;
}
static inline int hlist_unhashed( struct hlist_node *h)
{
 return !__get__ZN10hlist_node5pprevE_24(&h->pprev);
}


template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN10hlist_head5firstE_25_0 {
  typedef TJP__ZN10hlist_head5firstE_25_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline hlist_node * __get__ZN10hlist_head5firstE_25(hlist_node * *source) {
  ::hlist_node *__result_buffer;
  typedef TJP__ZN10hlist_head5firstE_25_0< ::hlist_node *, ::hlist_head , ::hlist_node * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::hlist_node *&)__result_buffer;
}
static inline int hlist_empty( struct hlist_head *h)
{
 return !__get__ZN10hlist_head5firstE_25(&h->first);
}


template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN10hlist_node4nextE_26_0 {
  typedef TJP__ZN10hlist_node4nextE_26_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline hlist_node * __get__ZN10hlist_node4nextE_26(hlist_node * *source) {
  ::hlist_node *__result_buffer;
  typedef TJP__ZN10hlist_node4nextE_26_0< ::hlist_node *, ::hlist_node , ::hlist_node * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::hlist_node *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN10hlist_node5pprevE_27_0 {
  typedef TJP__ZN10hlist_node5pprevE_27_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline hlist_node ** __get__ZN10hlist_node5pprevE_27(hlist_node ** *source) {
  ::hlist_node **__result_buffer;
  typedef TJP__ZN10hlist_node5pprevE_27_0< ::hlist_node **, ::hlist_node , ::hlist_node ** > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::hlist_node **&)__result_buffer;
}
static inline void __hlist_del(struct hlist_node *n)
{
 struct hlist_node *next = __get__ZN10hlist_node4nextE_26(&n->next);
 struct hlist_node **pprev = __get__ZN10hlist_node5pprevE_27(&n->pprev);
 *pprev = next;
 if (next)
  next->pprev = pprev;
}

static inline void hlist_del(struct hlist_node *n)
{
 __hlist_del(n);
 n->next = ((void *) 0x00100100 + (0xdead000000000000UL));
 n->pprev = ((void *) 0x00200200 + (0xdead000000000000UL));
}

static inline void hlist_del_init(struct hlist_node *n)
{
 if (!hlist_unhashed(n)) {
  __hlist_del(n);
  INIT_HLIST_NODE(n);
 }
}


template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN10hlist_head5firstE_28_0 {
  typedef TJP__ZN10hlist_head5firstE_28_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline hlist_node * __get__ZN10hlist_head5firstE_28(hlist_node * *source) {
  ::hlist_node *__result_buffer;
  typedef TJP__ZN10hlist_head5firstE_28_0< ::hlist_node *, ::hlist_head , ::hlist_node * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::hlist_node *&)__result_buffer;
}
static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)
{
 struct hlist_node *first = __get__ZN10hlist_head5firstE_28(&h->first);
 n->next = first;
 if (first)
  first->pprev = &n->next;
 h->first = n;
 n->pprev = &h->first;
}



template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN10hlist_node5pprevE_29_0 {
  typedef TJP__ZN10hlist_node5pprevE_29_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline hlist_node ** __get__ZN10hlist_node5pprevE_29(hlist_node ** *source) {
  ::hlist_node **__result_buffer;
  typedef TJP__ZN10hlist_node5pprevE_29_0< ::hlist_node **, ::hlist_node , ::hlist_node ** > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::hlist_node **&)__result_buffer;
}
static inline void hlist_add_before(struct hlist_node *n,
     struct hlist_node *next)
{
 n->pprev = __get__ZN10hlist_node5pprevE_29(&next->pprev);
 n->next = next;
 next->pprev = &n->next;
 *(n->pprev) = n;
}


template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN10hlist_node4nextE_30_0 {
  typedef TJP__ZN10hlist_node4nextE_30_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline hlist_node * __get__ZN10hlist_node4nextE_30(hlist_node * *source) {
  ::hlist_node *__result_buffer;
  typedef TJP__ZN10hlist_node4nextE_30_0< ::hlist_node *, ::hlist_node , ::hlist_node * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::hlist_node *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN10hlist_node4nextE_31_0 {
  typedef TJP__ZN10hlist_node4nextE_31_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline hlist_node * __get__ZN10hlist_node4nextE_31(hlist_node * *source) {
  ::hlist_node *__result_buffer;
  typedef TJP__ZN10hlist_node4nextE_31_0< ::hlist_node *, ::hlist_node , ::hlist_node * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::hlist_node *&)__result_buffer;
}
static inline void hlist_add_after(struct hlist_node *n,
     struct hlist_node *next)
{
 next->next = __get__ZN10hlist_node4nextE_30(&n->next);
 n->next = next;
 next->pprev = &n->next;

 if(__get__ZN10hlist_node4nextE_31(&next->next))
  next->next->pprev = &next->next;
}


static inline void hlist_add_fake(struct hlist_node *n)
{
 n->pprev = &n->next;
}






template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN10hlist_head5firstE_32_0 {
  typedef TJP__ZN10hlist_head5firstE_32_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline hlist_node * __get__ZN10hlist_head5firstE_32(hlist_node * *source) {
  ::hlist_node *__result_buffer;
  typedef TJP__ZN10hlist_head5firstE_32_0< ::hlist_node *, ::hlist_head , ::hlist_node * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::hlist_node *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN10hlist_head5firstE_33_0 {
  typedef TJP__ZN10hlist_head5firstE_33_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline hlist_node * __get__ZN10hlist_head5firstE_33(hlist_node * *source) {
  ::hlist_node *__result_buffer;
  typedef TJP__ZN10hlist_head5firstE_33_0< ::hlist_node *, ::hlist_head , ::hlist_node * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::hlist_node *&)__result_buffer;
}
static inline void hlist_move_list(struct hlist_head *old,
       struct hlist_head *_new)
{
 _new->first = __get__ZN10hlist_head5firstE_32(&old->first);
 if (__get__ZN10hlist_head5firstE_33(&_new->first))
  _new->first->pprev = &_new->first;
 old->first = 0;
}














typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;




extern unsigned int __sw_hweight8(unsigned int w);
extern unsigned int __sw_hweight16(unsigned int w);
extern unsigned int __sw_hweight32(unsigned int w);
extern unsigned long __sw_hweight64(__u64 w);














extern char early_idt_handlers[32][2+2+5];
static inline unsigned long get_limit(unsigned long segment)
{
 unsigned long __limit;
 asm("lsll %1,%0" : "=r" (__limit) : "r" (segment));
 return __limit + 1;
}






extern int devmem_is_allowed(unsigned long pagenr);

extern unsigned long max_low_pfn_mapped;
extern unsigned long max_pfn_mapped;

static inline phys_addr_t get_max_mapped(void)
{
 return (phys_addr_t)max_pfn_mapped << 12;
}

bool pfn_range_is_mapped(unsigned long start_pfn, unsigned long end_pfn);

extern unsigned long init_memory_mapping(unsigned long start,
      unsigned long end);

extern void initmem_init(void);







struct pt_regs {
  template <typename, int = 0> struct __BYPASSpt_regs {};
  template <typename, int> friend struct __BYPASSpt_regs;
 unsigned long r15;
 unsigned long r14;
 unsigned long r13;
 unsigned long r12;
 unsigned long bp;
 unsigned long bx;

 unsigned long r11;
 unsigned long r10;
 unsigned long r9;
 unsigned long r8;
 unsigned long ax;
 unsigned long cx;
 unsigned long dx;
 unsigned long si;
 unsigned long di;
 unsigned long orig_ax;


 unsigned long ip;
 unsigned long cs;
 unsigned long flags;
 unsigned long sp;
 unsigned long ss;


  friend class ::Introspect;
  friend class ::MyIntrospect;
};



typedef int (*initcall_t)(void);
typedef void (*exitcall_t)(void);

extern initcall_t __con_initcall_start[], __con_initcall_end[];
extern initcall_t __security_initcall_start[], __security_initcall_end[];


typedef void (*ctor_fn_t)(void);


extern int do_one_initcall(initcall_t fn);
extern char __attribute__ ((__section__(".init.data"))) boot_command_line[];
extern char *saved_command_line;
extern unsigned int reset_devices;


void setup_arch(char **);
void prepare_namespace(void);
void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) load_default_modules(void);
int __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) init_rootfs(void);

extern void (*late_time_init)(void);

extern bool initcall_debug;
struct obs_kernel_param {
  template <typename, int = 0> struct __BYPASSobs_kernel_param {};
  template <typename, int> friend struct __BYPASSobs_kernel_param;
 char *str;
 int (*setup_func)(char *);
 int early;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) parse_early_param(void);
void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) parse_early_options(char *cmdline);

struct desc_struct {
  template <typename, int = 0> struct __BYPASSdesc_struct {};
  template <typename, int> friend struct __BYPASSdesc_struct;
 union {
  struct {
   unsigned int a;
   unsigned int b;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
};
  struct {
   u16 limit0;
   u16 base0;
   unsigned base1: 8, type: 4, s: 1, dpl: 2, p: 1;
   unsigned limit: 4, avl: 1, l: 1, d: 1, g: 1, base2: 8;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
};
 };

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__((packed));







enum {
 GATE_INTERRUPT = 0xE,
 GATE_TRAP = 0xF,
 GATE_CALL = 0xC,
 GATE_TASK = 0x5,
};


struct gate_struct64 {
  template <typename, int = 0> struct __BYPASSgate_struct64 {};
  template <typename, int> friend struct __BYPASSgate_struct64;
 u16 offset_low;
 u16 segment;
 unsigned ist : 3, zero0 : 5, type : 5, dpl : 2, p : 1;
 u16 offset_middle;
 u32 offset_high;
 u32 zero1;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__((packed));





enum {
 DESC_TSS = 0x9,
 DESC_LDT = 0x2,
 DESCTYPE_S = 0x10,
};


struct ldttss_desc64 {
  template <typename, int = 0> struct __BYPASSldttss_desc64 {};
  template <typename, int> friend struct __BYPASSldttss_desc64;
 u16 limit0;
 u16 base0;
 unsigned base1 : 8, type : 5, dpl : 2, p : 1;
 unsigned limit1 : 4, zero0 : 3, g : 1, base2 : 8;
 u32 base3;
 u32 zero1;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__((packed));


typedef struct gate_struct64 gate_desc;
typedef struct ldttss_desc64 ldt_desc;
typedef struct ldttss_desc64 tss_desc;
struct desc_ptr {
  template <typename, int = 0> struct __BYPASSdesc_ptr {};
  template <typename, int> friend struct __BYPASSdesc_ptr;
 unsigned short size;
 unsigned long address;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__((packed)) ;

















typedef unsigned long pteval_t;
typedef unsigned long pmdval_t;
typedef unsigned long pudval_t;
typedef unsigned long pgdval_t;
typedef unsigned long pgprotval_t;

typedef struct { pteval_t pte; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} pte_t;
typedef struct pgprot {
  template <typename, int = 0> struct __BYPASSpgprot {};
  template <typename, int> friend struct __BYPASSpgprot; pgprotval_t pgprot; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} pgprot_t;

typedef struct { pgdval_t pgd; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} pgd_t;

static inline pgd_t native_make_pgd(pgdval_t val)
{
 return (pgd_t) { val };
}

static inline pgdval_t native_pgd_val(pgd_t pgd)
{
 return pgd.pgd;
}

static inline pgdval_t pgd_flags(pgd_t pgd)
{
 return native_pgd_val(pgd) & (~((pteval_t)(((signed long)(~(((1UL) << 12)-1))) & ((phys_addr_t)((1ULL << 46) - 1)))));
}


typedef struct { pudval_t pud; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} pud_t;

static inline pud_t native_make_pud(pmdval_t val)
{
 return (pud_t) { val };
}

static inline pudval_t native_pud_val(pud_t pud)
{
 return pud.pud;
}
typedef struct { pmdval_t pmd; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} pmd_t;

static inline pmd_t native_make_pmd(pmdval_t val)
{
 return (pmd_t) { val };
}

static inline pmdval_t native_pmd_val(pmd_t pmd)
{
 return pmd.pmd;
}
static inline pudval_t pud_flags(pud_t pud)
{
 return native_pud_val(pud) & (~((pteval_t)(((signed long)(~(((1UL) << 12)-1))) & ((phys_addr_t)((1ULL << 46) - 1)))));
}

static inline pmdval_t pmd_flags(pmd_t pmd)
{
 return native_pmd_val(pmd) & (~((pteval_t)(((signed long)(~(((1UL) << 12)-1))) & ((phys_addr_t)((1ULL << 46) - 1)))));
}

static inline pte_t native_make_pte(pteval_t val)
{



        return ({ pte_t var; var.pte = val; var; });

}

static inline pteval_t native_pte_val(pte_t pte)
{
 return pte.pte;
}

static inline pteval_t pte_flags(pte_t pte)
{
 return native_pte_val(pte) & (~((pteval_t)(((signed long)(~(((1UL) << 12)-1))) & ((phys_addr_t)((1ULL << 46) - 1)))));
}





typedef struct page *pgtable_t;

extern pteval_t __supported_pte_mask;
extern void set_nx(void);
extern int nx_enabled;


extern pgprot_t pgprot_writecombine(pgprot_t prot);





struct file;
pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
                              unsigned long size, pgprot_t vma_prot);
int phys_mem_access_prot_allowed(struct file *file, unsigned long pfn,
                              unsigned long size, pgprot_t *vma_prot);


void set_pte_vaddr(unsigned long vaddr, pte_t pte);







struct seq_file;
extern void arch_report_meminfo(struct seq_file *m);

enum pg_level {
 PG_LEVEL_NONE,
 PG_LEVEL_4K,
 PG_LEVEL_2M,
 PG_LEVEL_1G,
 PG_LEVEL_NUM
};


extern void update_page_count(int level, unsigned long pages);
extern pte_t *lookup_address(unsigned long address, unsigned int *level);
extern phys_addr_t slow_virt_to_phys(void *__address);
extern int kernel_map_pages_in_pgd(pgd_t *pgd, u64 pfn, unsigned long address,
       unsigned numpages, unsigned long page_flags);

struct page;
struct thread_struct;
struct desc_ptr;
struct tss_struct;
struct mm_struct;
struct desc_struct;
struct task_struct;
struct cpumask;





struct paravirt_callee_save {
  template <typename, int = 0> struct __BYPASSparavirt_callee_save {};
  template <typename, int> friend struct __BYPASSparavirt_callee_save;
 void *func;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};


struct pv_info {
  template <typename, int = 0> struct __BYPASSpv_info {};
  template <typename, int> friend struct __BYPASSpv_info;
 unsigned int kernel_rpl;
 int shared_kernel_pmd;


 u16 extra_user_64bit_cs;


 int paravirt_enabled;
 char *name;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct pv_init_ops {
  template <typename, int = 0> struct __BYPASSpv_init_ops {};
  template <typename, int> friend struct __BYPASSpv_init_ops;
 unsigned (*patch)(u8 type, u16 clobber, void *insnbuf,
     unsigned long addr, unsigned len);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};


struct pv_lazy_ops {
  template <typename, int = 0> struct __BYPASSpv_lazy_ops {};
  template <typename, int> friend struct __BYPASSpv_lazy_ops;

 void (*enter)(void);
 void (*leave)(void);
 void (*flush)(void);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct pv_time_ops {
  template <typename, int = 0> struct __BYPASSpv_time_ops {};
  template <typename, int> friend struct __BYPASSpv_time_ops;
 unsigned long long (*sched_clock)(void);
 unsigned long long (*steal_clock)(int cpu);
 unsigned long (*get_tsc_khz)(void);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct pv_cpu_ops {
  template <typename, int = 0> struct __BYPASSpv_cpu_ops {};
  template <typename, int> friend struct __BYPASSpv_cpu_ops;

 unsigned long (*get_debugreg)(int regno);
 void (*set_debugreg)(int regno, unsigned long value);

 void (*clts)(void);

 unsigned long (*read_cr0)(void);
 void (*write_cr0)(unsigned long);

 unsigned long (*read_cr4_safe)(void);
 unsigned long (*read_cr4)(void);
 void (*write_cr4)(unsigned long);


 unsigned long (*read_cr8)(void);
 void (*write_cr8)(unsigned long);



 void (*load_tr_desc)(void);
 void (*load_gdt)( struct desc_ptr *);
 void (*load_idt)( struct desc_ptr *);

 void (*store_idt)(struct desc_ptr *);
 void (*set_ldt)( void *desc, unsigned entries);
 unsigned long (*store_tr)(void);
 void (*load_tls)(struct thread_struct *t, unsigned int cpu);

 void (*load_gs_index)(unsigned int idx);

 void (*write_ldt_entry)(struct desc_struct *ldt, int entrynum,
    void *desc);
 void (*write_gdt_entry)(struct desc_struct *,
    int entrynum, void *desc, int size);
 void (*write_idt_entry)(gate_desc *,
    int entrynum, gate_desc *gate);
 void (*alloc_ldt)(struct desc_struct *ldt, unsigned entries);
 void (*free_ldt)(struct desc_struct *ldt, unsigned entries);

 void (*load_sp0)(struct tss_struct *tss, struct thread_struct *t);

 void (*set_iopl_mask)(unsigned mask);

 void (*wbinvd)(void);
 void (*io_delay)(void);


 void (*cpuid)(unsigned int *eax, unsigned int *ebx,
        unsigned int *ecx, unsigned int *edx);



 u64 (*read_msr)(unsigned int msr, int *err);
 int (*write_msr)(unsigned int msr, unsigned low, unsigned high);

 u64 (*read_tsc)(void);
 u64 (*read_pmc)(int counter);
 unsigned long long (*read_tscp)(unsigned int *aux);







 void (*irq_enable_sysexit)(void);







 void (*usergs_sysret64)(void);







 void (*usergs_sysret32)(void);



 void (*iret)(void);

 void (*swapgs)(void);

 void (*start_context_switch)(struct task_struct *prev);
 void (*end_context_switch)(struct task_struct *next);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct pv_irq_ops {
  template <typename, int = 0> struct __BYPASSpv_irq_ops {};
  template <typename, int> friend struct __BYPASSpv_irq_ops;
 struct paravirt_callee_save save_fl;
 struct paravirt_callee_save restore_fl;
 struct paravirt_callee_save irq_disable;
 struct paravirt_callee_save irq_enable;

 void (*safe_halt)(void);
 void (*halt)(void);


 void (*adjust_exception_frame)(void);


  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct pv_apic_ops {
  template <typename, int = 0> struct __BYPASSpv_apic_ops {};
  template <typename, int> friend struct __BYPASSpv_apic_ops;

 void (*startup_ipi_hook)(int phys_apicid,
     unsigned long start_eip,
     unsigned long start_esp);


  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct pv_mmu_ops {
  template <typename, int = 0> struct __BYPASSpv_mmu_ops {};
  template <typename, int> friend struct __BYPASSpv_mmu_ops;
 unsigned long (*read_cr2)(void);
 void (*write_cr2)(unsigned long);

 unsigned long (*read_cr3)(void);
 void (*write_cr3)(unsigned long);





 void (*activate_mm)(struct mm_struct *prev,
       struct mm_struct *next);
 void (*dup_mmap)(struct mm_struct *oldmm,
    struct mm_struct *mm);
 void (*exit_mmap)(struct mm_struct *mm);



 void (*flush_tlb_user)(void);
 void (*flush_tlb_kernel)(void);
 void (*flush_tlb_single)(unsigned long addr);
 void (*flush_tlb_others)( struct cpumask *cpus,
     struct mm_struct *mm,
     unsigned long start,
     unsigned long end);


 int (*pgd_alloc)(struct mm_struct *mm);
 void (*pgd_free)(struct mm_struct *mm, pgd_t *pgd);





 void (*alloc_pte)(struct mm_struct *mm, unsigned long pfn);
 void (*alloc_pmd)(struct mm_struct *mm, unsigned long pfn);
 void (*alloc_pud)(struct mm_struct *mm, unsigned long pfn);
 void (*release_pte)(unsigned long pfn);
 void (*release_pmd)(unsigned long pfn);
 void (*release_pud)(unsigned long pfn);


 void (*set_pte)(pte_t *ptep, pte_t pteval);
 void (*set_pte_at)(struct mm_struct *mm, unsigned long addr,
      pte_t *ptep, pte_t pteval);
 void (*set_pmd)(pmd_t *pmdp, pmd_t pmdval);
 void (*set_pmd_at)(struct mm_struct *mm, unsigned long addr,
      pmd_t *pmdp, pmd_t pmdval);
 void (*pte_update)(struct mm_struct *mm, unsigned long addr,
      pte_t *ptep);
 void (*pte_update_defer)(struct mm_struct *mm,
     unsigned long addr, pte_t *ptep);
 void (*pmd_update)(struct mm_struct *mm, unsigned long addr,
      pmd_t *pmdp);
 void (*pmd_update_defer)(struct mm_struct *mm,
     unsigned long addr, pmd_t *pmdp);

 pte_t (*ptep_modify_prot_start)(struct mm_struct *mm, unsigned long addr,
     pte_t *ptep);
 void (*ptep_modify_prot_commit)(struct mm_struct *mm, unsigned long addr,
     pte_t *ptep, pte_t pte);

 struct paravirt_callee_save pte_val;
 struct paravirt_callee_save make_pte;

 struct paravirt_callee_save pgd_val;
 struct paravirt_callee_save make_pgd;
 void (*set_pud)(pud_t *pudp, pud_t pudval);

 struct paravirt_callee_save pmd_val;
 struct paravirt_callee_save make_pmd;


 struct paravirt_callee_save pud_val;
 struct paravirt_callee_save make_pud;

 void (*set_pgd)(pgd_t *pudp, pgd_t pgdval);



 struct pv_lazy_ops lazy_mode;





 void (*set_fixmap)(unsigned idx,
      phys_addr_t phys, pgprot_t flags);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct arch_spinlock;

typedef u16 __ticket_t;
typedef u32 __ticketpair_t;






typedef struct arch_spinlock {
  template <typename, int = 0> struct __BYPASSarch_spinlock {};
  template <typename, int> friend struct __BYPASSarch_spinlock;



 union _arch_u {

  __ticketpair_t head_tail;
  struct __raw_tickets {
   __ticket_t head, tail;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} tickets;
 };

  friend class ::Introspect;
  friend class ::MyIntrospect;
} arch_spinlock_t;



typedef union {
 s32 lock;
 s32 write;
} arch_rwlock_t;




struct pv_lock_ops {
  template <typename, int = 0> struct __BYPASSpv_lock_ops {};
  template <typename, int> friend struct __BYPASSpv_lock_ops;
 struct paravirt_callee_save lock_spinning;
 void (*unlock_kick)(struct arch_spinlock *lock, __ticket_t ticket);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};




struct paravirt_patch_template {
  template <typename, int = 0> struct __BYPASSparavirt_patch_template {};
  template <typename, int> friend struct __BYPASSparavirt_patch_template;
 struct pv_init_ops pv_init_ops;
 struct pv_time_ops pv_time_ops;
 struct pv_cpu_ops pv_cpu_ops;
 struct pv_irq_ops pv_irq_ops;
 struct pv_apic_ops pv_apic_ops;
 struct pv_mmu_ops pv_mmu_ops;
 struct pv_lock_ops pv_lock_ops;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

extern struct pv_info pv_info;
extern struct pv_init_ops pv_init_ops;
extern struct pv_time_ops pv_time_ops;
extern struct pv_cpu_ops pv_cpu_ops;
extern struct pv_irq_ops pv_irq_ops;
extern struct pv_apic_ops pv_apic_ops;
extern struct pv_mmu_ops pv_mmu_ops;
extern struct pv_lock_ops pv_lock_ops;
unsigned paravirt_patch_nop(void);
unsigned paravirt_patch_ident_32(void *insnbuf, unsigned len);
unsigned paravirt_patch_ident_64(void *insnbuf, unsigned len);
unsigned paravirt_patch_ignore(unsigned len);
unsigned paravirt_patch_call(void *insnbuf,
        void *target, u16 tgt_clobbers,
        unsigned long addr, u16 site_clobbers,
        unsigned len);
unsigned paravirt_patch_jmp(void *insnbuf, void *target,
       unsigned long addr, unsigned len);
unsigned paravirt_patch_default(u8 type, u16 clobbers, void *insnbuf,
    unsigned long addr, unsigned len);

unsigned paravirt_patch_insns(void *insnbuf, unsigned len,
         char *start, char *end);

unsigned native_patch(u8 type, u16 clobbers, void *ibuf,
        unsigned long addr, unsigned len);

int paravirt_disable_iospace(void);
enum paravirt_lazy_mode {
 PARAVIRT_LAZY_NONE,
 PARAVIRT_LAZY_MMU,
 PARAVIRT_LAZY_CPU,
};

enum paravirt_lazy_mode paravirt_get_lazy_mode(void);
void paravirt_start_context_switch(struct task_struct *prev);
void paravirt_end_context_switch(struct task_struct *next);

void paravirt_enter_lazy_mmu(void);
void paravirt_leave_lazy_mmu(void);
void paravirt_flush_lazy_mmu(void);

void _paravirt_nop(void);
u32 _paravirt_ident_32(u32);
u64 _paravirt_ident_64(u64);




struct paravirt_patch_site {
  template <typename, int = 0> struct __BYPASSparavirt_patch_site {};
  template <typename, int> friend struct __BYPASSparavirt_patch_site;
 u8 *instr;
 u8 instrtype;
 u8 len;
 u16 clobbers;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

extern struct paravirt_patch_site __parainstructions[],
 __parainstructions_end[];


struct cpuinfo_x86;
struct task_struct;

extern unsigned long profile_pc(struct pt_regs *regs);


extern unsigned long
convert_ip_to_linear(struct task_struct *child, struct pt_regs *regs);
extern void send_sigtrap(struct task_struct *tsk, struct pt_regs *regs,
    int error_code, int si_code);

extern long syscall_trace_enter(struct pt_regs *);
extern void syscall_trace_leave(struct pt_regs *);


template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7pt_regs2axE_39_0 {
  typedef TJP__ZN7pt_regs2axE_39_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int __get__ZN7pt_regs2axE_39(unsigned long int *source) {
  unsigned long int __result_buffer;
  typedef TJP__ZN7pt_regs2axE_39_0< unsigned long int , ::pt_regs , unsigned long int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int &)__result_buffer;
}
static inline unsigned long regs_return_value(struct pt_regs *regs)
{
 return __get__ZN7pt_regs2axE_39(&regs->ax);
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7pt_regs2csE_40_0 {
  typedef TJP__ZN7pt_regs2csE_40_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int __get__ZN7pt_regs2csE_40(unsigned long int *source) {
  unsigned long int __result_buffer;
  typedef TJP__ZN7pt_regs2csE_40_0< unsigned long int , ::pt_regs , unsigned long int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int &)__result_buffer;
}
static inline int user_mode(struct pt_regs *regs)
{



 return !!(__get__ZN7pt_regs2csE_40(&regs->cs) & 3);

}

static inline int user_mode_vm(struct pt_regs *regs)
{




 return user_mode(regs);

}

static inline int v8086_mode(struct pt_regs *regs)
{



 return 0;

}



template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7pt_regs2csE_41_0 {
  typedef TJP__ZN7pt_regs2csE_41_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int __get__ZN7pt_regs2csE_41(unsigned long int *source) {
  unsigned long int __result_buffer;
  typedef TJP__ZN7pt_regs2csE_41_0< unsigned long int , ::pt_regs , unsigned long int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int &)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7pt_regs2csE_42_0 {
  typedef TJP__ZN7pt_regs2csE_42_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int __get__ZN7pt_regs2csE_42(unsigned long int *source) {
  unsigned long int __result_buffer;
  typedef TJP__ZN7pt_regs2csE_42_0< unsigned long int , ::pt_regs , unsigned long int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int &)__result_buffer;
}
static inline bool user_64bit_mode(struct pt_regs *regs)
{
 return __get__ZN7pt_regs2csE_41(&regs->cs) == (6*8+3) || __get__ZN7pt_regs2csE_42(&regs->cs) == pv_info.extra_user_64bit_cs;

}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7pt_regs2spE_45_0 {
  typedef TJP__ZN7pt_regs2spE_45_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int __get__ZN7pt_regs2spE_45(unsigned long int *source) {
  unsigned long int __result_buffer;
  typedef TJP__ZN7pt_regs2spE_45_0< unsigned long int , ::pt_regs , unsigned long int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int &)__result_buffer;
}
static inline unsigned long kernel_stack_pointer(struct pt_regs *regs)
{
 return __get__ZN7pt_regs2spE_45(&regs->sp);
}







template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7pt_regs2ipE_46_0 {
  typedef TJP__ZN7pt_regs2ipE_46_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int __get__ZN7pt_regs2ipE_46(unsigned long int *source) {
  unsigned long int __result_buffer;
  typedef TJP__ZN7pt_regs2ipE_46_0< unsigned long int , ::pt_regs , unsigned long int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int &)__result_buffer;
}
static inline unsigned long instruction_pointer(struct pt_regs *regs)
{
 return (__get__ZN7pt_regs2ipE_46(&(regs)->ip));
}
static inline void instruction_pointer_set(struct pt_regs *regs,
                                           unsigned long val)
{
 (((regs)->ip) = (val));
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7pt_regs2spE_47_0 {
  typedef TJP__ZN7pt_regs2spE_47_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int __get__ZN7pt_regs2spE_47(unsigned long int *source) {
  unsigned long int __result_buffer;
  typedef TJP__ZN7pt_regs2spE_47_0< unsigned long int , ::pt_regs , unsigned long int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int &)__result_buffer;
}
static inline unsigned long user_stack_pointer(struct pt_regs *regs)
{
 return (__get__ZN7pt_regs2spE_47(&(regs)->sp));
}
static inline void user_stack_pointer_set(struct pt_regs *regs,
                                          unsigned long val)
{
 (((regs)->sp) = (val));
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7pt_regs2bpE_48_0 {
  typedef TJP__ZN7pt_regs2bpE_48_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int __get__ZN7pt_regs2bpE_48(unsigned long int *source) {
  unsigned long int __result_buffer;
  typedef TJP__ZN7pt_regs2bpE_48_0< unsigned long int , ::pt_regs , unsigned long int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int &)__result_buffer;
}
static inline unsigned long frame_pointer(struct pt_regs *regs)
{
 return (__get__ZN7pt_regs2bpE_48(&(regs)->bp));
}
static inline void frame_pointer_set(struct pt_regs *regs,
                                     unsigned long val)
{
 (((regs)->bp) = (val));
}


extern int regs_query_register_offset( char *name);
extern char *regs_query_register_name(unsigned int offset);
static inline unsigned long regs_get_register(struct pt_regs *regs,
           unsigned int offset)
{
 if (__builtin_expect(!!(offset > (((size_t) &((struct pt_regs *)0)->ss))), 0))
  return 0;
 return *(unsigned long *)((unsigned long)regs + offset);
}
static inline int regs_within_kernel_stack(struct pt_regs *regs,
        unsigned long addr)
{
 return ((addr & ~((((1UL) << 12) << 1) - 1)) ==
  (kernel_stack_pointer(regs) & ~((((1UL) << 12) << 1) - 1)));
}
static inline unsigned long regs_get_kernel_stack_nth(struct pt_regs *regs,
            unsigned int n)
{
 unsigned long *addr = (unsigned long *)kernel_stack_pointer(regs);
 addr += n;
 if (regs_within_kernel_stack(regs, (unsigned long)addr))
  return *addr;
 else
  return 0;
}
struct user_desc;
extern int do_get_thread_area(struct task_struct *p, int idx,
         struct user_desc *info);
extern int do_set_thread_area(struct task_struct *p, int idx,
         struct user_desc *info, int can_allocate);
struct alt_instr {
  template <typename, int = 0> struct __BYPASSalt_instr {};
  template <typename, int> friend struct __BYPASSalt_instr;
 s32 instr_offset;
 s32 repl_offset;
 u16 cpuid;
 u8 instrlen;
 u8 replacementlen;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

extern void alternative_instructions(void);
extern void apply_alternatives(struct alt_instr *start, struct alt_instr *end);

struct module;


extern void alternatives_smp_module_add(struct module *mod, char *name,
     void *locks, void *locks_end,
     void *text, void *text_end);
extern void alternatives_smp_module_del(struct module *mod);
extern void alternatives_enable_smp(void);
extern int alternatives_text_reserved(void *start, void *end);
extern bool skip_smp_alternatives;








extern char * x86_cap_flags[10*32];
extern char * x86_power_flags[32];
extern void warn_pre_alternatives(void);
extern bool __static_cpu_has_safe(u16 bit);






static inline __attribute__((always_inline)) __attribute__((pure)) bool __static_cpu_has(u16 bit)
{
  u8 flag;

  asm ("1: movb $0,%0\n"
        "2:\n"
        ".section .altinstructions,\"a\"\n"
        " .long 1b - .\n"
        " .long 3f - .\n"
        " .word %P1\n"
        " .byte 2b - 1b\n"
        " .byte 4f - 3f\n"
        ".previous\n"
        ".section .discard,\"aw\",@progbits\n"
        " .byte 0xff + (4f-3f) - (2b-1b)\n"
        ".previous\n"
        ".section .altinstr_replacement,\"ax\"\n"
        "3: movb $1,%0\n"
        "4:\n"
        ".previous\n"
        : "=qm" (flag) : "i" (bit));
  return flag;


}
static inline __attribute__((always_inline)) __attribute__((pure)) bool _static_cpu_has_safe(u16 bit)
{
  u8 flag;

  asm ("1: movb $2,%0\n"
        "2:\n"
        ".section .altinstructions,\"a\"\n"
        " .long 1b - .\n"
        " .long 3f - .\n"
        " .word %P2\n"
        " .byte 2b - 1b\n"
        " .byte 4f - 3f\n"
        ".previous\n"
        ".section .discard,\"aw\",@progbits\n"
        " .byte 0xff + (4f-3f) - (2b-1b)\n"
        ".previous\n"
        ".section .altinstr_replacement,\"ax\"\n"
        "3: movb $0,%0\n"
        "4:\n"
        ".previous\n"
        ".section .altinstructions,\"a\"\n"
        " .long 1b - .\n"
        " .long 5f - .\n"
        " .word %P1\n"
        " .byte 4b - 3b\n"
        " .byte 6f - 5f\n"
        ".previous\n"
        ".section .discard,\"aw\",@progbits\n"
        " .byte 0xff + (6f-5f) - (4b-3b)\n"
        ".previous\n"
        ".section .altinstr_replacement,\"ax\"\n"
        "5: movb $1,%0\n"
        "6:\n"
        ".previous\n"
        : "=qm" (flag)
        : "i" (bit), "i" ((3*32+21)));
  return (flag == 2 ? __static_cpu_has_safe(bit) : flag);

}
struct paravirt_patch_site;

void apply_paravirt(struct paravirt_patch_site *start,
      struct paravirt_patch_site *end);
extern void *text_poke_early(void *addr, void *opcode, size_t len);
extern void *text_poke(void *addr, void *opcode, size_t len);
extern int poke_int3_handler(struct pt_regs *regs);
extern void *text_poke_bp(void *addr, void *opcode, size_t len, void *handler);
static inline __attribute__((always_inline)) void
set_bit(long nr, unsigned long *addr)
{
 if ((__builtin_constant_p(nr))) {
  asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "orb %1,%0"
   : "+m" (*( long *) ((void *)(addr) + ((nr)>>3)))
   : "iq" ((u8)(1 << ((nr) & 7)))
   : "memory");
 } else {
  asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "bts %1,%0"
   : "+m" (*( long *) (addr)) : "Ir" (nr) : "memory");
 }
}
static inline void __set_bit(long nr, unsigned long *addr)
{
 asm ("bts %1,%0" : "+m" (*( long *) (addr)) : "Ir" (nr) : "memory");
}
static inline __attribute__((always_inline)) void
clear_bit(long nr, unsigned long *addr)
{
 if ((__builtin_constant_p(nr))) {
  asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "andb %1,%0"
   : "+m" (*( long *) ((void *)(addr) + ((nr)>>3)))
   : "iq" ((u8)~(1 << ((nr) & 7))));
 } else {
  asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "btr %1,%0"
   : "+m" (*( long *) (addr))
   : "Ir" (nr));
 }
}
static inline void clear_bit_unlock(long nr, unsigned long *addr)
{
 __asm__ __volatile__("": : :"memory");
 clear_bit(nr, addr);
}

static inline void __clear_bit(long nr, unsigned long *addr)
{
 asm ("btr %1,%0" : "+m" (*( long *) (addr)) : "Ir" (nr));
}
static inline void __clear_bit_unlock(long nr, unsigned long *addr)
{
 __asm__ __volatile__("": : :"memory");
 __clear_bit(nr, addr);
}
static inline void __change_bit(long nr, unsigned long *addr)
{
 asm ("btc %1,%0" : "+m" (*( long *) (addr)) : "Ir" (nr));
}
static inline void change_bit(long nr, unsigned long *addr)
{
 if ((__builtin_constant_p(nr))) {
  asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "xorb %1,%0"
   : "+m" (*( long *) ((void *)(addr) + ((nr)>>3)))
   : "iq" ((u8)(1 << ((nr) & 7))));
 } else {
  asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "btc %1,%0"
   : "+m" (*( long *) (addr))
   : "Ir" (nr));
 }
}
static inline int test_and_set_bit(long nr, unsigned long *addr)
{
 do { char c; asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "bts" " %2, " "%0" "; set" "c" " %1" : "+m" (*addr), "=qm" (c) : "Ir" (nr) : "memory"); return c != 0; } while (0);
}
static inline __attribute__((always_inline)) int
test_and_set_bit_lock(long nr, unsigned long *addr)
{
 return test_and_set_bit(nr, addr);
}
static inline int __test_and_set_bit(long nr, unsigned long *addr)
{
 int oldbit;

 asm("bts %2,%1\n\t"
     "sbb %0,%0"
     : "=r" (oldbit), "+m" (*( long *) (addr))
     : "Ir" (nr));
 return oldbit;
}
static inline int test_and_clear_bit(long nr, unsigned long *addr)
{
 do { char c; asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "btr" " %2, " "%0" "; set" "c" " %1" : "+m" (*addr), "=qm" (c) : "Ir" (nr) : "memory"); return c != 0; } while (0);
}
static inline int __test_and_clear_bit(long nr, unsigned long *addr)
{
 int oldbit;

 asm ("btr %2,%1\n\t"
       "sbb %0,%0"
       : "=r" (oldbit), "+m" (*( long *) (addr))
       : "Ir" (nr));
 return oldbit;
}


static inline int __test_and_change_bit(long nr, unsigned long *addr)
{
 int oldbit;

 asm ("btc %2,%1\n\t"
       "sbb %0,%0"
       : "=r" (oldbit), "+m" (*( long *) (addr))
       : "Ir" (nr) : "memory");

 return oldbit;
}
static inline int test_and_change_bit(long nr, unsigned long *addr)
{
 do { char c; asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "btc" " %2, " "%0" "; set" "c" " %1" : "+m" (*addr), "=qm" (c) : "Ir" (nr) : "memory"); return c != 0; } while (0);
}

static inline __attribute__((always_inline)) int constant_test_bit(long nr, unsigned long *addr)
{
 return ((1UL << (nr & (64 -1))) &
  (addr[nr >> 6])) != 0;
}

static inline int variable_test_bit(long nr, unsigned long *addr)
{
 int oldbit;

 asm ("bt %2,%1\n\t"
       "sbb %0,%0"
       : "=r" (oldbit)
       : "m" (*(unsigned long *)addr), "Ir" (nr));

 return oldbit;
}
static inline unsigned long __ffs(unsigned long word)
{
 asm("rep; bsf %1,%0"
  : "=r" (word)
  : "rm" (word));
 return word;
}







static inline unsigned long ffz(unsigned long word)
{
 asm("rep; bsf %1,%0"
  : "=r" (word)
  : "r" (~word));
 return word;
}







static inline unsigned long __fls(unsigned long word)
{
 asm("bsr %1,%0"
     : "=r" (word)
     : "rm" (word));
 return word;
}
static inline int ffs(int x)
{
 int r;
 asm("bsfl %1,%0"
     : "=r" (r)
     : "rm" (x), "0" (-1));
 return r + 1;
}
static inline int fls(int x)
{
 int r;
 asm("bsrl %1,%0"
     : "=r" (r)
     : "rm" (x), "0" (-1));
 return r + 1;
}
static inline __attribute__((always_inline)) int fls64(__u64 x)
{
 int bitpos = -1;





 asm("bsrq %1,%q0"
     : "+r" (bitpos)
     : "rm" (x));
 return bitpos + 1;
}




extern unsigned long find_next_bit( unsigned long *addr, unsigned long
  size, unsigned long offset);
extern unsigned long find_next_zero_bit( unsigned long *addr, unsigned
  long size, unsigned long offset);
extern unsigned long find_first_bit( unsigned long *addr,
        unsigned long size);
extern unsigned long find_first_zero_bit( unsigned long *addr,
      unsigned long size);

static inline int sched_find_first_bit( unsigned long *b)
{

 if (b[0])
  return __ffs(b[0]);
 return __ffs(b[1]) + 64;
}



static inline unsigned int __arch_hweight32(unsigned int w)
{
 unsigned int res = 0;

 asm ("661:\n\t" "call __sw_hweight32" "\n662:\n" ".pushsection .altinstructions,\"a\"\n" " .long 661b - .\n" " .long " "663""1""f - .\n" " .word " "(4*32+23)" "\n" " .byte " "662b-661b" "\n" " .byte " "664""1""f-""663""1""f" "\n" ".popsection\n" ".pushsection .discard,\"aw\",@progbits\n" " .byte 0xff + (" "664""1""f-""663""1""f" ") - (" "662b-661b" ")\n" ".popsection\n" ".pushsection .altinstr_replacement, \"ax\"\n" "663""1"":\n\t" ".byte 0xf3,0x40,0x0f,0xb8,0xc7" "\n" "664""1" ":\n\t" ".popsection"
       : "=""a" (res)
       : "D" (w));

 return res;
}

static inline unsigned int __arch_hweight16(unsigned int w)
{
 return __arch_hweight32(w & 0xffff);
}

static inline unsigned int __arch_hweight8(unsigned int w)
{
 return __arch_hweight32(w & 0xff);
}

static inline unsigned long __arch_hweight64(__u64 w)
{
 unsigned long res = 0;
 asm ("661:\n\t" "call _Z14__sw_hweight64y" "\n662:\n" ".pushsection .altinstructions,\"a\"\n" " .long 661b - .\n" " .long " "663""1""f - .\n" " .word " "(4*32+23)" "\n" " .byte " "662b-661b" "\n" " .byte " "664""1""f-""663""1""f" "\n" ".popsection\n" ".pushsection .discard,\"aw\",@progbits\n" " .byte 0xff + (" "664""1""f-""663""1""f" ") - (" "662b-661b" ")\n" ".popsection\n" ".pushsection .altinstr_replacement, \"ax\"\n" "663""1"":\n\t" ".byte 0xf3,0x48,0x0f,0xb8,0xc7" "\n" "664""1" ":\n\t" ".popsection"
       : "=""a" (res)
       : "D" (w));



 return res;
}


























static inline __attribute__((__const__)) __u32 __arch_swab32(__u32 val)
{
 asm("bswapl %0" : "=r" (val) : "0" (val));
 return val;
}


static inline __attribute__((__const__)) __u64 __arch_swab64(__u64 val)
{
 asm("bswapq %0" : "=r" (val) : "0" (val));
 return val;

}
static inline __attribute__((__const__)) __u16 __fswab16(__u16 val)
{

 return __builtin_bswap16(val);





}

static inline __attribute__((__const__)) __u32 __fswab32(__u32 val)
{

 return __builtin_bswap32(val);





}

static inline __attribute__((__const__)) __u64 __fswab64(__u64 val)
{

 return __builtin_bswap64(val);
}

static inline __attribute__((__const__)) __u32 __fswahw32(__u32 val)
{



 return ((__u32)( (((__u32)(val) & (__u32)0x0000ffffUL) << 16) | (((__u32)(val) & (__u32)0xffff0000UL) >> 16)));

}

static inline __attribute__((__const__)) __u32 __fswahb32(__u32 val)
{



 return ((__u32)( (((__u32)(val) & (__u32)0x00ff00ffUL) << 8) | (((__u32)(val) & (__u32)0xff00ff00UL) >> 8)));

}
static inline __u16 __swab16p( __u16 *p)
{



 return (__builtin_constant_p((__u16)(*p)) ? ((__u16)( (((__u16)(*p) & (__u16)0x00ffU) << 8) | (((__u16)(*p) & (__u16)0xff00U) >> 8))) : __fswab16(*p));

}





static inline __u32 __swab32p( __u32 *p)
{



 return (__builtin_constant_p((__u32)(*p)) ? ((__u32)( (((__u32)(*p) & (__u32)0x000000ffUL) << 24) | (((__u32)(*p) & (__u32)0x0000ff00UL) << 8) | (((__u32)(*p) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(*p) & (__u32)0xff000000UL) >> 24))) : __fswab32(*p));

}





static inline __u64 __swab64p( __u64 *p)
{



 return (__builtin_constant_p((__u64)(*p)) ? ((__u64)( (((__u64)(*p) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(*p) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(*p) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(*p) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(*p) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(*p) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(*p) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(*p) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(*p));

}







static inline __u32 __swahw32p( __u32 *p)
{



 return (__builtin_constant_p((__u32)(*p)) ? ((__u32)( (((__u32)(*p) & (__u32)0x0000ffffUL) << 16) | (((__u32)(*p) & (__u32)0xffff0000UL) >> 16))) : __fswahw32(*p));

}







static inline __u32 __swahb32p( __u32 *p)
{



 return (__builtin_constant_p((__u32)(*p)) ? ((__u32)( (((__u32)(*p) & (__u32)0x00ff00ffUL) << 8) | (((__u32)(*p) & (__u32)0xff00ff00UL) >> 8))) : __fswahb32(*p));

}





static inline void __swab16s(__u16 *p)
{



 *p = __swab16p(p);

}




static inline void __swab32s(__u32 *p)
{



 *p = __swab32p(p);

}





static inline void __swab64s(__u64 *p)
{



 *p = __swab64p(p);

}







static inline void __swahw32s(__u32 *p)
{



 *p = __swahw32p(p);

}







static inline void __swahb32s(__u32 *p)
{



 *p = __swahb32p(p);

}
static inline __le64 __cpu_to_le64p( __u64 *p)
{
 return ( __le64)*p;
}
static inline __u64 __le64_to_cpup( __le64 *p)
{
 return ( __u64)*p;
}
static inline __le32 __cpu_to_le32p( __u32 *p)
{
 return ( __le32)*p;
}
static inline __u32 __le32_to_cpup( __le32 *p)
{
 return ( __u32)*p;
}
static inline __le16 __cpu_to_le16p( __u16 *p)
{
 return ( __le16)*p;
}
static inline __u16 __le16_to_cpup( __le16 *p)
{
 return ( __u16)*p;
}
static inline __be64 __cpu_to_be64p( __u64 *p)
{
 return ( __be64)__swab64p(p);
}
static inline __u64 __be64_to_cpup( __be64 *p)
{
 return __swab64p((__u64 *)p);
}
static inline __be32 __cpu_to_be32p( __u32 *p)
{
 return ( __be32)__swab32p(p);
}
static inline __u32 __be32_to_cpup( __be32 *p)
{
 return __swab32p((__u32 *)p);
}
static inline __be16 __cpu_to_be16p( __u16 *p)
{
 return ( __be16)__swab16p(p);
}
static inline __u16 __be16_to_cpup( __be16 *p)
{
 return __swab16p((__u16 *)p);
}

static inline void le16_add_cpu(__le16 *var, u16 val)
{
 *var = (( __le16)(__u16)((( __u16)(__le16)(*var)) + val));
}

static inline void le32_add_cpu(__le32 *var, u32 val)
{
 *var = (( __le32)(__u32)((( __u32)(__le32)(*var)) + val));
}

static inline void le64_add_cpu(__le64 *var, u64 val)
{
 *var = (( __le64)(__u64)((( __u64)(__le64)(*var)) + val));
}

static inline void be16_add_cpu(__be16 *var, u16 val)
{
 *var = (( __be16)(__builtin_constant_p((__u16)(((__builtin_constant_p((__u16)(( __u16)(__be16)(*var))) ? ((__u16)( (((__u16)(( __u16)(__be16)(*var)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__be16)(*var)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__be16)(*var))) + val))) ? ((__u16)( (((__u16)(((__builtin_constant_p((__u16)(( __u16)(__be16)(*var))) ? ((__u16)( (((__u16)(( __u16)(__be16)(*var)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__be16)(*var)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__be16)(*var))) + val)) & (__u16)0x00ffU) << 8) | (((__u16)(((__builtin_constant_p((__u16)(( __u16)(__be16)(*var))) ? ((__u16)( (((__u16)(( __u16)(__be16)(*var)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__be16)(*var)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__be16)(*var))) + val)) & (__u16)0xff00U) >> 8))) : __fswab16(((__builtin_constant_p((__u16)(( __u16)(__be16)(*var))) ? ((__u16)( (((__u16)(( __u16)(__be16)(*var)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__be16)(*var)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__be16)(*var))) + val))));
}

static inline void be32_add_cpu(__be32 *var, u32 val)
{
 *var = (( __be32)(__builtin_constant_p((__u32)(((__builtin_constant_p((__u32)(( __u32)(__be32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__be32)(*var))) + val))) ? ((__u32)( (((__u32)(((__builtin_constant_p((__u32)(( __u32)(__be32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__be32)(*var))) + val)) & (__u32)0x000000ffUL) << 24) | (((__u32)(((__builtin_constant_p((__u32)(( __u32)(__be32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__be32)(*var))) + val)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(((__builtin_constant_p((__u32)(( __u32)(__be32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__be32)(*var))) + val)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(((__builtin_constant_p((__u32)(( __u32)(__be32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__be32)(*var))) + val)) & (__u32)0xff000000UL) >> 24))) : __fswab32(((__builtin_constant_p((__u32)(( __u32)(__be32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__be32)(*var))) + val))));
}

static inline void be64_add_cpu(__be64 *var, u64 val)
{
 *var = (( __be64)(__builtin_constant_p((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val))) ? ((__u64)( (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val))));
}





static inline unsigned long find_next_zero_bit_le( void *addr,
  unsigned long size, unsigned long offset)
{



 return find_next_zero_bit((unsigned long *)addr, size, offset);

}

static inline unsigned long find_next_bit_le( void *addr,
  unsigned long size, unsigned long offset)
{



 return find_next_bit((unsigned long *)addr, size, offset);

}

static inline unsigned long find_first_zero_bit_le( void *addr,
  unsigned long size)
{



 return find_first_zero_bit((unsigned long *)addr, size);

}
static inline int test_bit_le(int nr, void *addr)
{



        return (__builtin_constant_p((nr ^ 0)) ? constant_test_bit((nr ^ 0), ((unsigned long *)addr)) : variable_test_bit((nr ^ 0), ((unsigned long *)addr)));

}

static inline void set_bit_le(int nr, void *addr)
{



 set_bit(nr ^ 0, (unsigned long *)addr);

}

static inline void clear_bit_le(int nr, void *addr)
{



 clear_bit(nr ^ 0, (unsigned long *)addr);

}

static inline void __set_bit_le(int nr, void *addr)
{



 __set_bit(nr ^ 0, (unsigned long *)addr);

}

static inline void __clear_bit_le(int nr, void *addr)
{



 __clear_bit(nr ^ 0, (unsigned long *)addr);

}

static inline int test_and_set_bit_le(int nr, void *addr)
{



 return test_and_set_bit(nr ^ 0, (unsigned long *)addr);

}

static inline int test_and_clear_bit_le(int nr, void *addr)
{



 return test_and_clear_bit(nr ^ 0, (unsigned long *)addr);

}

static inline int __test_and_set_bit_le(int nr, void *addr)
{



 return __test_and_set_bit(nr ^ 0, (unsigned long *)addr);

}

static inline int __test_and_clear_bit_le(int nr, void *addr)
{



 return __test_and_clear_bit(nr ^ 0, (unsigned long *)addr);

}

static __inline__ int get_bitmask_order(unsigned int count)
{
 int order;

 order = fls(count);
 return order;
}

static __inline__ int get_count_order(unsigned int count)
{
 int order;

 order = fls(count) - 1;
 if (count & (count - 1))
  order++;
 return order;
}

static inline unsigned long hweight_long(unsigned long w)
{
 return sizeof(w) == 4 ? (__builtin_constant_p(w) ? ((( (!!((w) & (1ULL << 0))) + (!!((w) & (1ULL << 1))) + (!!((w) & (1ULL << 2))) + (!!((w) & (1ULL << 3))) + (!!((w) & (1ULL << 4))) + (!!((w) & (1ULL << 5))) + (!!((w) & (1ULL << 6))) + (!!((w) & (1ULL << 7))) ) + ( (!!(((w) >> 8) & (1ULL << 0))) + (!!(((w) >> 8) & (1ULL << 1))) + (!!(((w) >> 8) & (1ULL << 2))) + (!!(((w) >> 8) & (1ULL << 3))) + (!!(((w) >> 8) & (1ULL << 4))) + (!!(((w) >> 8) & (1ULL << 5))) + (!!(((w) >> 8) & (1ULL << 6))) + (!!(((w) >> 8) & (1ULL << 7))) )) + (( (!!(((w) >> 16) & (1ULL << 0))) + (!!(((w) >> 16) & (1ULL << 1))) + (!!(((w) >> 16) & (1ULL << 2))) + (!!(((w) >> 16) & (1ULL << 3))) + (!!(((w) >> 16) & (1ULL << 4))) + (!!(((w) >> 16) & (1ULL << 5))) + (!!(((w) >> 16) & (1ULL << 6))) + (!!(((w) >> 16) & (1ULL << 7))) ) + ( (!!((((w) >> 16) >> 8) & (1ULL << 0))) + (!!((((w) >> 16) >> 8) & (1ULL << 1))) + (!!((((w) >> 16) >> 8) & (1ULL << 2))) + (!!((((w) >> 16) >> 8) & (1ULL << 3))) + (!!((((w) >> 16) >> 8) & (1ULL << 4))) + (!!((((w) >> 16) >> 8) & (1ULL << 5))) + (!!((((w) >> 16) >> 8) & (1ULL << 6))) + (!!((((w) >> 16) >> 8) & (1ULL << 7))) ))) : __arch_hweight32(w)) : (__builtin_constant_p(w) ? (((( (!!((w) & (1ULL << 0))) + (!!((w) & (1ULL << 1))) + (!!((w) & (1ULL << 2))) + (!!((w) & (1ULL << 3))) + (!!((w) & (1ULL << 4))) + (!!((w) & (1ULL << 5))) + (!!((w) & (1ULL << 6))) + (!!((w) & (1ULL << 7))) ) + ( (!!(((w) >> 8) & (1ULL << 0))) + (!!(((w) >> 8) & (1ULL << 1))) + (!!(((w) >> 8) & (1ULL << 2))) + (!!(((w) >> 8) & (1ULL << 3))) + (!!(((w) >> 8) & (1ULL << 4))) + (!!(((w) >> 8) & (1ULL << 5))) + (!!(((w) >> 8) & (1ULL << 6))) + (!!(((w) >> 8) & (1ULL << 7))) )) + (( (!!(((w) >> 16) & (1ULL << 0))) + (!!(((w) >> 16) & (1ULL << 1))) + (!!(((w) >> 16) & (1ULL << 2))) + (!!(((w) >> 16) & (1ULL << 3))) + (!!(((w) >> 16) & (1ULL << 4))) + (!!(((w) >> 16) & (1ULL << 5))) + (!!(((w) >> 16) & (1ULL << 6))) + (!!(((w) >> 16) & (1ULL << 7))) ) + ( (!!((((w) >> 16) >> 8) & (1ULL << 0))) + (!!((((w) >> 16) >> 8) & (1ULL << 1))) + (!!((((w) >> 16) >> 8) & (1ULL << 2))) + (!!((((w) >> 16) >> 8) & (1ULL << 3))) + (!!((((w) >> 16) >> 8) & (1ULL << 4))) + (!!((((w) >> 16) >> 8) & (1ULL << 5))) + (!!((((w) >> 16) >> 8) & (1ULL << 6))) + (!!((((w) >> 16) >> 8) & (1ULL << 7))) ))) + ((( (!!(((w) >> 32) & (1ULL << 0))) + (!!(((w) >> 32) & (1ULL << 1))) + (!!(((w) >> 32) & (1ULL << 2))) + (!!(((w) >> 32) & (1ULL << 3))) + (!!(((w) >> 32) & (1ULL << 4))) + (!!(((w) >> 32) & (1ULL << 5))) + (!!(((w) >> 32) & (1ULL << 6))) + (!!(((w) >> 32) & (1ULL << 7))) ) + ( (!!((((w) >> 32) >> 8) & (1ULL << 0))) + (!!((((w) >> 32) >> 8) & (1ULL << 1))) + (!!((((w) >> 32) >> 8) & (1ULL << 2))) + (!!((((w) >> 32) >> 8) & (1ULL << 3))) + (!!((((w) >> 32) >> 8) & (1ULL << 4))) + (!!((((w) >> 32) >> 8) & (1ULL << 5))) + (!!((((w) >> 32) >> 8) & (1ULL << 6))) + (!!((((w) >> 32) >> 8) & (1ULL << 7))) )) + (( (!!((((w) >> 32) >> 16) & (1ULL << 0))) + (!!((((w) >> 32) >> 16) & (1ULL << 1))) + (!!((((w) >> 32) >> 16) & (1ULL << 2))) + (!!((((w) >> 32) >> 16) & (1ULL << 3))) + (!!((((w) >> 32) >> 16) & (1ULL << 4))) + (!!((((w) >> 32) >> 16) & (1ULL << 5))) + (!!((((w) >> 32) >> 16) & (1ULL << 6))) + (!!((((w) >> 32) >> 16) & (1ULL << 7))) ) + ( (!!(((((w) >> 32) >> 16) >> 8) & (1ULL << 0))) + (!!(((((w) >> 32) >> 16) >> 8) & (1ULL << 1))) + (!!(((((w) >> 32) >> 16) >> 8) & (1ULL << 2))) + (!!(((((w) >> 32) >> 16) >> 8) & (1ULL << 3))) + (!!(((((w) >> 32) >> 16) >> 8) & (1ULL << 4))) + (!!(((((w) >> 32) >> 16) >> 8) & (1ULL << 5))) + (!!(((((w) >> 32) >> 16) >> 8) & (1ULL << 6))) + (!!(((((w) >> 32) >> 16) >> 8) & (1ULL << 7))) )))) : __arch_hweight64(w));
}






static inline __u64 rol64(__u64 word, unsigned int shift)
{
 return (word << shift) | (word >> (64 - shift));
}






static inline __u64 ror64(__u64 word, unsigned int shift)
{
 return (word >> shift) | (word << (64 - shift));
}






static inline __u32 rol32(__u32 word, unsigned int shift)
{
 return (word << shift) | (word >> (32 - shift));
}






static inline __u32 ror32(__u32 word, unsigned int shift)
{
 return (word >> shift) | (word << (32 - shift));
}






static inline __u16 rol16(__u16 word, unsigned int shift)
{
 return (word << shift) | (word >> (16 - shift));
}






static inline __u16 ror16(__u16 word, unsigned int shift)
{
 return (word >> shift) | (word << (16 - shift));
}






static inline __u8 rol8(__u8 word, unsigned int shift)
{
 return (word << shift) | (word >> (8 - shift));
}






static inline __u8 ror8(__u8 word, unsigned int shift)
{
 return (word >> shift) | (word << (8 - shift));
}






static inline __s32 sign_extend32(__u32 value, int index)
{
 __u8 shift = 31 - index;
 return (__s32)(value << shift) >> shift;
}

static inline unsigned fls_long(unsigned long l)
{
 if (sizeof(l) == 4)
  return fls(l);
 return fls64(l);
}
static inline unsigned long __ffs64(u64 word)
{






 return __ffs((unsigned long)word);
}
extern unsigned long find_last_bit( unsigned long *addr,
       unsigned long size);
extern __attribute__((, noreturn))
int ____ilog2_NaN(void);
static inline __attribute__(())
int __ilog2_u32(u32 n)
{
 return fls(n) - 1;
}



static inline __attribute__(())
int __ilog2_u64(u64 n)
{
 return fls64(n) - 1;
}







static inline __attribute__(())
bool is_power_of_2(unsigned long n)
{
 return (n != 0 && ((n & (n - 1)) == 0));
}




static inline __attribute__(())
unsigned long __roundup_pow_of_two(unsigned long n)
{
 return 1UL << fls_long(n - 1);
}




static inline __attribute__(())
unsigned long __rounddown_pow_of_two(unsigned long n)
{
 return 1UL << (fls_long(n) - 1);
}








extern char linux_banner[];
extern char linux_proc_banner[];

static inline int printk_get_level( char *buffer)
{
 if (buffer[0] == '\001' && buffer[1]) {
  switch (buffer[1]) {
  case '0' ... '7':
  case 'd':
   return buffer[1];
  }
 }
 return 0;
}

static inline char *printk_skip_level( char *buffer)
{
 if (printk_get_level(buffer)) {
  switch (buffer[1]) {
  case '0' ... '7':
  case 'd':
   return buffer + 2;
  }
 }
 return buffer;
}

extern int console_printk[];






static inline void console_silent(void)
{
 (console_printk[0]) = 0;
}

static inline void console_verbose(void)
{
 if ((console_printk[0]))
  (console_printk[0]) = 15;
}

struct va_format {
  template <typename, int = 0> struct __BYPASSva_format {};
  template <typename, int> friend struct __BYPASSva_format;
 char *fmt;
 va_list *va;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
static inline __attribute__((format(printf, 1, 2)))
int no_printk( char *fmt, ...)
{
 return 0;
}


extern __attribute__((format(printf, 1, 2)))
void early_printk( char *fmt, ...);
void early_vprintk( char *fmt, va_list ap);






 __attribute__((format(printf, 5, 0)))
int vprintk_emit(int facility, int level,
   char *dict, size_t dictlen,
   char *fmt, va_list args);

 __attribute__((format(printf, 1, 0)))
int vprintk( char *fmt, va_list args);

 __attribute__((format(printf, 5, 6))) __attribute__((__cold__))
 int printk_emit(int facility, int level,
      char *dict, size_t dictlen,
      char *fmt, ...);








extern "C" {

extern void printf(char *str, ...);
extern void *malloc(unsigned long size);
extern void free(void *ptr);

}







__attribute__((format(printf, 1, 2))) __attribute__((__cold__)) int printk_sched( char *fmt, ...);






extern int __printk_ratelimit( char *func);

extern bool printk_timed_ratelimit(unsigned long *caller_jiffies,
       unsigned int interval_msec);

extern int printk_delay_msec;
extern int dmesg_restrict;
extern int kptr_restrict;

extern void wake_up_klogd(void);

void log_buf_kexec_setup(void);
void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) setup_log_buf(int early);
void dump_stack_set_arch_desc( char *fmt, ...);
void dump_stack_print_info( char *log_lvl);
void show_regs_print_info( char *log_lvl);
extern void dump_stack(void) __attribute__((__cold__));
struct _ddebug {
  template <typename, int = 0> struct __BYPASS_ddebug {};
  template <typename, int> friend struct __BYPASS_ddebug;




 char *modname;
 char *function;
 char *filename;
 char *format;
 unsigned int lineno:18;
 unsigned int flags:8;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__((aligned(8)));


int ddebug_add_module(struct _ddebug *tab, unsigned int n,
    char *modname);

extern char *strndup_user( char *, long);
extern void *memdup_user( void *, size_t);







static inline __attribute__((always_inline)) void *__inline_memcpy(void *to, void *from, size_t n)
{
 unsigned long d0, d1, d2;
 asm ("rep ; movsl\n\t"
       "testb $2,%b4\n\t"
       "je 1f\n\t"
       "movsw\n"
       "1:\ttestb $1,%b4\n\t"
       "je 2f\n\t"
       "movsb\n"
       "2:"
       : "=&c" (d0), "=&D" (d1), "=&S" (d2)
       : "0" (n / 4), "q" (n), "1" ((long)to), "2" ((long)from)
       : "memory");
 return to;
}







extern void *memcpy(void *to, void *from, size_t len);
void *memset(void *s, int c, size_t n);


void *memmove(void *dest, void *src, size_t count);

int memcmp( void *cs, void *ct, size_t count);
size_t strlen( char *s);
char *strcpy(char *dest, char *src);
char *strcat(char *dest, char *src);
int strcmp( char *cs, char *ct);


extern char * strcpy(char *, char *);


extern char * strncpy(char *, char *, __kernel_size_t);


size_t strlcpy(char *, char *, size_t);


extern char * strcat(char *, char *);


extern char * strncat(char *, char *, __kernel_size_t);


extern size_t strlcat(char *, char *, __kernel_size_t);


extern int strcmp( char *, char *);


extern int strncmp( char *, char *,__kernel_size_t);


extern int strnicmp( char *, char *, __kernel_size_t);


extern int strcasecmp( char *s1, char *s2);


extern int strncasecmp( char *s1, char *s2, size_t n);


extern char * strchr( char *,int);


extern char * strnchr( char *, size_t, int);


extern char * strrchr( char *,int);

extern char * skip_spaces( char *);

extern char *strim(char *);

static inline char *strstrip(char *str)
{
 return strim(str);
}


extern char * strstr( char *, char *);


extern char * strnstr( char *, char *, size_t);


extern __kernel_size_t strlen( char *);


extern __kernel_size_t strnlen( char *,__kernel_size_t);


extern char * strpbrk( char *, char *);


extern char * strsep(char **, char *);


extern __kernel_size_t strspn( char *, char *);


extern __kernel_size_t strcspn( char *, char *);
extern void * memscan(void *,int,__kernel_size_t);


extern int memcmp( void *, void *,__kernel_size_t);


extern void * memchr( void *,int,__kernel_size_t);

void *memchr_inv( void *s, int c, size_t n);

extern char *kstrdup( char *s, gfp_t gfp);
extern char *kstrndup( char *s, size_t len, gfp_t gfp);
extern void *kmemdup( void *src, size_t len, gfp_t gfp);

extern char **argv_split(gfp_t gfp, char *str, int *argcp);
extern void argv_free(char **argv);

extern bool sysfs_streq( char *s1, char *s2);
extern int strtobool( char *s, bool *res);


int vbin_printf(u32 *bin_buf, size_t size, char *fmt, va_list args);
int bstr_printf(char *buf, size_t size, char *fmt, u32 *bin_buf);
int bprintf(u32 *bin_buf, size_t size, char *fmt, ...) __attribute__((format(printf, 3, 4)));


extern ssize_t memory_read_from_buffer(void *to, size_t count, loff_t *ppos,
   void *from, size_t available);






static inline bool strstarts( char *str, char *prefix)
{
 return strncmp(str, prefix, strlen(prefix)) == 0;
}

extern size_t memweight( void *ptr, size_t bytes);






static inline char *kbasename( char *path)
{
 char *tail = strrchr(path, '/');
 return tail ? tail + 1 : path;
}







static inline int ddebug_remove_module( char *mod)
{
 return 0;
}

static inline int ddebug_dyndbg_module_param_cb(char *param, char *val,
      char *modname)
{
 if (strstr(param, "dyndbg")) {

  printf("\001" "4" "dyndbg param is supported only in "
   "CONFIG_DYNAMIC_DEBUG builds\n");
  return 0;
 }
 return -22;
}
extern struct file_operations kmsg_fops;

enum {
 DUMP_PREFIX_NONE,
 DUMP_PREFIX_ADDRESS,
 DUMP_PREFIX_OFFSET
};
extern void hex_dump_to_buffer( void *buf, size_t len,
          int rowsize, int groupsize,
          char *linebuf, size_t linebuflen, bool ascii);

extern void print_hex_dump( char *level, char *prefix_str,
      int prefix_type, int rowsize, int groupsize,
      void *buf, size_t len, bool ascii);




extern void print_hex_dump_bytes( char *prefix_str, int prefix_type,
     void *buf, size_t len);











struct sysinfo {
  template <typename, int = 0> struct __BYPASSsysinfo {};
  template <typename, int> friend struct __BYPASSsysinfo;
 __kernel_long_t uptime;
 __kernel_ulong_t loads[3];
 __kernel_ulong_t totalram;
 __kernel_ulong_t freeram;
 __kernel_ulong_t sharedram;
 __kernel_ulong_t bufferram;
 __kernel_ulong_t totalswap;
 __kernel_ulong_t freeswap;
 __u16 procs;
 __u16 pad;
 __kernel_ulong_t totalhigh;
 __kernel_ulong_t freehigh;
 __u32 mem_unit;
 char _f[20-2*sizeof(__kernel_ulong_t)-sizeof(__u32)];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct completion;
struct pt_regs;
struct user;


extern int _cond_resched(void);
  static inline void __might_sleep( char *file, int line,
       int preempt_offset) { }
static inline void might_fault(void) { }


extern struct atomic_notifier_head panic_notifier_list;
extern long (*panic_blink)(int state);
__attribute__((format(printf, 1, 2)))
void panic( char *fmt, ...)
 __attribute__((noreturn)) __attribute__((__cold__));
extern void oops_enter(void);
extern void oops_exit(void);
void print_oops_end_marker(void);
extern int oops_may_print(void);
void do_exit(long error_code)
 __attribute__((noreturn));
void complete_and_exit(struct completion *, long)
 __attribute__((noreturn));


int _kstrtoul( char *s, unsigned int base, unsigned long *res);
int _kstrtol( char *s, unsigned int base, long *res);

int kstrtoull( char *s, unsigned int base, unsigned long long *res);
int kstrtoll( char *s, unsigned int base, long long *res);
static inline int kstrtoul( char *s, unsigned int base, unsigned long *res)
{




 if (sizeof(unsigned long) == sizeof(unsigned long long) &&
     __alignof__(unsigned long) == __alignof__(unsigned long long))
  return kstrtoull(s, base, (unsigned long long *)res);
 else
  return _kstrtoul(s, base, res);
}
static inline int kstrtol( char *s, unsigned int base, long *res)
{




 if (sizeof(long) == sizeof(long long) &&
     __alignof__(long) == __alignof__(long long))
  return kstrtoll(s, base, (long long *)res);
 else
  return _kstrtol(s, base, res);
}

int kstrtouint( char *s, unsigned int base, unsigned int *res);
int kstrtoint( char *s, unsigned int base, int *res);

static inline int kstrtou64( char *s, unsigned int base, u64 *res)
{
 return kstrtoull(s, base, res);
}

static inline int kstrtos64( char *s, unsigned int base, s64 *res)
{
 return kstrtoll(s, base, res);
}

static inline int kstrtou32( char *s, unsigned int base, u32 *res)
{
 return kstrtouint(s, base, res);
}

static inline int kstrtos32( char *s, unsigned int base, s32 *res)
{
 return kstrtoint(s, base, res);
}

int kstrtou16( char *s, unsigned int base, u16 *res);
int kstrtos16( char *s, unsigned int base, s16 *res);
int kstrtou8( char *s, unsigned int base, u8 *res);
int kstrtos8( char *s, unsigned int base, s8 *res);

int kstrtoull_from_user( char *s, size_t count, unsigned int base, unsigned long long *res);
int kstrtoll_from_user( char *s, size_t count, unsigned int base, long long *res);
int kstrtoul_from_user( char *s, size_t count, unsigned int base, unsigned long *res);
int kstrtol_from_user( char *s, size_t count, unsigned int base, long *res);
int kstrtouint_from_user( char *s, size_t count, unsigned int base, unsigned int *res);
int kstrtoint_from_user( char *s, size_t count, unsigned int base, int *res);
int kstrtou16_from_user( char *s, size_t count, unsigned int base, u16 *res);
int kstrtos16_from_user( char *s, size_t count, unsigned int base, s16 *res);
int kstrtou8_from_user( char *s, size_t count, unsigned int base, u8 *res);
int kstrtos8_from_user( char *s, size_t count, unsigned int base, s8 *res);

static inline int kstrtou64_from_user( char *s, size_t count, unsigned int base, u64 *res)
{
 return kstrtoull_from_user(s, count, base, res);
}

static inline int kstrtos64_from_user( char *s, size_t count, unsigned int base, s64 *res)
{
 return kstrtoll_from_user(s, count, base, res);
}

static inline int kstrtou32_from_user( char *s, size_t count, unsigned int base, u32 *res)
{
 return kstrtouint_from_user(s, count, base, res);
}

static inline int kstrtos32_from_user( char *s, size_t count, unsigned int base, s32 *res)
{
 return kstrtoint_from_user(s, count, base, res);
}



extern unsigned long simple_strtoul( char *,char **,unsigned int);
extern long simple_strtol( char *,char **,unsigned int);
extern unsigned long long simple_strtoull( char *,char **,unsigned int);
extern long long simple_strtoll( char *,char **,unsigned int);





extern int num_to_str(char *buf, int size, unsigned long long num);



extern __attribute__((format(printf, 2, 3))) int sprintf(char *buf, char * fmt, ...);
extern __attribute__((format(printf, 2, 0))) int vsprintf(char *buf, char *, va_list);
extern __attribute__((format(printf, 3, 4)))
int snprintf(char *buf, size_t size, char *fmt, ...);
extern __attribute__((format(printf, 3, 0)))
int vsnprintf(char *buf, size_t size, char *fmt, va_list args);
extern __attribute__((format(printf, 3, 4)))
int scnprintf(char *buf, size_t size, char *fmt, ...);
extern __attribute__((format(printf, 3, 0)))
int vscnprintf(char *buf, size_t size, char *fmt, va_list args);
extern __attribute__((format(printf, 2, 3)))
char *kasprintf(gfp_t gfp, char *fmt, ...);
extern char *kvasprintf(gfp_t gfp, char *fmt, va_list args);

extern __attribute__((format(scanf, 2, 3)))
int sscanf( char *, char *, ...);
extern __attribute__((format(scanf, 2, 0)))
int vsscanf( char *, char *, va_list);

extern int get_option(char **str, int *pint);
extern char *get_options( char *str, int nints, int *ints);
extern unsigned long long memparse( char *ptr, char **retptr);

extern int core_kernel_text(unsigned long addr);
extern int core_kernel_data(unsigned long addr);
extern int __kernel_text_address(unsigned long addr);
extern int kernel_text_address(unsigned long addr);
extern int func_ptr_is_kernel_text(void *ptr);

struct pid;
extern struct pid *session_of_pgrp(struct pid *pgrp);

unsigned long int_sqrt(unsigned long);

extern void bust_spinlocks(int yes);
extern int oops_in_progress;
extern int panic_timeout;
extern int panic_on_oops;
extern int panic_on_unrecovered_nmi;
extern int panic_on_io_nmi;
extern int sysctl_panic_on_stackoverflow;
extern char *print_tainted(void);
enum lockdep_ok {
 LOCKDEP_STILL_OK,
 LOCKDEP_NOW_UNRELIABLE
};
extern void add_taint(unsigned flag, enum lockdep_ok);
extern int test_taint(unsigned flag);
extern unsigned long get_taint(void);
extern int root_mountflags;

extern bool early_boot_irqs_disabled;


extern enum system_states {
 SYSTEM_BOOTING,
 SYSTEM_RUNNING,
 SYSTEM_HALT,
 SYSTEM_POWER_OFF,
 SYSTEM_RESTART,
} system_state;
extern char hex_asc[];



static inline char *hex_byte_pack(char *buf, u8 byte)
{
 *buf++ = hex_asc[((byte) & 0xf0) >> 4];
 *buf++ = hex_asc[((byte) & 0x0f)];
 return buf;
}

extern char hex_asc_upper[];



static inline char *hex_byte_pack_upper(char *buf, u8 byte)
{
 *buf++ = hex_asc_upper[((byte) & 0xf0) >> 4];
 *buf++ = hex_asc_upper[((byte) & 0x0f)];
 return buf;
}

static inline char * pack_hex_byte(char *buf, u8 byte)
{
 return hex_byte_pack(buf, byte);
}

extern int hex_to_bin(char ch);
extern int hex2bin(u8 *dst, char *src, size_t count);

int mac_pton( char *s, u8 *mac);
void tracing_off_permanent(void);




enum ftrace_dump_mode {
 DUMP_NONE,
 DUMP_ALL,
 DUMP_ORIG,
};


void tracing_on(void);
void tracing_off(void);
int tracing_is_on(void);
void tracing_snapshot(void);
void tracing_snapshot_alloc(void);

extern void tracing_start(void);
extern void tracing_stop(void);

static inline __attribute__((format(printf, 1, 2)))
void ____trace_printk_check_format( char *fmt, ...)
{
}
extern __attribute__((format(printf, 2, 3)))
int __trace_bprintk(unsigned long ip, char *fmt, ...);

extern __attribute__((format(printf, 2, 3)))
int __trace_printk(unsigned long ip, char *fmt, ...);
extern int __trace_bputs(unsigned long ip, char *str);
extern int __trace_puts(unsigned long ip, char *str, int size);

extern void trace_dump_stack(int skip);
extern int
__ftrace_vbprintk(unsigned long ip, char *fmt, va_list ap);

extern int
__ftrace_vprintk(unsigned long ip, char *fmt, va_list ap);

extern void ftrace_dump(enum ftrace_dump_mode oops_dump_mode);
extern void __bad_percpu_size(void);
static inline __attribute__((always_inline)) int x86_this_cpu_constant_test_bit(unsigned int nr,
                        unsigned long *addr)
{
 unsigned long *a = (unsigned long *)addr + nr / 64;


 return ((1UL << (nr % 64)) & ({ typeof((*a)) pfo_ret__; switch (sizeof((*a))) { case 1: asm("mov" "b ""%%""gs"":" "%P" "1"",%0" : "=q" (pfo_ret__) : "m"(*a)); break; case 2: asm("mov" "w ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"(*a)); break; case 4: asm("mov" "l ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"(*a)); break; case 8: asm("mov" "q ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"(*a)); break; default: __bad_percpu_size(); } pfo_ret__; })) != 0;



}

static inline int x86_this_cpu_variable_test_bit(int nr,
                        unsigned long *addr)
{
 int oldbit;

 asm ("bt ""%%""gs"":" "%P" "2"",%1\n\t"
   "sbb %0,%0"
   : "=r" (oldbit)
   : "m" (*(unsigned long *)addr), "Ir" (nr));

 return oldbit;
}











extern unsigned long __per_cpu_offset[256];
extern void setup_per_cpu_areas(void);


extern __attribute__((section(".data..percpu" ""))) __typeof__(unsigned long) this_cpu_off;





enum bug_trap_type {
 BUG_TRAP_TYPE_NONE = 0,
 BUG_TRAP_TYPE_WARN = 1,
 BUG_TRAP_TYPE_BUG = 2,
};

struct pt_regs;
static inline int is_warning_bug( struct bug_entry *bug)
{



        return 0;

}

 struct bug_entry *find_bug(unsigned long bugaddr);

enum bug_trap_type report_bug(unsigned long bug_addr, struct pt_regs *regs);


int is_valid_bugaddr(unsigned long addr);

struct timespec;
struct compat_timespec;




struct restart_block {
  template <typename, int = 0> struct __BYPASSrestart_block {};
  template <typename, int> friend struct __BYPASSrestart_block;
 long (*fn)(struct restart_block *);
 union {

  struct {
   u32 *uaddr;
   u32 val;
   u32 flags;
   u32 bitset;
   u64 time;
   u32 *uaddr2;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} futex;

  struct {
   clockid_t clockid;
   struct timespec *rmtp;

   struct compat_timespec *compat_rmtp;

   u64 expires;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} nanosleep;

  struct {
   struct pollfd *ufds;
   int nfds;
   int has_timeout;
   unsigned long tv_sec;
   unsigned long tv_nsec;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} poll;
 };

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

extern long do_no_restart_syscall(struct restart_block *parm);


extern unsigned long max_pfn;
extern unsigned long phys_base;

static inline unsigned long __phys_addr_nodebug(unsigned long x)
{
 unsigned long y = x - (0xffffffff80000000UL);


 x = y + ((x > y) ? phys_base : ((0xffffffff80000000UL) - ((unsigned long)(0xffff880000000000UL))));

 return x;
}
void clear_page(void *page);
void copy_page(void *to, void *from);






struct page;




struct range {
  template <typename, int = 0> struct __BYPASSrange {};
  template <typename, int> friend struct __BYPASSrange;
 u64 start;
 u64 end;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

int add_range(struct range *range, int az, int nr_range,
  u64 start, u64 end);


int add_range_with_merge(struct range *range, int az, int nr_range,
    u64 start, u64 end);

void subtract_range(struct range *range, int az, u64 start, u64 end);

int clean_sort_range(struct range *range, int az);

void sort_range(struct range *range, int nr_range);


static inline resource_size_t cap_resource(u64 val)
{
 if (val > ((resource_size_t)~0))
  return ((resource_size_t)~0);

 return val;
}
extern struct range pfn_mapped[];
extern int nr_pfn_mapped;

static inline void clear_user_page(void *page, unsigned long vaddr,
       struct page *pg)
{
 clear_page(page);
}

static inline void copy_user_page(void *to, void *from, unsigned long vaddr,
      struct page *topage)
{
 copy_page(to, from);
}
extern bool __virt_addr_valid(unsigned long kaddr);




static inline __attribute__((__const__))
int __get_order(unsigned long size)
{
 int order;

 size--;
 size >>= 12;



 order = fls64(size);

 return order;
}
struct task_struct;
struct exec_domain;






struct task_struct;
struct mm_struct;






struct vm86_regs {
  template <typename, int = 0> struct __BYPASSvm86_regs {};
  template <typename, int> friend struct __BYPASSvm86_regs;



 long ebx;
 long ecx;
 long edx;
 long esi;
 long edi;
 long ebp;
 long eax;
 long __null_ds;
 long __null_es;
 long __null_fs;
 long __null_gs;
 long orig_eax;
 long eip;
 unsigned short cs, __csh;
 long eflags;
 long esp;
 unsigned short ss, __ssh;



 unsigned short es, __esh;
 unsigned short ds, __dsh;
 unsigned short fs, __fsh;
 unsigned short gs, __gsh;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct revectored_struct {
  template <typename, int = 0> struct __BYPASSrevectored_struct {};
  template <typename, int> friend struct __BYPASSrevectored_struct;
 unsigned long __map[8];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct vm86_struct {
  template <typename, int = 0> struct __BYPASSvm86_struct {};
  template <typename, int> friend struct __BYPASSvm86_struct;
 struct vm86_regs regs;
 unsigned long flags;
 unsigned long screen_bitmap;
 unsigned long cpu_type;
 struct revectored_struct int_revectored;
 struct revectored_struct int21_revectored;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};






struct vm86plus_info_struct {
  template <typename, int = 0> struct __BYPASSvm86plus_info_struct {};
  template <typename, int> friend struct __BYPASSvm86plus_info_struct;
 unsigned long force_return_for_pic:1;
 unsigned long vm86dbg_active:1;
 unsigned long vm86dbg_TFpendig:1;
 unsigned long unused:28;
 unsigned long is_vm86pus:1;
 unsigned char vm86dbg_intxxtab[32];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct vm86plus_struct {
  template <typename, int = 0> struct __BYPASSvm86plus_struct {};
  template <typename, int> friend struct __BYPASSvm86plus_struct;
 struct vm86_regs regs;
 unsigned long flags;
 unsigned long screen_bitmap;
 unsigned long cpu_type;
 struct revectored_struct int_revectored;
 struct revectored_struct int21_revectored;
 struct vm86plus_info_struct vm86plus;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct kernel_vm86_regs {
  template <typename, int = 0> struct __BYPASSkernel_vm86_regs {};
  template <typename, int> friend struct __BYPASSkernel_vm86_regs;



 struct pt_regs pt;



 unsigned short es, __esh;
 unsigned short ds, __dsh;
 unsigned short fs, __fsh;
 unsigned short gs, __gsh;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct kernel_vm86_struct {
  template <typename, int = 0> struct __BYPASSkernel_vm86_struct {};
  template <typename, int> friend struct __BYPASSkernel_vm86_struct;
 struct kernel_vm86_regs regs;
 unsigned long flags;
 unsigned long screen_bitmap;
 unsigned long cpu_type;
 struct revectored_struct int_revectored;
 struct revectored_struct int21_revectored;
 struct vm86plus_info_struct vm86plus;
 struct pt_regs *regs32;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
static inline int handle_vm86_trap(struct kernel_vm86_regs *a, long b, int c)
{
 return 0;
}
struct math_emu_info {
  template <typename, int = 0> struct __BYPASSmath_emu_info {};
  template <typename, int> friend struct __BYPASSmath_emu_info;
 long ___orig_eip;
 union {
  struct pt_regs *regs;
  struct kernel_vm86_regs *vm86;
 };

  friend class ::Introspect;
  friend class ::MyIntrospect;
};





struct _fpx_sw_bytes {
  template <typename, int = 0> struct __BYPASS_fpx_sw_bytes {};
  template <typename, int> friend struct __BYPASS_fpx_sw_bytes;
 __u32 magic1;
 __u32 extended_size;


 __u64 xstate_bv;




 __u32 xstate_size;




 __u32 padding[7];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct _fpstate {
  template <typename, int = 0> struct __BYPASS_fpstate {};
  template <typename, int> friend struct __BYPASS_fpstate;
 __u16 cwd;
 __u16 swd;
 __u16 twd;

 __u16 fop;
 __u64 rip;
 __u64 rdp;
 __u32 mxcsr;
 __u32 mxcsr_mask;
 __u32 st_space[32];
 __u32 xmm_space[64];
 __u32 reserved2[12];
 union {
  __u32 reserved3[12];
  struct _fpx_sw_bytes sw_reserved;

 };

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct _xsave_hdr {
  template <typename, int = 0> struct __BYPASS_xsave_hdr {};
  template <typename, int> friend struct __BYPASS_xsave_hdr;
 __u64 xstate_bv;
 __u64 reserved1[2];
 __u64 reserved2[5];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct _ymmh_state {
  template <typename, int = 0> struct __BYPASS_ymmh_state {};
  template <typename, int> friend struct __BYPASS_ymmh_state;

 __u32 ymmh_space[64];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};







struct _xstate {
  template <typename, int = 0> struct __BYPASS_xstate {};
  template <typename, int> friend struct __BYPASS_xstate;
 struct _fpstate fpstate;
 struct _xsave_hdr xstate_hdr;
 struct _ymmh_state ymmh;


  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct sigcontext {
  template <typename, int = 0> struct __BYPASSsigcontext {};
  template <typename, int> friend struct __BYPASSsigcontext;
 unsigned long r8;
 unsigned long r9;
 unsigned long r10;
 unsigned long r11;
 unsigned long r12;
 unsigned long r13;
 unsigned long r14;
 unsigned long r15;
 unsigned long di;
 unsigned long si;
 unsigned long bp;
 unsigned long bx;
 unsigned long dx;
 unsigned long ax;
 unsigned long cx;
 unsigned long sp;
 unsigned long ip;
 unsigned long flags;
 unsigned short cs;
 unsigned short gs;
 unsigned short fs;
 unsigned short __pad0;
 unsigned long err;
 unsigned long trapno;
 unsigned long oldmask;
 unsigned long cr2;
 void *fpstate;
 unsigned long reserved1[8];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};







struct task_struct;

extern __attribute__((section(".data..percpu" ""))) __typeof__(struct task_struct *) current_task;







extern struct task_struct *get_current(void);






















extern unsigned int __invalid_size_argument_for_IOC;







extern int __bitmap_empty( unsigned long *bitmap, int bits);
extern int __bitmap_full( unsigned long *bitmap, int bits);
extern int __bitmap_equal( unsigned long *bitmap1,
                 unsigned long *bitmap2, int bits);
extern void __bitmap_complement(unsigned long *dst, unsigned long *src,
   int bits);
extern void __bitmap_shift_right(unsigned long *dst,
                        unsigned long *src, int shift, int bits);
extern void __bitmap_shift_left(unsigned long *dst,
                        unsigned long *src, int shift, int bits);
extern int __bitmap_and(unsigned long *dst, unsigned long *bitmap1,
   unsigned long *bitmap2, int bits);
extern void __bitmap_or(unsigned long *dst, unsigned long *bitmap1,
   unsigned long *bitmap2, int bits);
extern void __bitmap_xor(unsigned long *dst, unsigned long *bitmap1,
   unsigned long *bitmap2, int bits);
extern int __bitmap_andnot(unsigned long *dst, unsigned long *bitmap1,
   unsigned long *bitmap2, int bits);
extern int __bitmap_intersects( unsigned long *bitmap1,
   unsigned long *bitmap2, int bits);
extern int __bitmap_subset( unsigned long *bitmap1,
   unsigned long *bitmap2, int bits);
extern int __bitmap_weight( unsigned long *bitmap, int bits);

extern void bitmap_set(unsigned long *map, int i, int len);
extern void bitmap_clear(unsigned long *map, int start, int nr);
extern unsigned long bitmap_find_next_zero_area(unsigned long *map,
      unsigned long size,
      unsigned long start,
      unsigned int nr,
      unsigned long align_mask);

extern int bitmap_scnprintf(char *buf, unsigned int len,
   unsigned long *src, int nbits);
extern int __bitmap_parse( char *buf, unsigned int buflen, int is_user,
   unsigned long *dst, int nbits);
extern int bitmap_parse_user( char *ubuf, unsigned int ulen,
   unsigned long *dst, int nbits);
extern int bitmap_scnlistprintf(char *buf, unsigned int len,
   unsigned long *src, int nbits);
extern int bitmap_parselist( char *buf, unsigned long *maskp,
   int nmaskbits);
extern int bitmap_parselist_user( char *ubuf, unsigned int ulen,
   unsigned long *dst, int nbits);
extern void bitmap_remap(unsigned long *dst, unsigned long *src,
  unsigned long *old, unsigned long *_new, int bits);
extern int bitmap_bitremap(int oldbit,
  unsigned long *old, unsigned long *_new, int bits);
extern void bitmap_onto(unsigned long *dst, unsigned long *orig,
  unsigned long *relmap, int bits);
extern void bitmap_fold(unsigned long *dst, unsigned long *orig,
  int sz, int bits);
extern int bitmap_find_free_region(unsigned long *bitmap, int bits, int order);
extern void bitmap_release_region(unsigned long *bitmap, int pos, int order);
extern int bitmap_allocate_region(unsigned long *bitmap, int pos, int order);
extern void bitmap_copy_le(void *dst, unsigned long *src, int nbits);
extern int bitmap_ord_to_pos( unsigned long *bitmap, int n, int bits);
static inline void bitmap_zero(unsigned long *dst, int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64))
  *dst = 0UL;
 else {
  int len = (((nbits) + (8 * sizeof(long)) - 1) / (8 * sizeof(long))) * sizeof(unsigned long);
  memset(dst, 0, len);
 }
}

static inline void bitmap_fill(unsigned long *dst, int nbits)
{
 size_t nlongs = (((nbits) + (8 * sizeof(long)) - 1) / (8 * sizeof(long)));
 if (!(__builtin_constant_p(nbits) && (nbits) <= 64)) {
  int len = (nlongs - 1) * sizeof(unsigned long);
  memset(dst, 0xff, len);
 }
 dst[nlongs - 1] = ( ((nbits) % 64) ? (1UL<<((nbits) % 64))-1 : ~0UL );
}

static inline void bitmap_copy(unsigned long *dst, unsigned long *src,
   int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64))
  *dst = *src;
 else {
  int len = (((nbits) + (8 * sizeof(long)) - 1) / (8 * sizeof(long))) * sizeof(unsigned long);
  memcpy(dst, src, len);
 }
}

static inline int bitmap_and(unsigned long *dst, unsigned long *src1,
   unsigned long *src2, int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64))
  return (*dst = *src1 & *src2) != 0;
 return __bitmap_and(dst, src1, src2, nbits);
}

static inline void bitmap_or(unsigned long *dst, unsigned long *src1,
   unsigned long *src2, int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64))
  *dst = *src1 | *src2;
 else
  __bitmap_or(dst, src1, src2, nbits);
}

static inline void bitmap_xor(unsigned long *dst, unsigned long *src1,
   unsigned long *src2, int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64))
  *dst = *src1 ^ *src2;
 else
  __bitmap_xor(dst, src1, src2, nbits);
}

static inline int bitmap_andnot(unsigned long *dst, unsigned long *src1,
   unsigned long *src2, int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64))
  return (*dst = *src1 & ~(*src2)) != 0;
 return __bitmap_andnot(dst, src1, src2, nbits);
}

static inline void bitmap_complement(unsigned long *dst, unsigned long *src,
   int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64))
  *dst = ~(*src) & ( ((nbits) % 64) ? (1UL<<((nbits) % 64))-1 : ~0UL );
 else
  __bitmap_complement(dst, src, nbits);
}

static inline int bitmap_equal( unsigned long *src1,
   unsigned long *src2, int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64))
  return ! ((*src1 ^ *src2) & ( ((nbits) % 64) ? (1UL<<((nbits) % 64))-1 : ~0UL ));
 else
  return __bitmap_equal(src1, src2, nbits);
}

static inline int bitmap_intersects( unsigned long *src1,
   unsigned long *src2, int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64))
  return ((*src1 & *src2) & ( ((nbits) % 64) ? (1UL<<((nbits) % 64))-1 : ~0UL )) != 0;
 else
  return __bitmap_intersects(src1, src2, nbits);
}

static inline int bitmap_subset( unsigned long *src1,
   unsigned long *src2, int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64))
  return ! ((*src1 & ~(*src2)) & ( ((nbits) % 64) ? (1UL<<((nbits) % 64))-1 : ~0UL ));
 else
  return __bitmap_subset(src1, src2, nbits);
}

static inline int bitmap_empty( unsigned long *src, int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64))
  return ! (*src & ( ((nbits) % 64) ? (1UL<<((nbits) % 64))-1 : ~0UL ));
 else
  return __bitmap_empty(src, nbits);
}

static inline int bitmap_full( unsigned long *src, int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64))
  return ! (~(*src) & ( ((nbits) % 64) ? (1UL<<((nbits) % 64))-1 : ~0UL ));
 else
  return __bitmap_full(src, nbits);
}

static inline int bitmap_weight( unsigned long *src, int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64))
  return hweight_long(*src & ( ((nbits) % 64) ? (1UL<<((nbits) % 64))-1 : ~0UL ));
 return __bitmap_weight(src, nbits);
}

static inline void bitmap_shift_right(unsigned long *dst,
   unsigned long *src, int n, int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64))
  *dst = *src >> n;
 else
  __bitmap_shift_right(dst, src, n, nbits);
}

static inline void bitmap_shift_left(unsigned long *dst,
   unsigned long *src, int n, int nbits)
{
 if ((__builtin_constant_p(nbits) && (nbits) <= 64))
  *dst = (*src << n) & ( ((nbits) % 64) ? (1UL<<((nbits) % 64))-1 : ~0UL );
 else
  __bitmap_shift_left(dst, src, n, nbits);
}

static inline int bitmap_parse( char *buf, unsigned int buflen,
   unsigned long *maskp, int nmaskbits)
{
 return __bitmap_parse(buf, buflen, 0, maskp, nmaskbits);
}


typedef struct cpumask {
  template <typename, int = 0> struct __BYPASScpumask {};
  template <typename, int> friend struct __BYPASScpumask; unsigned long bits[(((256) + (8 * sizeof(long)) - 1) / (8 * sizeof(long)))]; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} cpumask_t;
extern int nr_cpu_ids;
extern struct cpumask * cpu_possible_mask;
extern struct cpumask * cpu_online_mask;
extern struct cpumask * cpu_present_mask;
extern struct cpumask * cpu_active_mask;
static inline unsigned int cpumask_check(unsigned int cpu)
{



 return cpu;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_55_0 {
  typedef TJP__ZN7cpumask4bitsE_55_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_55(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_55_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline unsigned int cpumask_first( struct cpumask *srcp)
{
 return find_first_bit((__get__ZN7cpumask4bitsE_55((srcp)->bits)), 256);
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_56_0 {
  typedef TJP__ZN7cpumask4bitsE_56_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_56(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_56_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline unsigned int cpumask_next(int n, struct cpumask *srcp)
{

 if (n != -1)
  cpumask_check(n);
 return find_next_bit((__get__ZN7cpumask4bitsE_56((srcp)->bits)), 256, n+1);
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_57_0 {
  typedef TJP__ZN7cpumask4bitsE_57_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_57(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_57_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline unsigned int cpumask_next_zero(int n, struct cpumask *srcp)
{

 if (n != -1)
  cpumask_check(n);
 return find_next_zero_bit((__get__ZN7cpumask4bitsE_57((srcp)->bits)), 256, n+1);
}

int cpumask_next_and(int n, struct cpumask *, struct cpumask *);
int cpumask_any_but( struct cpumask *mask, unsigned int cpu);

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_58_0 {
  typedef TJP__ZN7cpumask4bitsE_58_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_58(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_58_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void cpumask_set_cpu(unsigned int cpu, struct cpumask *dstp)
{
 set_bit(cpumask_check(cpu), (__get__ZN7cpumask4bitsE_58((dstp)->bits)));
}







template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_59_0 {
  typedef TJP__ZN7cpumask4bitsE_59_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_59(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_59_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void cpumask_clear_cpu(int cpu, struct cpumask *dstp)
{
 clear_bit(cpumask_check(cpu), (__get__ZN7cpumask4bitsE_59((dstp)->bits)));
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_60_0 {
  typedef TJP__ZN7cpumask4bitsE_60_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_60(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_60_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int cpumask_test_and_set_cpu(int cpu, struct cpumask *cpumask)
{
 return test_and_set_bit(cpumask_check(cpu), (__get__ZN7cpumask4bitsE_60((cpumask)->bits)));
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_61_0 {
  typedef TJP__ZN7cpumask4bitsE_61_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_61(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_61_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int cpumask_test_and_clear_cpu(int cpu, struct cpumask *cpumask)
{
 return test_and_clear_bit(cpumask_check(cpu), (__get__ZN7cpumask4bitsE_61((cpumask)->bits)));
}






template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_62_0 {
  typedef TJP__ZN7cpumask4bitsE_62_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_62(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_62_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void cpumask_setall(struct cpumask *dstp)
{
 bitmap_fill((__get__ZN7cpumask4bitsE_62((dstp)->bits)), 256);
}






template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_63_0 {
  typedef TJP__ZN7cpumask4bitsE_63_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_63(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_63_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void cpumask_clear(struct cpumask *dstp)
{
 bitmap_zero((__get__ZN7cpumask4bitsE_63((dstp)->bits)), 256);
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_64_0 {
  typedef TJP__ZN7cpumask4bitsE_64_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_64(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_64_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_65_0 {
  typedef TJP__ZN7cpumask4bitsE_65_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_65(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_65_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_66_0 {
  typedef TJP__ZN7cpumask4bitsE_66_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_66(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_66_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int cpumask_and(struct cpumask *dstp,
          struct cpumask *src1p,
          struct cpumask *src2p)
{
 return bitmap_and((__get__ZN7cpumask4bitsE_64((dstp)->bits)), (__get__ZN7cpumask4bitsE_65((src1p)->bits)),
           (__get__ZN7cpumask4bitsE_66((src2p)->bits)), 256);
}








template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_67_0 {
  typedef TJP__ZN7cpumask4bitsE_67_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_67(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_67_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_68_0 {
  typedef TJP__ZN7cpumask4bitsE_68_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_68(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_68_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_69_0 {
  typedef TJP__ZN7cpumask4bitsE_69_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_69(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_69_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void cpumask_or(struct cpumask *dstp, struct cpumask *src1p,
         struct cpumask *src2p)
{
 bitmap_or((__get__ZN7cpumask4bitsE_67((dstp)->bits)), (__get__ZN7cpumask4bitsE_68((src1p)->bits)),
          (__get__ZN7cpumask4bitsE_69((src2p)->bits)), 256);
}








template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_70_0 {
  typedef TJP__ZN7cpumask4bitsE_70_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_70(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_70_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_71_0 {
  typedef TJP__ZN7cpumask4bitsE_71_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_71(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_71_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_72_0 {
  typedef TJP__ZN7cpumask4bitsE_72_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_72(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_72_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void cpumask_xor(struct cpumask *dstp,
          struct cpumask *src1p,
          struct cpumask *src2p)
{
 bitmap_xor((__get__ZN7cpumask4bitsE_70((dstp)->bits)), (__get__ZN7cpumask4bitsE_71((src1p)->bits)),
           (__get__ZN7cpumask4bitsE_72((src2p)->bits)), 256);
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_73_0 {
  typedef TJP__ZN7cpumask4bitsE_73_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_73(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_73_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_74_0 {
  typedef TJP__ZN7cpumask4bitsE_74_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_74(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_74_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_75_0 {
  typedef TJP__ZN7cpumask4bitsE_75_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_75(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_75_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int cpumask_andnot(struct cpumask *dstp,
      struct cpumask *src1p,
      struct cpumask *src2p)
{
 return bitmap_andnot((__get__ZN7cpumask4bitsE_73((dstp)->bits)), (__get__ZN7cpumask4bitsE_74((src1p)->bits)),
       (__get__ZN7cpumask4bitsE_75((src2p)->bits)), 256);
}







template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_76_0 {
  typedef TJP__ZN7cpumask4bitsE_76_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_76(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_76_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_77_0 {
  typedef TJP__ZN7cpumask4bitsE_77_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_77(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_77_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void cpumask_complement(struct cpumask *dstp,
          struct cpumask *srcp)
{
 bitmap_complement((__get__ZN7cpumask4bitsE_76((dstp)->bits)), (__get__ZN7cpumask4bitsE_77((srcp)->bits)),
           256);
}







template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_78_0 {
  typedef TJP__ZN7cpumask4bitsE_78_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_78(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_78_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_79_0 {
  typedef TJP__ZN7cpumask4bitsE_79_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_79(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_79_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline bool cpumask_equal( struct cpumask *src1p,
    struct cpumask *src2p)
{
 return bitmap_equal((__get__ZN7cpumask4bitsE_78((src1p)->bits)), (__get__ZN7cpumask4bitsE_79((src2p)->bits)),
       256);
}







template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_80_0 {
  typedef TJP__ZN7cpumask4bitsE_80_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_80(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_80_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_81_0 {
  typedef TJP__ZN7cpumask4bitsE_81_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_81(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_81_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline bool cpumask_intersects( struct cpumask *src1p,
         struct cpumask *src2p)
{
 return bitmap_intersects((__get__ZN7cpumask4bitsE_80((src1p)->bits)), (__get__ZN7cpumask4bitsE_81((src2p)->bits)),
            256);
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_82_0 {
  typedef TJP__ZN7cpumask4bitsE_82_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_82(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_82_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_83_0 {
  typedef TJP__ZN7cpumask4bitsE_83_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_83(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_83_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int cpumask_subset( struct cpumask *src1p,
     struct cpumask *src2p)
{
 return bitmap_subset((__get__ZN7cpumask4bitsE_82((src1p)->bits)), (__get__ZN7cpumask4bitsE_83((src2p)->bits)),
        256);
}






template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_84_0 {
  typedef TJP__ZN7cpumask4bitsE_84_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_84(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_84_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline bool cpumask_empty( struct cpumask *srcp)
{
 return bitmap_empty((__get__ZN7cpumask4bitsE_84((srcp)->bits)), 256);
}






template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_85_0 {
  typedef TJP__ZN7cpumask4bitsE_85_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_85(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_85_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline bool cpumask_full( struct cpumask *srcp)
{
 return bitmap_full((__get__ZN7cpumask4bitsE_85((srcp)->bits)), 256);
}






template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_86_0 {
  typedef TJP__ZN7cpumask4bitsE_86_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_86(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_86_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline unsigned int cpumask_weight( struct cpumask *srcp)
{
 return bitmap_weight((__get__ZN7cpumask4bitsE_86((srcp)->bits)), 256);
}








template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_87_0 {
  typedef TJP__ZN7cpumask4bitsE_87_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_87(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_87_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_88_0 {
  typedef TJP__ZN7cpumask4bitsE_88_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_88(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_88_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void cpumask_shift_right(struct cpumask *dstp,
           struct cpumask *srcp, int n)
{
 bitmap_shift_right((__get__ZN7cpumask4bitsE_87((dstp)->bits)), (__get__ZN7cpumask4bitsE_88((srcp)->bits)), n,
            256);
}








template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_89_0 {
  typedef TJP__ZN7cpumask4bitsE_89_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_89(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_89_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_90_0 {
  typedef TJP__ZN7cpumask4bitsE_90_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_90(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_90_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void cpumask_shift_left(struct cpumask *dstp,
          struct cpumask *srcp, int n)
{
 bitmap_shift_left((__get__ZN7cpumask4bitsE_89((dstp)->bits)), (__get__ZN7cpumask4bitsE_90((srcp)->bits)), n,
           256);
}







template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_91_0 {
  typedef TJP__ZN7cpumask4bitsE_91_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_91(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_91_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_92_0 {
  typedef TJP__ZN7cpumask4bitsE_92_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_92(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_92_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void cpumask_copy(struct cpumask *dstp,
    struct cpumask *srcp)
{
 bitmap_copy((__get__ZN7cpumask4bitsE_91((dstp)->bits)), (__get__ZN7cpumask4bitsE_92((srcp)->bits)), 256);
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_93_0 {
  typedef TJP__ZN7cpumask4bitsE_93_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_93(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_93_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int cpumask_scnprintf(char *buf, int len,
        struct cpumask *srcp)
{
 return bitmap_scnprintf(buf, len, (__get__ZN7cpumask4bitsE_93((srcp)->bits)), 256);
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_94_0 {
  typedef TJP__ZN7cpumask4bitsE_94_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_94(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_94_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int cpumask_parse_user( char *buf, int len,
         struct cpumask *dstp)
{
 return bitmap_parse_user(buf, len, (__get__ZN7cpumask4bitsE_94((dstp)->bits)), 256);
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_95_0 {
  typedef TJP__ZN7cpumask4bitsE_95_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_95(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_95_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int cpumask_parselist_user( char *buf, int len,
         struct cpumask *dstp)
{
 return bitmap_parselist_user(buf, len, (__get__ZN7cpumask4bitsE_95((dstp)->bits)),
       256);
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_96_0 {
  typedef TJP__ZN7cpumask4bitsE_96_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_96(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_96_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int cpulist_scnprintf(char *buf, int len,
        struct cpumask *srcp)
{
 return bitmap_scnlistprintf(buf, len, (__get__ZN7cpumask4bitsE_96((srcp)->bits)),
        256);
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_97_0 {
  typedef TJP__ZN7cpumask4bitsE_97_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_97(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_97_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int cpumask_parse( char *buf, struct cpumask *dstp)
{
 char *nl = strchr(buf, '\n');
 int len = nl ? nl - buf : strlen(buf);

 return bitmap_parse(buf, len, (__get__ZN7cpumask4bitsE_97((dstp)->bits)), 256);
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_98_0 {
  typedef TJP__ZN7cpumask4bitsE_98_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_98(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_98_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int cpulist_parse( char *buf, struct cpumask *dstp)
{
 return bitmap_parselist(buf, (__get__ZN7cpumask4bitsE_98((dstp)->bits)), 256);
}






static inline size_t cpumask_size(void)
{


 return (((256) + (8 * sizeof(long)) - 1) / (8 * sizeof(long))) * sizeof(long);
}
typedef struct cpumask cpumask_var_t[1];

static inline bool alloc_cpumask_var(cpumask_var_t *mask, gfp_t flags)
{
 return _true;
}

static inline bool alloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags,
       int node)
{
 return _true;
}

static inline bool zalloc_cpumask_var(cpumask_var_t *mask, gfp_t flags)
{
 cpumask_clear(*mask);
 return _true;
}

static inline bool zalloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags,
       int node)
{
 cpumask_clear(*mask);
 return _true;
}

static inline void alloc_bootmem_cpumask_var(cpumask_var_t *mask)
{
}

static inline void free_cpumask_var(cpumask_var_t mask)
{
}

static inline void free_bootmem_cpumask_var(cpumask_var_t mask)
{
}




extern unsigned long cpu_all_bits[(((256) + (8 * sizeof(long)) - 1) / (8 * sizeof(long)))];
void set_cpu_possible(unsigned int cpu, bool possible);
void set_cpu_present(unsigned int cpu, bool present);
void set_cpu_online(unsigned int cpu, bool online);
void set_cpu_active(unsigned int cpu, bool active);
void init_cpu_present( struct cpumask *src);
void init_cpu_possible( struct cpumask *src);
void init_cpu_online( struct cpumask *src);
static inline int __check_is_bitmap( unsigned long *bitmap)
{
 return 1;
}
extern unsigned long
 cpu_bit_bitmap[64 +1][(((256) + (8 * sizeof(long)) - 1) / (8 * sizeof(long)))];

static inline struct cpumask *get_cpu_mask(unsigned int cpu)
{
 unsigned long *p = cpu_bit_bitmap[1 + cpu % 64];
 p -= cpu / 64;
 return ((struct cpumask *)(1 ? (p) : (void *)sizeof(__check_is_bitmap(p))));
}
int __first_cpu( cpumask_t *srcp);
int __next_cpu(int n, cpumask_t *srcp);
int __next_cpu_nr(int n, cpumask_t *srcp);

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_104_0 {
  typedef TJP__ZN7cpumask4bitsE_104_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_104(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_104_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void __cpu_set(int cpu, cpumask_t *dstp)
{
 set_bit(cpu, __get__ZN7cpumask4bitsE_104(dstp->bits));
}



template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_105_0 {
  typedef TJP__ZN7cpumask4bitsE_105_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_105(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_105_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void __cpu_clear(int cpu, cpumask_t *dstp)
{
 clear_bit(cpu, __get__ZN7cpumask4bitsE_105(dstp->bits));
}



template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_106_0 {
  typedef TJP__ZN7cpumask4bitsE_106_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_106(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_106_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void __cpus_setall(cpumask_t *dstp, int nbits)
{
 bitmap_fill(__get__ZN7cpumask4bitsE_106(dstp->bits), nbits);
}



template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_107_0 {
  typedef TJP__ZN7cpumask4bitsE_107_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_107(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_107_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void __cpus_clear(cpumask_t *dstp, int nbits)
{
 bitmap_zero(__get__ZN7cpumask4bitsE_107(dstp->bits), nbits);
}






template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_108_0 {
  typedef TJP__ZN7cpumask4bitsE_108_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_108(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_108_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __cpu_test_and_set(int cpu, cpumask_t *addr)
{
 return test_and_set_bit(cpu, __get__ZN7cpumask4bitsE_108(addr->bits));
}



template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_109_0 {
  typedef TJP__ZN7cpumask4bitsE_109_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_109(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_109_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_110_0 {
  typedef TJP__ZN7cpumask4bitsE_110_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_110(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_110_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_111_0 {
  typedef TJP__ZN7cpumask4bitsE_111_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_111(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_111_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __cpus_and(cpumask_t *dstp, cpumask_t *src1p,
     cpumask_t *src2p, int nbits)
{
 return bitmap_and(__get__ZN7cpumask4bitsE_109(dstp->bits), __get__ZN7cpumask4bitsE_110(src1p->bits), __get__ZN7cpumask4bitsE_111(src2p->bits), nbits);
}



template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_112_0 {
  typedef TJP__ZN7cpumask4bitsE_112_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_112(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_112_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_113_0 {
  typedef TJP__ZN7cpumask4bitsE_113_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_113(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_113_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_114_0 {
  typedef TJP__ZN7cpumask4bitsE_114_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_114(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_114_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void __cpus_or(cpumask_t *dstp, cpumask_t *src1p,
     cpumask_t *src2p, int nbits)
{
 bitmap_or(__get__ZN7cpumask4bitsE_112(dstp->bits), __get__ZN7cpumask4bitsE_113(src1p->bits), __get__ZN7cpumask4bitsE_114(src2p->bits), nbits);
}



template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_115_0 {
  typedef TJP__ZN7cpumask4bitsE_115_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_115(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_115_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_116_0 {
  typedef TJP__ZN7cpumask4bitsE_116_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_116(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_116_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_117_0 {
  typedef TJP__ZN7cpumask4bitsE_117_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_117(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_117_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void __cpus_xor(cpumask_t *dstp, cpumask_t *src1p,
     cpumask_t *src2p, int nbits)
{
 bitmap_xor(__get__ZN7cpumask4bitsE_115(dstp->bits), __get__ZN7cpumask4bitsE_116(src1p->bits), __get__ZN7cpumask4bitsE_117(src2p->bits), nbits);
}




template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_118_0 {
  typedef TJP__ZN7cpumask4bitsE_118_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_118(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_118_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_119_0 {
  typedef TJP__ZN7cpumask4bitsE_119_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_119(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_119_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_120_0 {
  typedef TJP__ZN7cpumask4bitsE_120_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_120(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_120_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __cpus_andnot(cpumask_t *dstp, cpumask_t *src1p,
     cpumask_t *src2p, int nbits)
{
 return bitmap_andnot(__get__ZN7cpumask4bitsE_118(dstp->bits), __get__ZN7cpumask4bitsE_119(src1p->bits), __get__ZN7cpumask4bitsE_120(src2p->bits), nbits);
}



template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_121_0 {
  typedef TJP__ZN7cpumask4bitsE_121_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_121(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_121_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_122_0 {
  typedef TJP__ZN7cpumask4bitsE_122_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_122(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_122_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __cpus_equal( cpumask_t *src1p,
     cpumask_t *src2p, int nbits)
{
 return bitmap_equal(__get__ZN7cpumask4bitsE_121(src1p->bits), __get__ZN7cpumask4bitsE_122(src2p->bits), nbits);
}



template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_123_0 {
  typedef TJP__ZN7cpumask4bitsE_123_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_123(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_123_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_124_0 {
  typedef TJP__ZN7cpumask4bitsE_124_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_124(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_124_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __cpus_intersects( cpumask_t *src1p,
     cpumask_t *src2p, int nbits)
{
 return bitmap_intersects(__get__ZN7cpumask4bitsE_123(src1p->bits), __get__ZN7cpumask4bitsE_124(src2p->bits), nbits);
}



template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_125_0 {
  typedef TJP__ZN7cpumask4bitsE_125_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_125(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_125_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_126_0 {
  typedef TJP__ZN7cpumask4bitsE_126_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_126(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_126_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __cpus_subset( cpumask_t *src1p,
     cpumask_t *src2p, int nbits)
{
 return bitmap_subset(__get__ZN7cpumask4bitsE_125(src1p->bits), __get__ZN7cpumask4bitsE_126(src2p->bits), nbits);
}



template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_127_0 {
  typedef TJP__ZN7cpumask4bitsE_127_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_127(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_127_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __cpus_empty( cpumask_t *srcp, int nbits)
{
 return bitmap_empty(__get__ZN7cpumask4bitsE_127(srcp->bits), nbits);
}



template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_128_0 {
  typedef TJP__ZN7cpumask4bitsE_128_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_128(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_128_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __cpus_weight( cpumask_t *srcp, int nbits)
{
 return bitmap_weight(__get__ZN7cpumask4bitsE_128(srcp->bits), nbits);
}




template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_129_0 {
  typedef TJP__ZN7cpumask4bitsE_129_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_129(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_129_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_130_0 {
  typedef TJP__ZN7cpumask4bitsE_130_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_130(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_130_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void __cpus_shift_left(cpumask_t *dstp,
     cpumask_t *srcp, int n, int nbits)
{
 bitmap_shift_left(__get__ZN7cpumask4bitsE_129(dstp->bits), __get__ZN7cpumask4bitsE_130(srcp->bits), n, nbits);
}

extern cpumask_var_t cpu_callin_mask;
extern cpumask_var_t cpu_callout_mask;
extern cpumask_var_t cpu_initialized_mask;
extern cpumask_var_t cpu_sibling_setup_mask;

extern void setup_cpu_local_masks(void);

struct msr {
  template <typename, int = 0> struct __BYPASSmsr {};
  template <typename, int> friend struct __BYPASSmsr;
 union {
  struct {
   u32 l;
   u32 h;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
};
  u64 q;
 };

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct msr_info {
  template <typename, int = 0> struct __BYPASSmsr_info {};
  template <typename, int> friend struct __BYPASSmsr_info;
 u32 msr_no;
 struct msr reg;
 struct msr *msrs;
 int err;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct msr_regs_info {
  template <typename, int = 0> struct __BYPASSmsr_regs_info {};
  template <typename, int> friend struct __BYPASSmsr_regs_info;
 u32 *regs;
 int err;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

static inline unsigned long long native_read_tscp(unsigned int *aux)
{
 unsigned long low, high;
 asm (".byte 0x0f,0x01,0xf9"
       : "=a" (low), "=d" (high), "=c" (*aux));
 return low | ((u64)high << 32);
}
static inline unsigned long long native_read_msr(unsigned int msr)
{
 unsigned low, high;

 asm ("rdmsr" : "=a" (low), "=d" (high) : "c" (msr));
 return ((low) | ((u64)(high) << 32));
}

static inline unsigned long long native_read_msr_safe(unsigned int msr,
            int *err)
{
 unsigned low, high;

 asm ("2: rdmsr ; xor %[err],%[err]\n"
       "1:\n\t"
       ".section .fixup,\"ax\"\n\t"
       "3:  mov %[fault],%[err] ; jmp 1b\n\t"
       ".previous\n\t"
       " .pushsection \"__ex_table\",\"a\"\n" " .balign 8\n" " .long (" "2b" ") - .\n" " .long (" "3b" ") - .\n" " .popsection\n"
       : [err] "=r" (*err), "=a" (low), "=d" (high)
       : "c" (msr), [fault] "i" (-5));
 return ((low) | ((u64)(high) << 32));
}

static inline void native_write_msr(unsigned int msr,
        unsigned low, unsigned high)
{
 asm ("wrmsr" : : "c" (msr), "a"(low), "d" (high) : "memory");
}


 static inline int native_write_msr_safe(unsigned int msr,
     unsigned low, unsigned high)
{
 int err;
 asm ("2: wrmsr ; xor %[err],%[err]\n"
       "1:\n\t"
       ".section .fixup,\"ax\"\n\t"
       "3:  mov %[fault],%[err] ; jmp 1b\n\t"
       ".previous\n\t"
       " .pushsection \"__ex_table\",\"a\"\n" " .balign 8\n" " .long (" "2b" ") - .\n" " .long (" "3b" ") - .\n" " .popsection\n"
       : [err] "=a" (err)
       : "c" (msr), "0" (low), "d" (high),
         [fault] "i" (-5)
       : "memory");
 return err;
}

extern unsigned long long native_read_tsc(void);

extern int rdmsr_safe_regs(u32 regs[8]);
extern int wrmsr_safe_regs(u32 regs[8]);

static inline __attribute__((always_inline)) unsigned long long __native_read_tsc(void)
{
 unsigned low, high;

 asm ("rdtsc" : "=a" (low), "=d" (high));

 return ((low) | ((u64)(high) << 32));
}

static inline unsigned long long native_read_pmc(int counter)
{
 unsigned low, high;

 asm ("rdpmc" : "=a" (low), "=d" (high) : "c" (counter));
 return ((low) | ((u64)(high) << 32));
}


static inline int paravirt_enabled(void)
{
 return pv_info.paravirt_enabled;
}

static inline void load_sp0(struct tss_struct *tss,
        struct thread_struct *thread)
{
 ;
}


static inline void __cpuid(unsigned int *eax, unsigned int *ebx,
      unsigned int *ecx, unsigned int *edx)
{
 ;
}




static inline unsigned long paravirt_get_debugreg(int reg)
{
 return 0;
}

static inline void set_debugreg(unsigned long val, int reg)
{
 ;
}

static inline void clts(void)
{
 ;
}

static inline unsigned long read_cr0(void)
{
 return 0;
}

static inline void write_cr0(unsigned long x)
{
 ;
}

static inline unsigned long read_cr2(void)
{
 return 0;
}

static inline void write_cr2(unsigned long x)
{
 ;
}

static inline unsigned long read_cr3(void)
{
 return 0;
}

static inline void write_cr3(unsigned long x)
{
 ;
}

static inline unsigned long read_cr4(void)
{
 return 0;
}
static inline unsigned long read_cr4_safe(void)
{
 return 0;
}

static inline void write_cr4(unsigned long x)
{
 ;
}


static inline unsigned long read_cr8(void)
{
 return 0;
}

static inline void write_cr8(unsigned long x)
{
 ;
}


static inline void arch_safe_halt(void)
{
 ;
}

static inline void halt(void)
{
 ;
}

static inline void wbinvd(void)
{
 ;
}



static inline u64 paravirt_read_msr(unsigned msr, int *err)
{
 return 0;
}

static inline int paravirt_write_msr(unsigned msr, unsigned low, unsigned high)
{
 return 0;
}
static inline int rdmsrl_safe(unsigned msr, unsigned long long *p)
{
 int err;

 *p = paravirt_read_msr(msr, &err);
 return err;
}

static inline u64 paravirt_read_tsc(void)
{
 return 0;
}
static inline unsigned long long paravirt_sched_clock(void)
{
 return 0;
}

struct static_key;
extern struct static_key paravirt_steal_enabled;
extern struct static_key paravirt_steal_rq_enabled;

static inline u64 paravirt_steal_clock(int cpu)
{
 return 0;
}

static inline unsigned long long paravirt_read_pmc(int counter)
{
 return 0;
}
static inline unsigned long long paravirt_rdtscp(unsigned int *aux)
{
 return 0;
}
static inline void paravirt_alloc_ldt(struct desc_struct *ldt, unsigned entries)
{
 ;
}

static inline void paravirt_free_ldt(struct desc_struct *ldt, unsigned entries)
{
 ;
}

static inline void load_TR_desc(void)
{
 ;
}
static inline void load_gdt( struct desc_ptr *dtr)
{
 ;
}
static inline void load_idt( struct desc_ptr *dtr)
{
 ;
}
static inline void set_ldt( void *addr, unsigned entries)
{
 ;
}
static inline void store_idt(struct desc_ptr *dtr)
{
 ;
}
static inline unsigned long paravirt_store_tr(void)
{
 return 0;
}

static inline void load_TLS(struct thread_struct *t, unsigned cpu)
{
 ;
}


static inline void load_gs_index(unsigned int gs)
{
 ;
}


static inline void write_ldt_entry(struct desc_struct *dt, int entry,
       void *desc)
{
 ;
}

static inline void write_gdt_entry(struct desc_struct *dt, int entry,
       void *desc, int type)
{
 ;
}

static inline void write_idt_entry(gate_desc *dt, int entry, gate_desc *g)
{
 ;
}
static inline void set_iopl_mask(unsigned mask)
{
 ;
}


static inline void slow_down_io(void)
{
 pv_cpu_ops.io_delay();





}


static inline void startup_ipi_hook(int phys_apicid, unsigned long start_eip,
        unsigned long start_esp)
{

                                        ;
}


static inline void paravirt_activate_mm(struct mm_struct *prev,
     struct mm_struct *next)
{
 ;
}

static inline void arch_dup_mmap(struct mm_struct *oldmm,
     struct mm_struct *mm)
{
 ;
}

static inline void arch_exit_mmap(struct mm_struct *mm)
{
 ;
}

static inline void __flush_tlb(void)
{
 ;
}
static inline void __flush_tlb_global(void)
{
 ;
}
static inline void __flush_tlb_single(unsigned long addr)
{
 ;
}

static inline void flush_tlb_others( struct cpumask *cpumask,
        struct mm_struct *mm,
        unsigned long start,
        unsigned long end)
{
 ;
}

static inline int paravirt_pgd_alloc(struct mm_struct *mm)
{
 return 0;
}

static inline void paravirt_pgd_free(struct mm_struct *mm, pgd_t *pgd)
{
 ;
}

static inline void paravirt_alloc_pte(struct mm_struct *mm, unsigned long pfn)
{
 ;
}
static inline void paravirt_release_pte(unsigned long pfn)
{
 ;
}

static inline void paravirt_alloc_pmd(struct mm_struct *mm, unsigned long pfn)
{
 ;
}

static inline void paravirt_release_pmd(unsigned long pfn)
{
 ;
}

static inline void paravirt_alloc_pud(struct mm_struct *mm, unsigned long pfn)
{
 ;
}
static inline void paravirt_release_pud(unsigned long pfn)
{
 ;
}

static inline void pte_update(struct mm_struct *mm, unsigned long addr,
         pte_t *ptep)
{
 ;
}
static inline void pmd_update(struct mm_struct *mm, unsigned long addr,
         pmd_t *pmdp)
{
 ;
}

static inline void pte_update_defer(struct mm_struct *mm, unsigned long addr,
        pte_t *ptep)
{
 ;
}

static inline void pmd_update_defer(struct mm_struct *mm, unsigned long addr,
        pmd_t *pmdp)
{
 ;
}

static inline pte_t __pte(pteval_t val)
{
        return (pte_t) { 0 };

}

static inline pteval_t pte_val(pte_t pte)
{
        return 0;

}

static inline pgd_t __pgd(pgdval_t val)
{
        return (pgd_t) { 0 };

}

static inline pgdval_t pgd_val(pgd_t pgd)
{
        return 0;

}


static inline pte_t ptep_modify_prot_start(struct mm_struct *mm, unsigned long addr,
        pte_t *ptep)
{
        return (pte_t) { 0 };

}

static inline void ptep_modify_prot_commit(struct mm_struct *mm, unsigned long addr,
        pte_t *ptep, pte_t pte)
{
 if (sizeof(pteval_t) > sizeof(long))

  pv_mmu_ops.ptep_modify_prot_commit(mm, addr, ptep, pte);
 else
 
                               ;
}

static inline void set_pte(pte_t *ptep, pte_t pte)
{
 if (sizeof(pteval_t) > sizeof(long))
 
                                   ;
 else
 
               ;
}

static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,
         pte_t *ptep, pte_t pte)
{
 if (sizeof(pteval_t) > sizeof(long))

  pv_mmu_ops.set_pte_at(mm, addr, ptep, pte);
 else
  ;
}

static inline void set_pmd_at(struct mm_struct *mm, unsigned long addr,
         pmd_t *pmdp, pmd_t pmd)
{
 if (sizeof(pmdval_t) > sizeof(long))

  pv_mmu_ops.set_pmd_at(mm, addr, pmdp, pmd);
 else
 
                           ;
}

static inline void set_pmd(pmd_t *pmdp, pmd_t pmd)
{
 pmdval_t val = native_pmd_val(pmd);

 if (sizeof(pmdval_t) > sizeof(long))
  ;
 else
  ;
}


static inline pmd_t __pmd(pmdval_t val)
{
        return (pmd_t) { 0 };

}

static inline pmdval_t pmd_val(pmd_t pmd)
{
        return 0;

}

static inline void set_pud(pud_t *pudp, pud_t pud)
{
 pudval_t val = native_pud_val(pud);

 if (sizeof(pudval_t) > sizeof(long))
 
                           ;
 else
 
           ;
}

static inline pud_t __pud(pudval_t val)
{
        return (pud_t) { 0 };

}

static inline pudval_t pud_val(pud_t pud)
{
        return 0;

}

static inline void set_pgd(pgd_t *pgdp, pgd_t pgd)
{
 pgdval_t val = native_pgd_val(pgd);

 if (sizeof(pgdval_t) > sizeof(long))
 
                           ;
 else
 
           ;
}

static inline void pgd_clear(pgd_t *pgdp)
{
 set_pgd(pgdp, __pgd(0));
}

static inline void pud_clear(pud_t *pudp)
{
 set_pud(pudp, __pud(0));
}
static inline void set_pte_atomic(pte_t *ptep, pte_t pte)
{
 set_pte(ptep, pte);
}

static inline void pte_clear(struct mm_struct *mm, unsigned long addr,
        pte_t *ptep)
{
 set_pte_at(mm, addr, ptep, __pte(0));
}

static inline void pmd_clear(pmd_t *pmdp)
{
 set_pmd(pmdp, __pmd(0));
}



static inline void arch_start_context_switch(struct task_struct *prev)
{
 ;
}

static inline void arch_end_context_switch(struct task_struct *next)
{
 ;
}


static inline void arch_enter_lazy_mmu_mode(void)
{
 ;
}

static inline void arch_leave_lazy_mmu_mode(void)
{
 ;
}

static inline void arch_flush_lazy_mmu_mode(void)
{
 ;
}

static inline void __set_fixmap(unsigned idx,
    phys_addr_t phys, pgprot_t flags)
{
 pv_mmu_ops.set_fixmap(idx, phys, flags);
}



static inline __attribute__((always_inline)) void __ticket_lock_spinning(struct arch_spinlock *lock,
       __ticket_t ticket)
{
 ;
}

static inline __attribute__((always_inline)) void __ticket_unlock_kick(struct arch_spinlock *lock,
       __ticket_t ticket)
{
 ;
}
static inline unsigned long arch_local_save_flags(void)
{
 return 0;
}

static inline void arch_local_irq_restore(unsigned long f)
{
 ;
}

static inline void arch_local_irq_disable(void)
{
 ;
}

static inline void arch_local_irq_enable(void)
{
 ;
}

static inline unsigned long arch_local_irq_save(void)
{
 unsigned long f;

 f = arch_local_save_flags();
 arch_local_irq_disable();
 return f;
}
extern void default_banner(void);
struct msr *msrs_alloc(void);
void msrs_free(struct msr *msrs);


int rdmsr_on_cpu(unsigned int cpu, u32 msr_no, u32 *l, u32 *h);
int wrmsr_on_cpu(unsigned int cpu, u32 msr_no, u32 l, u32 h);
int rdmsrl_on_cpu(unsigned int cpu, u32 msr_no, u64 *q);
int wrmsrl_on_cpu(unsigned int cpu, u32 msr_no, u64 q);
void rdmsr_on_cpus( struct cpumask *mask, u32 msr_no, struct msr *msrs);
void wrmsr_on_cpus( struct cpumask *mask, u32 msr_no, struct msr *msrs);
int rdmsr_safe_on_cpu(unsigned int cpu, u32 msr_no, u32 *l, u32 *h);
int wrmsr_safe_on_cpu(unsigned int cpu, u32 msr_no, u32 l, u32 h);
int rdmsrl_safe_on_cpu(unsigned int cpu, u32 msr_no, u64 *q);
int wrmsrl_safe_on_cpu(unsigned int cpu, u32 msr_no, u64 q);
int rdmsr_safe_regs_on_cpu(unsigned int cpu, u32 regs[8]);
int wrmsr_safe_regs_on_cpu(unsigned int cpu, u32 regs[8]);

extern unsigned char * *ideal_nops;
extern void arch_init_ideal_nops(void);






static inline void native_clts(void)
{
 asm ("clts");
}
extern unsigned long __force_order;

static inline unsigned long native_read_cr0(void)
{
 unsigned long val;
 asm ("mov %%cr0,%0\n\t" : "=r" (val), "=m" (__force_order));
 return val;
}

static inline void native_write_cr0(unsigned long val)
{
 asm ("mov %0,%%cr0": : "r" (val), "m" (__force_order));
}

static inline unsigned long native_read_cr2(void)
{
 unsigned long val;
 asm ("mov %%cr2,%0\n\t" : "=r" (val), "=m" (__force_order));
 return val;
}

static inline void native_write_cr2(unsigned long val)
{
 asm ("mov %0,%%cr2": : "r" (val), "m" (__force_order));
}

static inline unsigned long native_read_cr3(void)
{
 unsigned long val;
 asm ("mov %%cr3,%0\n\t" : "=r" (val), "=m" (__force_order));
 return val;
}

static inline void native_write_cr3(unsigned long val)
{
 asm ("mov %0,%%cr3": : "r" (val), "m" (__force_order));
}

static inline unsigned long native_read_cr4(void)
{
 unsigned long val;
 asm ("mov %%cr4,%0\n\t" : "=r" (val), "=m" (__force_order));
 return val;
}

static inline unsigned long native_read_cr4_safe(void)
{
 unsigned long val;
 val = native_read_cr4();

 return val;
}

static inline void native_write_cr4(unsigned long val)
{
 asm ("mov %0,%%cr4": : "r" (val), "m" (__force_order));
}


static inline unsigned long native_read_cr8(void)
{
 unsigned long cr8;
 asm ("movq %%cr8,%0" : "=r" (cr8));
 return cr8;
}

static inline void native_write_cr8(unsigned long val)
{
 asm ("movq %0,%%cr8" :: "r" (val) : "memory");
}


static inline void native_wbinvd(void)
{
 asm ("wbinvd": : :"memory");
}

extern void native_load_gs_index(unsigned);
static inline void clflush( void *__p)
{
 asm ("clflush %0" : "+m" (*( char *)__p));
}




enum {
 UNAME26 = 0x0020000,
 ADDR_NO_RANDOMIZE = 0x0040000,
 FDPIC_FUNCPTRS = 0x0080000,


 MMAP_PAGE_ZERO = 0x0100000,
 ADDR_COMPAT_LAYOUT = 0x0200000,
 READ_IMPLIES_EXEC = 0x0400000,
 ADDR_LIMIT_32BIT = 0x0800000,
 SHORT_INODE = 0x1000000,
 WHOLE_SECONDS = 0x2000000,
 STICKY_TIMEOUTS = 0x4000000,
 ADDR_LIMIT_3GB = 0x8000000,
};
enum {
 PER_LINUX = 0x0000,
 PER_LINUX_32BIT = 0x0000 | ADDR_LIMIT_32BIT,
 PER_LINUX_FDPIC = 0x0000 | FDPIC_FUNCPTRS,
 PER_SVR4 = 0x0001 | STICKY_TIMEOUTS | MMAP_PAGE_ZERO,
 PER_SVR3 = 0x0002 | STICKY_TIMEOUTS | SHORT_INODE,
 PER_SCOSVR3 = 0x0003 | STICKY_TIMEOUTS |
      WHOLE_SECONDS | SHORT_INODE,
 PER_OSR5 = 0x0003 | STICKY_TIMEOUTS | WHOLE_SECONDS,
 PER_WYSEV386 = 0x0004 | STICKY_TIMEOUTS | SHORT_INODE,
 PER_ISCR4 = 0x0005 | STICKY_TIMEOUTS,
 PER_BSD = 0x0006,
 PER_SUNOS = 0x0006 | STICKY_TIMEOUTS,
 PER_XENIX = 0x0007 | STICKY_TIMEOUTS | SHORT_INODE,
 PER_LINUX32 = 0x0008,
 PER_LINUX32_3GB = 0x0008 | ADDR_LIMIT_3GB,
 PER_IRIX32 = 0x0009 | STICKY_TIMEOUTS,
 PER_IRIXN32 = 0x000a | STICKY_TIMEOUTS,
 PER_IRIX64 = 0x000b | STICKY_TIMEOUTS,
 PER_RISCOS = 0x000c,
 PER_SOLARIS = 0x000d | STICKY_TIMEOUTS,
 PER_UW7 = 0x000e | STICKY_TIMEOUTS | MMAP_PAGE_ZERO,
 PER_OSF4 = 0x000f,
 PER_HPUX = 0x0010,
 PER_MASK = 0x00ff,
};






struct exec_domain;
struct pt_regs;

extern int register_exec_domain(struct exec_domain *);
extern int unregister_exec_domain(struct exec_domain *);
extern int __set_personality(unsigned int);
typedef void (*handler_t)(int, struct pt_regs *);

struct exec_domain {
  template <typename, int = 0> struct __BYPASSexec_domain {};
  template <typename, int> friend struct __BYPASSexec_domain;
 char *name;
 handler_t handler;
 unsigned char pers_low;
 unsigned char pers_high;
 unsigned long *signal_map;
 unsigned long *signal_invmap;
 struct map_segment *err_map;
 struct map_segment *socktype_map;
 struct map_segment *sockopt_map;
 struct map_segment *af_map;
 struct module *module;
 struct exec_domain *next;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};






static inline u64 div_u64_rem(u64 dividend, u32 divisor, u32 *remainder)
{
 *remainder = dividend % divisor;
 return dividend / divisor;
}




static inline s64 div_s64_rem(s64 dividend, s32 divisor, s32 *remainder)
{
 *remainder = dividend % divisor;
 return dividend / divisor;
}




static inline u64 div64_u64_rem(u64 dividend, u64 divisor, u64 *remainder)
{
 *remainder = dividend % divisor;
 return dividend / divisor;
}




static inline u64 div64_u64(u64 dividend, u64 divisor)
{
 return dividend / divisor;
}




static inline s64 div64_s64(s64 dividend, s64 divisor)
{
 return dividend / divisor;
}
static inline u64 div_u64(u64 dividend, u32 divisor)
{
 u32 remainder;
 return div_u64_rem(dividend, divisor, &remainder);
}






static inline s64 div_s64(s64 dividend, s32 divisor)
{
 s32 remainder;
 return div_s64_rem(dividend, divisor, &remainder);
}


u32 iter_div_u64_rem(u64 dividend, u32 divisor, u64 *remainder);

static inline __attribute__((always_inline)) u32
__iter_div_u64_rem(u64 dividend, u32 divisor, u64 *remainder)
{
 u32 ret = 0;

 while (dividend >= divisor) {


  asm("" : "+rm"(dividend));

  dividend -= divisor;
  ret++;
 }

 *remainder = dividend;

 return ret;
}




static inline u64 mul_u64_u32_shr(u64 a, u32 mul, unsigned int shift)
{
 return (u64)(((unsigned __int128)a * mul) >> shift);
}






static inline void * ERR_PTR(long error)
{
 return (void *) error;
}

static inline long PTR_ERR( void *ptr)
{
 return (long) ptr;
}

static inline long IS_ERR( void *ptr)
{
 return __builtin_expect(!!(((unsigned long)ptr) >= (unsigned long)-4095), 0);
}

static inline long IS_ERR_OR_NULL( void *ptr)
{
 return !ptr || __builtin_expect(!!(((unsigned long)ptr) >= (unsigned long)-4095), 0);
}
static inline void * ERR_CAST( void *ptr)
{

 return (void *) ptr;
}

static inline int PTR_ERR_OR_ZERO( void *ptr)
{
 if (IS_ERR(ptr))
  return PTR_ERR(ptr);
 else
  return 0;
}
static inline unsigned long native_save_fl(void)
{
 unsigned long flags;






 asm ("# __raw_save_flags\n\t"
       "pushf ; pop %0"
       : "=rm" (flags)
       :
       : "memory");

 return flags;
}

static inline void native_restore_fl(unsigned long flags)
{
 asm ("push %0 ; popf"
       :
       :"g" (flags)
       :"memory", "cc");
}

static inline void native_irq_disable(void)
{
 asm ("cli": : :"memory");
}

static inline void native_irq_enable(void)
{
 asm ("sti": : :"memory");
}

static inline void native_safe_halt(void)
{
 asm ("sti; hlt": : :"memory");
}

static inline void native_halt(void)
{
 asm ("hlt": : :"memory");
}
static inline int arch_irqs_disabled_flags(unsigned long flags)
{
 return !(flags & ((1UL) << (9)));
}

static inline int arch_irqs_disabled(void)
{
 unsigned long flags = arch_local_save_flags();

 return arch_irqs_disabled_flags(flags);
}
static inline void *current_text_addr(void)
{
 void *pc;

 asm ("mov $1f, %0; 1:":"=r" (pc));

 return pc;
}
enum tlb_infos {
 ENTRIES,
 NR_INFO
};

extern u16 __attribute__((__section__(".data..read_mostly"))) tlb_lli_4k[NR_INFO];
extern u16 __attribute__((__section__(".data..read_mostly"))) tlb_lli_2m[NR_INFO];
extern u16 __attribute__((__section__(".data..read_mostly"))) tlb_lli_4m[NR_INFO];
extern u16 __attribute__((__section__(".data..read_mostly"))) tlb_lld_4k[NR_INFO];
extern u16 __attribute__((__section__(".data..read_mostly"))) tlb_lld_2m[NR_INFO];
extern u16 __attribute__((__section__(".data..read_mostly"))) tlb_lld_4m[NR_INFO];
extern s8 __attribute__((__section__(".data..read_mostly"))) tlb_flushall_shift;







struct cpuinfo_x86 {
  template <typename, int = 0> struct __BYPASScpuinfo_x86 {};
  template <typename, int> friend struct __BYPASScpuinfo_x86;
 __u8 x86;
 __u8 x86_vendor;
 __u8 x86_model;
 __u8 x86_mask;
 int x86_tlbsize;

 __u8 x86_virt_bits;
 __u8 x86_phys_bits;

 __u8 x86_coreid_bits;

 __u32 extended_cpuid_level;

 int cpuid_level;
 __u32 x86_capability[10 + 1];
 char x86_vendor_id[16];
 char x86_model_id[64];

 int x86_cache_size;
 int x86_cache_alignment;
 int x86_power;
 unsigned long loops_per_jiffy;

 u16 x86_max_cores;
 u16 apicid;
 u16 initial_apicid;
 u16 x86_clflush_size;

 u16 booted_cores;

 u16 phys_proc_id;

 u16 cpu_core_id;

 u8 compute_unit_id;

 u16 cpu_index;
 u32 microcode;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__((__aligned__((1 << (6)))));
extern struct cpuinfo_x86 boot_cpu_data;
extern struct cpuinfo_x86 new_cpu_data;

extern struct tss_struct doublefault_tss;
extern __u32 cpu_caps_cleared[10];
extern __u32 cpu_caps_set[10];


extern __attribute__((section(".data..percpu" "..shared_aligned"))) __typeof__(struct cpuinfo_x86) cpu_info __attribute__((__aligned__((1 << (6)))));






extern struct seq_operations cpuinfo_op;



extern void cpu_detect(struct cpuinfo_x86 *c);
extern void fpu_detect(struct cpuinfo_x86 *c);

extern void early_cpu_init(void);
extern void identify_boot_cpu(void);
extern void identify_secondary_cpu(struct cpuinfo_x86 *);
extern void print_cpu_info(struct cpuinfo_x86 *);
void print_cpu_msr(struct cpuinfo_x86 *);
extern void init_scattered_cpuid_features(struct cpuinfo_x86 *c);
extern unsigned int init_intel_cacheinfo(struct cpuinfo_x86 *c);
extern void init_amd_cacheinfo(struct cpuinfo_x86 *c);

extern void detect_extended_topology(struct cpuinfo_x86 *c);
extern void detect_ht(struct cpuinfo_x86 *c);




static inline int have_cpuid_p(void)
{
 return 1;
}

static inline void native_cpuid(unsigned int *eax, unsigned int *ebx,
    unsigned int *ecx, unsigned int *edx)
{

 asm ("cpuid"
     : "=a" (*eax),
       "=b" (*ebx),
       "=c" (*ecx),
       "=d" (*edx)
     : "0" (*eax), "2" (*ecx)
     : "memory");
}

static inline void load_cr3(pgd_t *pgdir)
{
 write_cr3(__phys_addr_nodebug((unsigned long)(pgdir)));
}
struct x86_hw_tss {
  template <typename, int = 0> struct __BYPASSx86_hw_tss {};
  template <typename, int> friend struct __BYPASSx86_hw_tss;
 u32 reserved1;
 u64 sp0;
 u64 sp1;
 u64 sp2;
 u64 reserved2;
 u64 ist[7];
 u32 reserved3;
 u32 reserved4;
 u16 reserved5;
 u16 io_bitmap_base;


  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__((packed)) __attribute__((__aligned__((1 << (6)))));
struct tss_struct {
  template <typename, int = 0> struct __BYPASStss_struct {};
  template <typename, int> friend struct __BYPASStss_struct;



 struct x86_hw_tss x86_tss;







 unsigned long io_bitmap[((65536/8)/sizeof(long)) + 1];




 unsigned long stack[64];


  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__((__aligned__((1 << (6)))));

extern __attribute__((section(".data..percpu" "..shared_aligned"))) __typeof__(struct tss_struct) init_tss __attribute__((__aligned__((1 << (6)))));




struct orig_ist {
  template <typename, int = 0> struct __BYPASSorig_ist {};
  template <typename, int> friend struct __BYPASSorig_ist;
 unsigned long ist[7];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};



struct i387_fsave_struct {
  template <typename, int = 0> struct __BYPASSi387_fsave_struct {};
  template <typename, int> friend struct __BYPASSi387_fsave_struct;
 u32 cwd;
 u32 swd;
 u32 twd;
 u32 fip;
 u32 fcs;
 u32 foo;
 u32 fos;


 u32 st_space[20];


 u32 status;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct i387_fxsave_struct {
  template <typename, int = 0> struct __BYPASSi387_fxsave_struct {};
  template <typename, int> friend struct __BYPASSi387_fxsave_struct;
 u16 cwd;
 u16 swd;
 u16 twd;
 u16 fop;
 union {
  struct {
   u64 rip;
   u64 rdp;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
};
  struct {
   u32 fip;
   u32 fcs;
   u32 foo;
   u32 fos;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
};
 };
 u32 mxcsr;
 u32 mxcsr_mask;


 u32 st_space[32];


 u32 xmm_space[64];

 u32 padding[12];

 union {
  u32 padding1[12];
  u32 sw_reserved[12];
 };


  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__((aligned(16)));

struct i387_soft_struct {
  template <typename, int = 0> struct __BYPASSi387_soft_struct {};
  template <typename, int> friend struct __BYPASSi387_soft_struct;
 u32 cwd;
 u32 swd;
 u32 twd;
 u32 fip;
 u32 fcs;
 u32 foo;
 u32 fos;

 u32 st_space[20];
 u8 ftop;
 u8 changed;
 u8 lookahead;
 u8 no_update;
 u8 rm;
 u8 alimit;
 struct math_emu_info *info;
 u32 entry_eip;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct ymmh_struct {
  template <typename, int = 0> struct __BYPASSymmh_struct {};
  template <typename, int> friend struct __BYPASSymmh_struct;

 u32 ymmh_space[64];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct xsave_hdr_struct {
  template <typename, int = 0> struct __BYPASSxsave_hdr_struct {};
  template <typename, int> friend struct __BYPASSxsave_hdr_struct;
 u64 xstate_bv;
 u64 reserved1[2];
 u64 reserved2[5];

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__((packed));

struct xsave_struct {
  template <typename, int = 0> struct __BYPASSxsave_struct {};
  template <typename, int> friend struct __BYPASSxsave_struct;
 struct i387_fxsave_struct i387;
 struct xsave_hdr_struct xsave_hdr;
 struct ymmh_struct ymmh;


  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed, aligned (64)));

union thread_xstate {
 struct i387_fsave_struct fsave;
 struct i387_fxsave_struct fxsave;
 struct i387_soft_struct soft;
 struct xsave_struct xsave;
};

struct fpu {
  template <typename, int = 0> struct __BYPASSfpu {};
  template <typename, int> friend struct __BYPASSfpu;
 unsigned int last_cpu;
 unsigned int has_fpu;
 union thread_xstate *state;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};


extern __attribute__((section(".data..percpu" ""))) __typeof__(struct orig_ist) orig_ist;

union irq_stack_union {
 char irq_stack[(((1UL) << 12) << 2)];





 struct {
  char gs_base[40];
  unsigned long stack_canary;
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
};
};

extern __attribute__((section(".data..percpu" "..first"))) __typeof__(union irq_stack_union) irq_stack_union __attribute__((externally_visible));
extern typeof(irq_stack_union) init_per_cpu__irq_stack_union;

extern __attribute__((section(".data..percpu" ""))) __typeof__(char *) irq_stack_ptr;
extern __attribute__((section(".data..percpu" ""))) __typeof__(unsigned int) irq_count;
extern void ignore_sysret(void);
extern unsigned int xstate_size;
extern void free_thread_xstate(struct task_struct *);
extern struct kmem_cache *task_xstate_cachep;

struct perf_event;

struct thread_struct {
  template <typename, int = 0> struct __BYPASSthread_struct {};
  template <typename, int> friend struct __BYPASSthread_struct;

 struct desc_struct tls_array[3];
 unsigned long sp0;
 unsigned long sp;



 unsigned long usersp;
 unsigned short es;
 unsigned short ds;
 unsigned short fsindex;
 unsigned short gsindex;





 unsigned long fs;

 unsigned long gs;

 struct perf_event *ptrace_bps[4];

 unsigned long debugreg6;

 unsigned long ptrace_dr7;

 unsigned long cr2;
 unsigned long trap_nr;
 unsigned long error_code;

 struct fpu fpu;
 unsigned long *io_bitmap_ptr;
 unsigned long iopl;

 unsigned io_bitmap_max;
 unsigned char fpu_counter;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};




static inline void native_set_iopl_mask(unsigned mask)
{
}


template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN13thread_struct3sp0E_143_0 {
  typedef TJP__ZN13thread_struct3sp0E_143_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int __get__ZN13thread_struct3sp0E_143(unsigned long int *source) {
  unsigned long int __result_buffer;
  typedef TJP__ZN13thread_struct3sp0E_143_0< unsigned long int , ::thread_struct , unsigned long int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int &)__result_buffer;
}
static inline void
native_load_sp0(struct tss_struct *tss, struct thread_struct *thread)
{
 tss->x86_tss.sp0 = __get__ZN13thread_struct3sp0E_143(&thread->sp0);







}

static inline void native_swapgs(void)
{

 asm ("swapgs" ::: "memory");

}
extern unsigned long mmu_cr4_features;
extern u32 *trampoline_cr4_features;

static inline void set_in_cr4(unsigned long mask)
{
 unsigned long cr4;

 mmu_cr4_features |= mask;
 if (trampoline_cr4_features)
  *trampoline_cr4_features = mmu_cr4_features;
 cr4 = read_cr4();
 cr4 |= mask;
 write_cr4(cr4);
}

static inline void clear_in_cr4(unsigned long mask)
{
 unsigned long cr4;

 mmu_cr4_features &= ~mask;
 if (trampoline_cr4_features)
  *trampoline_cr4_features = mmu_cr4_features;
 cr4 = read_cr4();
 cr4 &= ~mask;
 write_cr4(cr4);
}

typedef struct {
 unsigned long seg;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} mm_segment_t;



extern void release_thread(struct task_struct *);

unsigned long get_wchan(struct task_struct *p);






static inline void cpuid(unsigned int op,
    unsigned int *eax, unsigned int *ebx,
    unsigned int *ecx, unsigned int *edx)
{
 *eax = op;
 *ecx = 0;
 __cpuid(eax, ebx, ecx, edx);
}


static inline void cpuid_count(unsigned int op, int count,
          unsigned int *eax, unsigned int *ebx,
          unsigned int *ecx, unsigned int *edx)
{
 *eax = op;
 *ecx = count;
 __cpuid(eax, ebx, ecx, edx);
}




static inline unsigned int cpuid_eax(unsigned int op)
{
 unsigned int eax, ebx, ecx, edx;

 cpuid(op, &eax, &ebx, &ecx, &edx);

 return eax;
}

static inline unsigned int cpuid_ebx(unsigned int op)
{
 unsigned int eax, ebx, ecx, edx;

 cpuid(op, &eax, &ebx, &ecx, &edx);

 return ebx;
}

static inline unsigned int cpuid_ecx(unsigned int op)
{
 unsigned int eax, ebx, ecx, edx;

 cpuid(op, &eax, &ebx, &ecx, &edx);

 return ecx;
}

static inline unsigned int cpuid_edx(unsigned int op)
{
 unsigned int eax, ebx, ecx, edx;

 cpuid(op, &eax, &ebx, &ecx, &edx);

 return edx;
}


static inline void rep_nop(void)
{
 asm ("rep; nop" ::: "memory");
}

static inline void cpu_relax(void)
{
 rep_nop();
}


static inline void sync_core(void)
{
 int tmp;
 asm ("cpuid"
       : "=a" (tmp)
       : "0" (1)
       : "ebx", "ecx", "edx", "memory");

}

static inline void __monitor( void *eax, unsigned long ecx,
        unsigned long edx)
{

 asm (".byte 0x0f, 0x01, 0xc8;"
       :: "a" (eax), "c" (ecx), "d"(edx));
}

static inline void __mwait(unsigned long eax, unsigned long ecx)
{

 asm (".byte 0x0f, 0x01, 0xc9;"
       :: "a" (eax), "c" (ecx));
}

static inline void __sti_mwait(unsigned long eax, unsigned long ecx)
{
 do { } while (0);

 asm ("sti; .byte 0x0f, 0x01, 0xc9;"
       :: "a" (eax), "c" (ecx));
}

extern void select_idle_routine( struct cpuinfo_x86 *c);
extern void init_amd_e400_c1e_mask(void);

extern unsigned long boot_option_idle_override;
extern bool amd_e400_c1e_detected;

enum idle_boot_override {IDLE_NO_OVERRIDE=0, IDLE_HALT, IDLE_NOMWAIT,
    IDLE_POLL};

extern void enable_sep_cpu(void);
extern int sysenter_setup(void);

extern void early_trap_init(void);
void early_trap_pf_init(void);


extern struct desc_ptr early_gdt_descr;

extern void cpu_set_gdt(int);
extern void switch_to_new_gdt(int);
extern void load_percpu_segment(int);
extern void cpu_init(void);

static inline unsigned long get_debugctlmsr(void)
{
 unsigned long debugctlmsr = 0;





 do { int _err; debugctlmsr = paravirt_read_msr(0x000001d9, &_err); } while (0);

 return debugctlmsr;
}

static inline void update_debugctlmsr(unsigned long debugctlmsr)
{




 do { paravirt_write_msr(0x000001d9, (u32)((u64)(debugctlmsr)), ((u64)(debugctlmsr))>>32); } while (0);
}

extern void set_task_blockstep(struct task_struct *task, bool on);





extern unsigned int machine_id;
extern unsigned int machine_submodel_id;
extern unsigned int BIOS_revision;


extern int bootloader_type;
extern int bootloader_version;

extern char ignore_fpu_irq;
static inline void prefetch( void *x)
{
 asm ("661:\n\t" "prefetcht0 (%1)" "\n662:\n" ".pushsection .altinstructions,\"a\"\n" " .long 661b - .\n" " .long " "663""1""f - .\n" " .word " "(0*32+25)" "\n" " .byte " "662b-661b" "\n" " .byte " "664""1""f-""663""1""f" "\n" ".popsection\n" ".pushsection .discard,\"aw\",@progbits\n" " .byte 0xff + (" "664""1""f-""663""1""f" ") - (" "662b-661b" ")\n" ".popsection\n" ".pushsection .altinstr_replacement, \"ax\"\n" "663""1"":\n\t" "prefetchnta (%1)" "\n" "664""1" ":\n\t" ".popsection" : : "i" (0), "r" (x))


             ;
}






static inline void prefetchw( void *x)
{
 asm ("661:\n\t" "prefetcht0 (%1)" "\n662:\n" ".pushsection .altinstructions,\"a\"\n" " .long 661b - .\n" " .long " "663""1""f - .\n" " .word " "(1*32+31)" "\n" " .byte " "662b-661b" "\n" " .byte " "664""1""f-""663""1""f" "\n" ".popsection\n" ".pushsection .discard,\"aw\",@progbits\n" " .byte 0xff + (" "664""1""f-""663""1""f" ") - (" "662b-661b" ")\n" ".popsection\n" ".pushsection .altinstr_replacement, \"ax\"\n" "663""1"":\n\t" "prefetchw (%1)" "\n" "664""1" ":\n\t" ".popsection" : : "i" (0), "r" (x))


             ;
}

static inline void spin_lock_prefetch( void *x)
{
 prefetchw(x);
}
extern unsigned long KSTK_ESP(struct task_struct *task);




extern __attribute__((section(".data..percpu" ""))) __typeof__(unsigned long) old_rsp;



extern void start_thread(struct pt_regs *regs, unsigned long new_ip,
            unsigned long new_sp);
extern int get_tsc_mode(unsigned long adr);
extern int set_tsc_mode(unsigned int val);

extern u16 amd_get_nb_id(int cpu);

static inline uint32_t hypervisor_cpuid_base( char *sig, uint32_t leaves)
{
 uint32_t base, eax, signature[3];

 for (base = 0x40000000; base < 0x40010000; base += 0x100) {
  cpuid(base, &eax, &signature[0], &signature[1], &signature[2]);

  if (!memcmp(sig, signature, 12) &&
      (leaves == 0 || ((eax - base) >= leaves)))
   return base;
 }

 return 0;
}

extern unsigned long arch_align_stack(unsigned long sp);
extern void free_init_pages(char *what, unsigned long begin, unsigned long end);

void default_idle(void);

bool xen_set_default_idle(void);




void stop_this_cpu(void *dummy);
void df_debug(struct pt_regs *regs, long error_code);










extern void __xchg_wrong_size(void)
 __attribute__((error("Bad argument size for xchg")));
extern void __cmpxchg_wrong_size(void)
 __attribute__((error("Bad argument size for cmpxchg")));
extern void __xadd_wrong_size(void)
 __attribute__((error("Bad argument size for xadd")));
extern void __add_wrong_size(void)
 __attribute__((error("Bad argument size for add")));



static inline void set_64bit( u64 *ptr, u64 val)
{
 *ptr = val;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7_atomic7counterE_148_0 {
  typedef TJP__ZN7_atomic7counterE_148_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline int __get__ZN7_atomic7counterE_148(int *source) {
  int __result_buffer;
  typedef TJP__ZN7_atomic7counterE_148_0< int , ::_atomic , int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (int &)__result_buffer;
}
static inline int atomic_read( atomic_t *v)
{



        return __get__ZN7_atomic7counterE_148(&v->counter);

}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7_atomic7counterE_149_0 {
  typedef TJP__ZN7_atomic7counterE_149_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline int __get__ZN7_atomic7counterE_149(int *source) {
  int __result_buffer;
  typedef TJP__ZN7_atomic7counterE_149_0< int , ::_atomic , int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (int &)__result_buffer;
}
static inline int atomic_sub_return(int i, atomic_t *v)
{
 return (__get__ZN7_atomic7counterE_149(&(v)->counter) + (-i));
}




static inline int atomic_cmpxchg(atomic_t *v, int old, int _new)
{



        int counter = *(typeof(&v->counter))g_map(&v->counter, sizeof(*(&v->counter)));
 return ({ __typeof__(*((&counter))) __ret; __typeof__(*((&counter))) __old = ((old)); __typeof__(*((&counter))) __new = ((_new)); switch ((sizeof(*(&counter)))) { case 1: { u8 *__ptr = ( u8 *)((&counter)); asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "cmpxchgb %2,%1" : "=a" (__ret), "+m" (*__ptr) : "q" (__new), "0" (__old) : "memory"); break; } case 2: { u16 *__ptr = ( u16 *)((&counter)); asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "cmpxchgw %2,%1" : "=a" (__ret), "+m" (*__ptr) : "r" (__new), "0" (__old) : "memory"); break; } case 4: { u32 *__ptr = ( u32 *)((&counter)); asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "cmpxchgl %2,%1" : "=a" (__ret), "+m" (*__ptr) : "r" (__new), "0" (__old) : "memory"); break; } case 8: { u64 *__ptr = ( u64 *)((&counter)); asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "cmpxchgq %2,%1" : "=a" (__ret), "+m" (*__ptr) : "r" (__new), "0" (__old) : "memory"); break; } default: __cmpxchg_wrong_size(); } __ret; });

}

static inline int atomic_xchg(atomic_t *v, int _new)
{
 return ({ __typeof__ (*((&v->counter))) __ret = ((_new)); switch (sizeof(*((&v->counter)))) { case 1: asm ("" "xchg" "b %b0, %1\n" : "+q" (__ret), "+m" (*((&v->counter))) : : "memory", "cc"); break; case 2: asm ("" "xchg" "w %w0, %1\n" : "+r" (__ret), "+m" (*((&v->counter))) : : "memory", "cc"); break; case 4: asm ("" "xchg" "l %0, %1\n" : "+r" (__ret), "+m" (*((&v->counter))) : : "memory", "cc"); break; case 8: asm ("" "xchg" "q %q0, %1\n" : "+r" (__ret), "+m" (*((&v->counter))) : : "memory", "cc"); break; default: __xchg_wrong_size(); } __ret; });
}
static inline int __atomic_add_unless(atomic_t *v, int a, int u)
{
 int c, old;
 c = atomic_read(v);
 for (;;) {
  if (__builtin_expect(!!(c == (u)), 0))
   break;
  old = atomic_cmpxchg((v), c, c + (a));
  if (__builtin_expect(!!(old == c), 1))
   break;
  c = old;
 }
 return c;
}
static inline short int atomic_inc_short(short int *v)
{
 asm(".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "addw $1, %0" : "+m" (*v));
 return *v;
}
static inline void atomic_or_long(unsigned long *v1, unsigned long v2)
{
 asm(".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "orq %1, %0" : "+m" (*v1) : "r" (v2));
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_atomic647counterE_150_0 {
  typedef TJP__ZN9_atomic647counterE_150_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline long int __get__ZN9_atomic647counterE_150(long int *source) {
  long int __result_buffer;
  typedef TJP__ZN9_atomic647counterE_150_0< long int , ::_atomic64 , long int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (long int &)__result_buffer;
}
static inline long atomic64_read( atomic64_t *v)
{



 return __get__ZN9_atomic647counterE_150(&v->counter);

}
static inline void atomic64_set(atomic64_t *v, long i)
{
 v->counter = i;
}
static inline void atomic64_add(long i, atomic64_t *v)
{
 asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "addq %1,%0"
       : "=m" (v->counter)
       : "er" (i), "m" (v->counter));
}
static inline void atomic64_sub(long i, atomic64_t *v)
{
 asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "subq %1,%0"
       : "=m" (v->counter)
       : "er" (i), "m" (v->counter));
}
static inline int atomic64_sub_and_test(long i, atomic64_t *v)
{
 do { char c; asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "subq" " %2, " "%0" "; set" "e" " %1" : "+m" (v->counter), "=qm" (c) : "er" (i) : "memory"); return c != 0; } while (0);
}







static inline void atomic64_inc(atomic64_t *v)
{
 asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "incq %0"
       : "=m" (v->counter)
       : "m" (v->counter));
}







static inline void atomic64_dec(atomic64_t *v)
{
 asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "decq %0"
       : "=m" (v->counter)
       : "m" (v->counter));
}
static inline int atomic64_dec_and_test(atomic64_t *v)
{
 do { char c; asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "decq" " " "%0" "; set" "e" " %1" : "+m" (v->counter), "=qm" (c) : : "memory"); return c != 0; } while (0);
}
static inline int atomic64_inc_and_test(atomic64_t *v)
{
 do { char c; asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "incq" " " "%0" "; set" "e" " %1" : "+m" (v->counter), "=qm" (c) : : "memory"); return c != 0; } while (0);
}
static inline int atomic64_add_negative(long i, atomic64_t *v)
{
 do { char c; asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "addq" " %2, " "%0" "; set" "s" " %1" : "+m" (v->counter), "=qm" (c) : "er" (i) : "memory"); return c != 0; } while (0);
}
static inline long atomic64_add_return(long i, atomic64_t *v)
{
 return i + ({ __typeof__ (*(((&v->counter)))) __ret = (((i))); switch (sizeof(*(((&v->counter))))) { case 1: asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "xadd" "b %b0, %1\n" : "+q" (__ret), "+m" (*(((&v->counter)))) : : "memory", "cc"); break; case 2: asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "xadd" "w %w0, %1\n" : "+r" (__ret), "+m" (*(((&v->counter)))) : : "memory", "cc"); break; case 4: asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "xadd" "l %0, %1\n" : "+r" (__ret), "+m" (*(((&v->counter)))) : : "memory", "cc"); break; case 8: asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "xadd" "q %q0, %1\n" : "+r" (__ret), "+m" (*(((&v->counter)))) : : "memory", "cc"); break; default: __xadd_wrong_size(); } __ret; });
}

static inline long atomic64_sub_return(long i, atomic64_t *v)
{
 return atomic64_add_return(-i, v);
}




static inline long atomic64_cmpxchg(atomic64_t *v, long old, long _new)
{
 return ({ __typeof__(*((&v->counter))) __ret; __typeof__(*((&v->counter))) __old = ((old)); __typeof__(*((&v->counter))) __new = ((_new)); switch ((sizeof(*(&v->counter)))) { case 1: { u8 *__ptr = ( u8 *)((&v->counter)); asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "cmpxchgb %2,%1" : "=a" (__ret), "+m" (*__ptr) : "q" (__new), "0" (__old) : "memory"); break; } case 2: { u16 *__ptr = ( u16 *)((&v->counter)); asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "cmpxchgw %2,%1" : "=a" (__ret), "+m" (*__ptr) : "r" (__new), "0" (__old) : "memory"); break; } case 4: { u32 *__ptr = ( u32 *)((&v->counter)); asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "cmpxchgl %2,%1" : "=a" (__ret), "+m" (*__ptr) : "r" (__new), "0" (__old) : "memory"); break; } case 8: { u64 *__ptr = ( u64 *)((&v->counter)); asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "cmpxchgq %2,%1" : "=a" (__ret), "+m" (*__ptr) : "r" (__new), "0" (__old) : "memory"); break; } default: __cmpxchg_wrong_size(); } __ret; });
}

static inline long atomic64_xchg(atomic64_t *v, long _new)
{
 return ({ __typeof__ (*((&v->counter))) __ret = ((_new)); switch (sizeof(*((&v->counter)))) { case 1: asm ("" "xchg" "b %b0, %1\n" : "+q" (__ret), "+m" (*((&v->counter))) : : "memory", "cc"); break; case 2: asm ("" "xchg" "w %w0, %1\n" : "+r" (__ret), "+m" (*((&v->counter))) : : "memory", "cc"); break; case 4: asm ("" "xchg" "l %0, %1\n" : "+r" (__ret), "+m" (*((&v->counter))) : : "memory", "cc"); break; case 8: asm ("" "xchg" "q %q0, %1\n" : "+r" (__ret), "+m" (*((&v->counter))) : : "memory", "cc"); break; default: __xchg_wrong_size(); } __ret; });
}
static inline int atomic64_add_unless(atomic64_t *v, long a, long u)
{
 long c, old;
 c = atomic64_read(v);
 for (;;) {
  if (__builtin_expect(!!(c == (u)), 0))
   break;
  old = atomic64_cmpxchg((v), c, c + (a));
  if (__builtin_expect(!!(old == c), 1))
   break;
  c = old;
 }
 return c != (u);
}
static inline long atomic64_dec_if_positive(atomic64_t *v)
{
 long c, old, dec;
 c = atomic64_read(v);
 for (;;) {
  dec = c - 1;
  if (__builtin_expect(!!(dec < 0), 0))
   break;
  old = atomic64_cmpxchg((v), c, dec);
  if (__builtin_expect(!!(old == c), 1))
   break;
  c = old;
 }
 return dec;
}
static inline int atomic_add_unless(atomic_t *v, int a, int u)
{
 return __atomic_add_unless(v, a, u) != u;
}
static inline int atomic_inc_not_zero_hint(atomic_t *v, int hint)
{
 int val, c = hint;


 if (!hint)
  return atomic_add_unless((v), 1, 0);

 do {
  val = atomic_cmpxchg(v, c, c + 1);
  if (val == c)
   return 1;
  c = val;
 } while (c);

 return 0;
}



static inline int atomic_inc_unless_negative(atomic_t *p)
{
 int v, v1;
 for (v = 0; v >= 0; v = v1) {
  v1 = atomic_cmpxchg(p, v, v + 1);
  if (__builtin_expect(!!(v1 == v), 1))
   return 1;
 }
 return 0;
}



static inline int atomic_dec_unless_positive(atomic_t *p)
{
 int v, v1;
 for (v = 0; v <= 0; v = v1) {
  v1 = atomic_cmpxchg(p, v, v - 1);
  if (__builtin_expect(!!(v1 == v), 1))
   return 1;
 }
 return 0;
}
static inline int atomic_dec_if_positive(atomic_t *v)
{
 int c, old, dec;
 c = atomic_read(v);
 for (;;) {
  dec = c - 1;
  if (__builtin_expect(!!(dec < 0), 0))
   break;
  old = atomic_cmpxchg((v), c, dec);
  if (__builtin_expect(!!(old == c), 1))
   break;
  c = old;
 }
 return dec;
}



static inline void atomic_or(int i, atomic_t *v)
{
 int old;
 int _new;

 do {
  old = atomic_read(v);
  _new = old | i;
 } while (atomic_cmpxchg(v, old, _new) != old);
}


typedef atomic64_t atomic_long_t;



static inline long atomic_long_read(atomic_long_t *l)
{
 atomic64_t *v = (atomic64_t *)l;

 return (long)atomic64_read(v);
}

static inline void atomic_long_set(atomic_long_t *l, long i)
{
 atomic64_t *v = (atomic64_t *)l;

 atomic64_set(v, i);
}

static inline void atomic_long_inc(atomic_long_t *l)
{
 atomic64_t *v = (atomic64_t *)l;

 atomic64_inc(v);
}

static inline void atomic_long_dec(atomic_long_t *l)
{
 atomic64_t *v = (atomic64_t *)l;

 atomic64_dec(v);
}

static inline void atomic_long_add(long i, atomic_long_t *l)
{
 atomic64_t *v = (atomic64_t *)l;

 atomic64_add(i, v);
}

static inline void atomic_long_sub(long i, atomic_long_t *l)
{
 atomic64_t *v = (atomic64_t *)l;

 atomic64_sub(i, v);
}

static inline int atomic_long_sub_and_test(long i, atomic_long_t *l)
{
 atomic64_t *v = (atomic64_t *)l;

 return atomic64_sub_and_test(i, v);
}

static inline int atomic_long_dec_and_test(atomic_long_t *l)
{
 atomic64_t *v = (atomic64_t *)l;

 return atomic64_dec_and_test(v);
}

static inline int atomic_long_inc_and_test(atomic_long_t *l)
{
 atomic64_t *v = (atomic64_t *)l;

 return atomic64_inc_and_test(v);
}

static inline int atomic_long_add_negative(long i, atomic_long_t *l)
{
 atomic64_t *v = (atomic64_t *)l;

 return atomic64_add_negative(i, v);
}

static inline long atomic_long_add_return(long i, atomic_long_t *l)
{
 atomic64_t *v = (atomic64_t *)l;

 return (long)atomic64_add_return(i, v);
}

static inline long atomic_long_sub_return(long i, atomic_long_t *l)
{
 atomic64_t *v = (atomic64_t *)l;

 return (long)atomic64_sub_return(i, v);
}

static inline long atomic_long_inc_return(atomic_long_t *l)
{
 atomic64_t *v = (atomic64_t *)l;

 return (long)(atomic64_add_return(1, (v)));
}

static inline long atomic_long_dec_return(atomic_long_t *l)
{
 atomic64_t *v = (atomic64_t *)l;

 return (long)(atomic64_sub_return(1, (v)));
}

static inline long atomic_long_add_unless(atomic_long_t *l, long a, long u)
{
 atomic64_t *v = (atomic64_t *)l;

 return (long)atomic64_add_unless(v, a, u);
}

struct thread_info {
  template <typename, int = 0> struct __BYPASSthread_info {};
  template <typename, int> friend struct __BYPASSthread_info;
 struct task_struct *task;
 struct exec_domain *exec_domain;
 __u32 flags;
 __u32 status;
 __u32 cpu;
 int saved_preempt_count;
 mm_segment_t addr_limit;
 struct restart_block restart_block;
 void *sysenter_return;






 unsigned int sig_on_uaccess_error:1;
 unsigned int uaccess_err:1;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
extern __attribute__((section(".data..percpu" ""))) __typeof__(unsigned long) kernel_stack;

static inline struct thread_info *current_thread_info(void)
{






}
static inline void set_restore_sigmask(void)
{
 struct thread_info *ti = current_thread_info();
 ti->status |= 0x0008;
 (!(__builtin_constant_p((2)) ? constant_test_bit((2), ((unsigned long *)&ti->flags)) : variable_test_bit((2), ((unsigned long *)&ti->flags))));
}
static inline void clear_restore_sigmask(void)
{
 current_thread_info()->status &= ~0x0008;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN11thread_info6statusE_151_0 {
  typedef TJP__ZN11thread_info6statusE_151_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned int __get__ZN11thread_info6statusE_151(unsigned int *source) {
  ::__u32 __result_buffer;
  typedef TJP__ZN11thread_info6statusE_151_0< ::__u32 , ::thread_info , ::__u32  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::__u32 &)__result_buffer;
}
static inline bool test_restore_sigmask(void)
{
 return __get__ZN11thread_info6statusE_151(&current_thread_info()->status) & 0x0008;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN11thread_info6statusE_152_0 {
  typedef TJP__ZN11thread_info6statusE_152_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned int __get__ZN11thread_info6statusE_152(unsigned int *source) {
  ::__u32 __result_buffer;
  typedef TJP__ZN11thread_info6statusE_152_0< ::__u32 , ::thread_info , ::__u32  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::__u32 &)__result_buffer;
}
static inline bool test_and_clear_restore_sigmask(void)
{
 struct thread_info *ti = current_thread_info();
 if (!(__get__ZN11thread_info6statusE_152(&ti->status) & 0x0008))
  return _false;
 ti->status &= ~0x0008;
 return _true;
}


template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN11thread_info6statusE_155_0 {
  typedef TJP__ZN11thread_info6statusE_155_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned int __get__ZN11thread_info6statusE_155(unsigned int *source) {
  ::__u32 __result_buffer;
  typedef TJP__ZN11thread_info6statusE_155_0< ::__u32 , ::thread_info , ::__u32  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::__u32 &)__result_buffer;
}
static inline bool is_ia32_task(void)
{




 if (__get__ZN11thread_info6statusE_155(&current_thread_info()->status) & 0x0002)
  return _true;

 return _false;
}



extern void arch_task_cache_init(void);
extern int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src);
extern void arch_release_task_struct(struct task_struct *tsk);
static inline void set_ti_thread_flag(struct thread_info *ti, int flag)
{
 set_bit(flag, (unsigned long *)&ti->flags);
}

static inline void clear_ti_thread_flag(struct thread_info *ti, int flag)
{
 clear_bit(flag, (unsigned long *)&ti->flags);
}

static inline int test_and_set_ti_thread_flag(struct thread_info *ti, int flag)
{
 return test_and_set_bit(flag, (unsigned long *)&ti->flags);
}

static inline int test_and_clear_ti_thread_flag(struct thread_info *ti, int flag)
{
 return test_and_clear_bit(flag, (unsigned long *)&ti->flags);
}

static inline int test_ti_thread_flag(struct thread_info *ti, int flag)
{
 return (__builtin_constant_p((flag)) ? constant_test_bit((flag), ((unsigned long *)&ti->flags)) : variable_test_bit((flag), ((unsigned long *)&ti->flags)));
}
static inline void set_need_resched(void)
{
}

extern __attribute__((section(".data..percpu" ""))) __typeof__(int) __preempt_count;
static inline __attribute__((always_inline)) int preempt_count(void)
{
 return ({ typeof((__preempt_count)) pfo_ret__; switch (sizeof((__preempt_count))) { case 1: asm("mov" "b ""%%""gs"":" "%P" "1"",%0" : "=q" (pfo_ret__) : "m"(__preempt_count)); break; case 2: asm("mov" "w ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"(__preempt_count)); break; case 4: asm("mov" "l ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"(__preempt_count)); break; case 8: asm("mov" "q ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"(__preempt_count)); break; default: __bad_percpu_size(); } pfo_ret__; }) & ~0x80000000;
}

static inline __attribute__((always_inline)) void preempt_count_set(int pc)
{
 do { typedef typeof((__preempt_count)) pto_T__; if (0) { pto_T__ pto_tmp__; pto_tmp__ = (pc); (void)pto_tmp__; } switch (sizeof((__preempt_count))) { case 1: asm("mov" "b %1,""%%""gs"":" "%P" "0" : "+m" ((__preempt_count)) : "qi" ((pto_T__)(pc))); break; case 2: asm("mov" "w %1,""%%""gs"":" "%P" "0" : "+m" ((__preempt_count)) : "ri" ((pto_T__)(pc))); break; case 4: asm("mov" "l %1,""%%""gs"":" "%P" "0" : "+m" ((__preempt_count)) : "ri" ((pto_T__)(pc))); break; case 8: asm("mov" "q %1,""%%""gs"":" "%P" "0" : "+m" ((__preempt_count)) : "re" ((pto_T__)(pc))); break; default: __bad_percpu_size(); } } while (0);
}
static inline __attribute__((always_inline)) void set_preempt_need_resched(void)
{
 do { typedef typeof((__preempt_count)) pto_T__; if (0) { pto_T__ pto_tmp__; pto_tmp__ = (~0x80000000); (void)pto_tmp__; } switch (sizeof((__preempt_count))) { case 1: asm("and" "b %1,""%%""gs"":" "%P" "0" : "+m" ((__preempt_count)) : "qi" ((pto_T__)(~0x80000000))); break; case 2: asm("and" "w %1,""%%""gs"":" "%P" "0" : "+m" ((__preempt_count)) : "ri" ((pto_T__)(~0x80000000))); break; case 4: asm("and" "l %1,""%%""gs"":" "%P" "0" : "+m" ((__preempt_count)) : "ri" ((pto_T__)(~0x80000000))); break; case 8: asm("and" "q %1,""%%""gs"":" "%P" "0" : "+m" ((__preempt_count)) : "re" ((pto_T__)(~0x80000000))); break; default: __bad_percpu_size(); } } while (0);
}

static inline __attribute__((always_inline)) void clear_preempt_need_resched(void)
{
 do { typedef typeof((__preempt_count)) pto_T__; if (0) { pto_T__ pto_tmp__; pto_tmp__ = (0x80000000); (void)pto_tmp__; } switch (sizeof((__preempt_count))) { case 1: asm("or" "b %1,""%%""gs"":" "%P" "0" : "+m" ((__preempt_count)) : "qi" ((pto_T__)(0x80000000))); break; case 2: asm("or" "w %1,""%%""gs"":" "%P" "0" : "+m" ((__preempt_count)) : "ri" ((pto_T__)(0x80000000))); break; case 4: asm("or" "l %1,""%%""gs"":" "%P" "0" : "+m" ((__preempt_count)) : "ri" ((pto_T__)(0x80000000))); break; case 8: asm("or" "q %1,""%%""gs"":" "%P" "0" : "+m" ((__preempt_count)) : "re" ((pto_T__)(0x80000000))); break; default: __bad_percpu_size(); } } while (0);
}

static inline __attribute__((always_inline)) bool test_preempt_need_resched(void)
{
 return !(({ typeof((__preempt_count)) pfo_ret__; switch (sizeof((__preempt_count))) { case 1: asm("mov" "b ""%%""gs"":" "%P" "1"",%0" : "=q" (pfo_ret__) : "m"(__preempt_count)); break; case 2: asm("mov" "w ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"(__preempt_count)); break; case 4: asm("mov" "l ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"(__preempt_count)); break; case 8: asm("mov" "q ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"(__preempt_count)); break; default: __bad_percpu_size(); } pfo_ret__; }) & 0x80000000);
}





static inline __attribute__((always_inline)) void __preempt_count_add(int val)
{
 do { typedef typeof((__preempt_count)) pao_T__; int pao_ID__ = (__builtin_constant_p(val) && ((val) == 1 || (val) == -1)) ? (int)(val) : 0; if (0) { pao_T__ pao_tmp__; pao_tmp__ = (val); (void)pao_tmp__; } switch (sizeof((__preempt_count))) { case 1: if (pao_ID__ == 1) asm("incb ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count))); else if (pao_ID__ == -1) asm("decb ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count))); else asm("addb %1, ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count)) : "qi" ((pao_T__)(val))); break; case 2: if (pao_ID__ == 1) asm("incw ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count))); else if (pao_ID__ == -1) asm("decw ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count))); else asm("addw %1, ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count)) : "ri" ((pao_T__)(val))); break; case 4: if (pao_ID__ == 1) asm("incl ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count))); else if (pao_ID__ == -1) asm("decl ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count))); else asm("addl %1, ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count)) : "ri" ((pao_T__)(val))); break; case 8: if (pao_ID__ == 1) asm("incq ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count))); else if (pao_ID__ == -1) asm("decq ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count))); else asm("addq %1, ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count)) : "re" ((pao_T__)(val))); break; default: __bad_percpu_size(); } } while (0);
}

static inline __attribute__((always_inline)) void __preempt_count_sub(int val)
{
 do { typedef typeof((__preempt_count)) pao_T__; int pao_ID__ = (__builtin_constant_p(-val) && ((-val) == 1 || (-val) == -1)) ? (int)(-val) : 0; if (0) { pao_T__ pao_tmp__; pao_tmp__ = (-val); (void)pao_tmp__; } switch (sizeof((__preempt_count))) { case 1: if (pao_ID__ == 1) asm("incb ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count))); else if (pao_ID__ == -1) asm("decb ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count))); else asm("addb %1, ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count)) : "qi" ((pao_T__)(-val))); break; case 2: if (pao_ID__ == 1) asm("incw ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count))); else if (pao_ID__ == -1) asm("decw ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count))); else asm("addw %1, ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count)) : "ri" ((pao_T__)(-val))); break; case 4: if (pao_ID__ == 1) asm("incl ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count))); else if (pao_ID__ == -1) asm("decl ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count))); else asm("addl %1, ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count)) : "ri" ((pao_T__)(-val))); break; case 8: if (pao_ID__ == 1) asm("incq ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count))); else if (pao_ID__ == -1) asm("decq ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count))); else asm("addq %1, ""%%""gs"":" "%P" "0" : "+m" ((__preempt_count)) : "re" ((pao_T__)(-val))); break; default: __bad_percpu_size(); } } while (0);
}






static inline __attribute__((always_inline)) bool __preempt_count_dec_and_test(void)
{
 do { char c; asm ("decl" " " "%%""gs"":" "%P" "0" "; set" "e" " %1" : "+m" (__preempt_count), "=qm" (c) : : "memory"); return c != 0; } while (0);
}




static inline __attribute__((always_inline)) bool should_resched(void)
{
 return __builtin_expect(!!(!({ typeof((__preempt_count)) pfo_ret__; switch (sizeof((__preempt_count))) { case 1: asm("mov" "b ""%%""gs"":" "%P" "1"",%0" : "=q" (pfo_ret__) : "m"(__preempt_count)); break; case 2: asm("mov" "w ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"(__preempt_count)); break; case 4: asm("mov" "l ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"(__preempt_count)); break; case 8: asm("mov" "q ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"(__preempt_count)); break; default: __bad_percpu_size(); } pfo_ret__; })), 0);
}
struct preempt_notifier;
struct preempt_ops {
  template <typename, int = 0> struct __BYPASSpreempt_ops {};
  template <typename, int> friend struct __BYPASSpreempt_ops;
 void (*sched_in)(struct preempt_notifier *notifier, int cpu);
 void (*sched_out)(struct preempt_notifier *notifier,
     struct task_struct *next);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct preempt_notifier {
  template <typename, int = 0> struct __BYPASSpreempt_notifier {};
  template <typename, int> friend struct __BYPASSpreempt_notifier;
 struct hlist_node link;
 struct preempt_ops *ops;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

void preempt_notifier_register(struct preempt_notifier *notifier);
void preempt_notifier_unregister(struct preempt_notifier *notifier);

static inline void preempt_notifier_init(struct preempt_notifier *notifier,
         struct preempt_ops *ops)
{
 INIT_HLIST_NODE(&notifier->link);
 notifier->ops = ops;
}









extern void local_bh_disable(void);
extern void _local_bh_enable(void);
extern void local_bh_enable(void);
extern void local_bh_enable_ip(unsigned long ip);
static inline __attribute__((always_inline)) void rdtsc_barrier(void)
{
 asm ("661:\n\t" ".byte " "0x66,0x66,0x90" "\n" "\n662:\n" ".pushsection .altinstructions,\"a\"\n" " .long 661b - .\n" " .long " "663""1""f - .\n" " .word " "(3*32+17)" "\n" " .byte " "662b-661b" "\n" " .byte " "664""1""f-""663""1""f" "\n" ".popsection\n" ".pushsection .discard,\"aw\",@progbits\n" " .byte 0xff + (" "664""1""f-""663""1""f" ") - (" "662b-661b" ")\n" ".popsection\n" ".pushsection .altinstr_replacement, \"ax\"\n" "663""1"":\n\t" "mfence" "\n" "664""1" ":\n\t" ".popsection" : : : "memory");
 asm ("661:\n\t" ".byte " "0x66,0x66,0x90" "\n" "\n662:\n" ".pushsection .altinstructions,\"a\"\n" " .long 661b - .\n" " .long " "663""1""f - .\n" " .word " "(3*32+18)" "\n" " .byte " "662b-661b" "\n" " .byte " "664""1""f-""663""1""f" "\n" ".popsection\n" ".pushsection .discard,\"aw\",@progbits\n" " .byte 0xff + (" "664""1""f-""663""1""f" ") - (" "662b-661b" ")\n" ".popsection\n" ".pushsection .altinstr_replacement, \"ax\"\n" "663""1"":\n\t" "lfence" "\n" "664""1" ":\n\t" ".popsection" : : : "memory");
}
struct task_struct;
struct lockdep_map;


extern int prove_locking;
extern int lock_stat;
static inline void lockdep_off(void)
{
}

static inline void lockdep_on(void)
{
}
struct lock_class_key {
  template <typename, int = 0> struct __BYPASSlock_class_key {};
  template <typename, int> friend struct __BYPASSlock_class_key; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
};
static inline void print_irqtrace_events(struct task_struct *curr)
{
}

typedef struct raw_spinlock {
  template <typename, int = 0> struct __BYPASSraw_spinlock {};
  template <typename, int> friend struct __BYPASSraw_spinlock;
 arch_spinlock_t raw_lock;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} raw_spinlock_t;
typedef struct spinlock {
  template <typename, int = 0> struct __BYPASSspinlock {};
  template <typename, int> friend struct __BYPASSspinlock;
 union {
  struct raw_spinlock rlock;
 };

  friend class ::Introspect;
  friend class ::MyIntrospect;
} spinlock_t;
typedef struct {
 arch_rwlock_t raw_lock;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} rwlock_t;








extern bool static_key_initialized;
enum jump_label_type {
 JUMP_LABEL_DISABLE = 0,
 JUMP_LABEL_ENABLE,
};

struct module;
struct static_key {
  template <typename, int = 0> struct __BYPASSstatic_key {};
  template <typename, int> friend struct __BYPASSstatic_key;
 atomic_t enabled;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

static inline __attribute__((always_inline)) void jump_label_init(void)
{
 static_key_initialized = _true;
}

static inline __attribute__((always_inline)) bool static_key_false(struct static_key *key)
{
 if (__builtin_expect(!!(atomic_read(&key->enabled) > 0), 0))
  return _true;
 return _false;
}

static inline __attribute__((always_inline)) bool static_key_true(struct static_key *key)
{
 if (__builtin_expect(!!(atomic_read(&key->enabled) > 0), 1))
  return _true;
 return _false;
}

static inline void static_key_slow_inc(struct static_key *key)
{
 (!static_key_initialized);
 ;
}

static inline void static_key_slow_dec(struct static_key *key)
{
 (!static_key_initialized);
 ;
}

static inline int jump_label_text_reserved(void *start, void *end)
{
 return 0;
}

static inline void jump_label_lock(void) {}
static inline void jump_label_unlock(void) {}

static inline int jump_label_apply_nops(struct module *mod)
{
 return 0;
}
static inline bool static_key_enabled(struct static_key *key)
{
 return (atomic_read(&key->enabled) > 0);
}
extern int _atomic_dec_and_lock(atomic_t *atomic, spinlock_t *lock);


typedef struct __wait_queue wait_queue_t;
typedef int (*wait_queue_func_t)(wait_queue_t *wait, unsigned mode, int flags, void *key);
int default_wake_function(wait_queue_t *wait, unsigned mode, int flags, void *key);

struct __wait_queue {
  template <typename, int = 0> struct __BYPASS__wait_queue {};
  template <typename, int> friend struct __BYPASS__wait_queue;
 unsigned int flags;

 void *_private;
 wait_queue_func_t func;
 struct list_head task_list;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct wait_bit_key {
  template <typename, int = 0> struct __BYPASSwait_bit_key {};
  template <typename, int> friend struct __BYPASSwait_bit_key;
 void *flags;
 int bit_nr;


  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct wait_bit_queue {
  template <typename, int = 0> struct __BYPASSwait_bit_queue {};
  template <typename, int> friend struct __BYPASSwait_bit_queue;
 struct wait_bit_key key;
 wait_queue_t wait;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct __wait_queue_head {
  template <typename, int = 0> struct __BYPASS__wait_queue_head {};
  template <typename, int> friend struct __BYPASS__wait_queue_head;
 spinlock_t lock;
 struct list_head task_list;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
typedef struct __wait_queue_head wait_queue_head_t;

struct task_struct;
extern void __init_waitqueue_head(wait_queue_head_t *q, char *name, struct lock_class_key *);
static inline void init_waitqueue_entry(wait_queue_t *q, struct task_struct *p)
{
 q->flags = 0;
 q->_private = p;
 q->func = default_wake_function;
}

static inline void
init_waitqueue_func_entry(wait_queue_t *q, wait_queue_func_t func)
{
 q->flags = 0;
 q->_private = 0;
 q->func = func;
}

static inline int waitqueue_active(wait_queue_head_t *q)
{
 return !list_empty(&q->task_list);
}

extern void add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait);
extern void add_wait_queue_exclusive(wait_queue_head_t *q, wait_queue_t *wait);
extern void remove_wait_queue(wait_queue_head_t *q, wait_queue_t *wait);

static inline void __add_wait_queue(wait_queue_head_t *head, wait_queue_t *_new)
{
 list_add(&_new->task_list, &head->task_list);
}




static inline void
__add_wait_queue_exclusive(wait_queue_head_t *q, wait_queue_t *wait)
{
 wait->flags |= 0x01;
 __add_wait_queue(q, wait);
}

static inline void __add_wait_queue_tail(wait_queue_head_t *head,
      wait_queue_t *_new)
{
 list_add_tail(&_new->task_list, &head->task_list);
}

static inline void
__add_wait_queue_tail_exclusive(wait_queue_head_t *q, wait_queue_t *wait)
{
 wait->flags |= 0x01;
 __add_wait_queue_tail(q, wait);
}

static inline void
__remove_wait_queue(wait_queue_head_t *head, wait_queue_t *old)
{
 list_del(&old->task_list);
}

void __wake_up(wait_queue_head_t *q, unsigned int mode, int nr, void *key);
void __wake_up_locked_key(wait_queue_head_t *q, unsigned int mode, void *key);
void __wake_up_sync_key(wait_queue_head_t *q, unsigned int mode, int nr, void *key);
void __wake_up_locked(wait_queue_head_t *q, unsigned int mode, int nr);
void __wake_up_sync(wait_queue_head_t *q, unsigned int mode, int nr);
void __wake_up_bit(wait_queue_head_t *, void *, int);
int __wait_on_bit(wait_queue_head_t *, struct wait_bit_queue *, int (*)(void *), unsigned);
int __wait_on_bit_lock(wait_queue_head_t *, struct wait_bit_queue *, int (*)(void *), unsigned);
void wake_up_bit(void *, int);
void wake_up_atomic_t(atomic_t *);
int out_of_line_wait_on_bit(void *, int, int (*)(void *), unsigned);
int out_of_line_wait_on_bit_lock(void *, int, int (*)(void *), unsigned);
int out_of_line_wait_on_atomic_t(atomic_t *, int (*)(atomic_t *), unsigned);
wait_queue_head_t *bit_waitqueue(void *, int);
extern void sleep_on(wait_queue_head_t *q);
extern long sleep_on_timeout(wait_queue_head_t *q, signed long timeout);
extern void interruptible_sleep_on(wait_queue_head_t *q);
extern long interruptible_sleep_on_timeout(wait_queue_head_t *q, signed long timeout);




void prepare_to_wait(wait_queue_head_t *q, wait_queue_t *wait, int state);
void prepare_to_wait_exclusive(wait_queue_head_t *q, wait_queue_t *wait, int state);
long prepare_to_wait_event(wait_queue_head_t *q, wait_queue_t *wait, int state);
void finish_wait(wait_queue_head_t *q, wait_queue_t *wait);
void abort_exclusive_wait(wait_queue_head_t *q, wait_queue_t *wait, unsigned int mode, void *key);
int autoremove_wake_function(wait_queue_t *wait, unsigned mode, int sync, void *key);
int wake_bit_function(wait_queue_t *wait, unsigned mode, int sync, void *key);
static inline int
wait_on_bit(void *word, int bit, int (*action)(void *), unsigned mode)
{



        if (!(__builtin_constant_p((bit)) ? constant_test_bit((bit), ((unsigned long *)word)) : variable_test_bit((bit), ((unsigned long *)word))))

  return 0;
 return out_of_line_wait_on_bit(word, bit, action, mode);
}
static inline int
wait_on_bit_lock(void *word, int bit, int (*action)(void *), unsigned mode)
{



        if (!test_and_set_bit(bit, (unsigned long *)word))

  return 0;
 return out_of_line_wait_on_bit_lock(word, bit, action, mode);
}
static inline
int wait_on_atomic_t(atomic_t *val, int (*action)(atomic_t *), unsigned mode)
{
 if (atomic_read(val) == 0)
  return 0;
 return out_of_line_wait_on_atomic_t(val, action, mode);
}




typedef struct seqcount {
  template <typename, int = 0> struct __BYPASSseqcount {};
  template <typename, int> friend struct __BYPASSseqcount;
 unsigned sequence;




  friend class ::Introspect;
  friend class ::MyIntrospect;
} seqcount_t;
typedef struct {
 struct seqcount seqcount;
 spinlock_t lock;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} seqlock_t;
typedef struct _nodemask {
  template <typename, int = 0> struct __BYPASS_nodemask {};
  template <typename, int> friend struct __BYPASS_nodemask; unsigned long bits[((((1 << 6)) + (8 * sizeof(long)) - 1) / (8 * sizeof(long)))]; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} nodemask_t;

extern nodemask_t _unused_nodemask_arg_;

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_165_0 {
  typedef TJP__ZN9_nodemask4bitsE_165_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_165(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_165_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline __attribute__((always_inline)) void __node_set(int node, nodemask_t *dstp)
{
 set_bit(node, __get__ZN9_nodemask4bitsE_165(dstp->bits));
}



template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_166_0 {
  typedef TJP__ZN9_nodemask4bitsE_166_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_166(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_166_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void __node_clear(int node, nodemask_t *dstp)
{
 clear_bit(node, __get__ZN9_nodemask4bitsE_166(dstp->bits));
}



template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_167_0 {
  typedef TJP__ZN9_nodemask4bitsE_167_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_167(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_167_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void __nodes_setall(nodemask_t *dstp, int nbits)
{
 bitmap_fill(__get__ZN9_nodemask4bitsE_167(dstp->bits), nbits);
}



template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_168_0 {
  typedef TJP__ZN9_nodemask4bitsE_168_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_168(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_168_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void __nodes_clear(nodemask_t *dstp, int nbits)
{
 bitmap_zero(__get__ZN9_nodemask4bitsE_168(dstp->bits), nbits);
}







template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_169_0 {
  typedef TJP__ZN9_nodemask4bitsE_169_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_169(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_169_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __node_test_and_set(int node, nodemask_t *addr)
{
 return test_and_set_bit(node, __get__ZN9_nodemask4bitsE_169(addr->bits));
}




template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_170_0 {
  typedef TJP__ZN9_nodemask4bitsE_170_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_170(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_170_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_171_0 {
  typedef TJP__ZN9_nodemask4bitsE_171_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_171(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_171_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_172_0 {
  typedef TJP__ZN9_nodemask4bitsE_172_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_172(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_172_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void __nodes_and(nodemask_t *dstp, nodemask_t *src1p,
     nodemask_t *src2p, int nbits)
{
 bitmap_and(__get__ZN9_nodemask4bitsE_170(dstp->bits), __get__ZN9_nodemask4bitsE_171(src1p->bits), __get__ZN9_nodemask4bitsE_172(src2p->bits), nbits);
}




template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_173_0 {
  typedef TJP__ZN9_nodemask4bitsE_173_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_173(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_173_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_174_0 {
  typedef TJP__ZN9_nodemask4bitsE_174_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_174(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_174_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_175_0 {
  typedef TJP__ZN9_nodemask4bitsE_175_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_175(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_175_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void __nodes_or(nodemask_t *dstp, nodemask_t *src1p,
     nodemask_t *src2p, int nbits)
{
 bitmap_or(__get__ZN9_nodemask4bitsE_173(dstp->bits), __get__ZN9_nodemask4bitsE_174(src1p->bits), __get__ZN9_nodemask4bitsE_175(src2p->bits), nbits);
}




template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_176_0 {
  typedef TJP__ZN9_nodemask4bitsE_176_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_176(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_176_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_177_0 {
  typedef TJP__ZN9_nodemask4bitsE_177_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_177(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_177_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_178_0 {
  typedef TJP__ZN9_nodemask4bitsE_178_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_178(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_178_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void __nodes_xor(nodemask_t *dstp, nodemask_t *src1p,
     nodemask_t *src2p, int nbits)
{
 bitmap_xor(__get__ZN9_nodemask4bitsE_176(dstp->bits), __get__ZN9_nodemask4bitsE_177(src1p->bits), __get__ZN9_nodemask4bitsE_178(src2p->bits), nbits);
}




template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_179_0 {
  typedef TJP__ZN9_nodemask4bitsE_179_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_179(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_179_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_180_0 {
  typedef TJP__ZN9_nodemask4bitsE_180_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_180(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_180_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_181_0 {
  typedef TJP__ZN9_nodemask4bitsE_181_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_181(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_181_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void __nodes_andnot(nodemask_t *dstp, nodemask_t *src1p,
     nodemask_t *src2p, int nbits)
{
 bitmap_andnot(__get__ZN9_nodemask4bitsE_179(dstp->bits), __get__ZN9_nodemask4bitsE_180(src1p->bits), __get__ZN9_nodemask4bitsE_181(src2p->bits), nbits);
}




template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_182_0 {
  typedef TJP__ZN9_nodemask4bitsE_182_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_182(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_182_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_183_0 {
  typedef TJP__ZN9_nodemask4bitsE_183_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_183(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_183_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void __nodes_complement(nodemask_t *dstp,
     nodemask_t *srcp, int nbits)
{
 bitmap_complement(__get__ZN9_nodemask4bitsE_182(dstp->bits), __get__ZN9_nodemask4bitsE_183(srcp->bits), nbits);
}




template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_184_0 {
  typedef TJP__ZN9_nodemask4bitsE_184_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_184(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_184_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_185_0 {
  typedef TJP__ZN9_nodemask4bitsE_185_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_185(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_185_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __nodes_equal( nodemask_t *src1p,
     nodemask_t *src2p, int nbits)
{
 return bitmap_equal(__get__ZN9_nodemask4bitsE_184(src1p->bits), __get__ZN9_nodemask4bitsE_185(src2p->bits), nbits);
}




template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_186_0 {
  typedef TJP__ZN9_nodemask4bitsE_186_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_186(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_186_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_187_0 {
  typedef TJP__ZN9_nodemask4bitsE_187_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_187(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_187_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __nodes_intersects( nodemask_t *src1p,
     nodemask_t *src2p, int nbits)
{
 return bitmap_intersects(__get__ZN9_nodemask4bitsE_186(src1p->bits), __get__ZN9_nodemask4bitsE_187(src2p->bits), nbits);
}




template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_188_0 {
  typedef TJP__ZN9_nodemask4bitsE_188_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_188(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_188_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_189_0 {
  typedef TJP__ZN9_nodemask4bitsE_189_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_189(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_189_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __nodes_subset( nodemask_t *src1p,
     nodemask_t *src2p, int nbits)
{
 return bitmap_subset(__get__ZN9_nodemask4bitsE_188(src1p->bits), __get__ZN9_nodemask4bitsE_189(src2p->bits), nbits);
}



template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_190_0 {
  typedef TJP__ZN9_nodemask4bitsE_190_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_190(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_190_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __nodes_empty( nodemask_t *srcp, int nbits)
{
 return bitmap_empty(__get__ZN9_nodemask4bitsE_190(srcp->bits), nbits);
}



template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_191_0 {
  typedef TJP__ZN9_nodemask4bitsE_191_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_191(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_191_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __nodes_full( nodemask_t *srcp, int nbits)
{
 return bitmap_full(__get__ZN9_nodemask4bitsE_191(srcp->bits), nbits);
}



template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_192_0 {
  typedef TJP__ZN9_nodemask4bitsE_192_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_192(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_192_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __nodes_weight( nodemask_t *srcp, int nbits)
{
 return bitmap_weight(__get__ZN9_nodemask4bitsE_192(srcp->bits), nbits);
}




template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_193_0 {
  typedef TJP__ZN9_nodemask4bitsE_193_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_193(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_193_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_194_0 {
  typedef TJP__ZN9_nodemask4bitsE_194_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_194(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_194_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void __nodes_shift_right(nodemask_t *dstp,
     nodemask_t *srcp, int n, int nbits)
{
 bitmap_shift_right(__get__ZN9_nodemask4bitsE_193(dstp->bits), __get__ZN9_nodemask4bitsE_194(srcp->bits), n, nbits);
}




template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_195_0 {
  typedef TJP__ZN9_nodemask4bitsE_195_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_195(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_195_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_196_0 {
  typedef TJP__ZN9_nodemask4bitsE_196_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_196(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_196_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void __nodes_shift_left(nodemask_t *dstp,
     nodemask_t *srcp, int n, int nbits)
{
 bitmap_shift_left(__get__ZN9_nodemask4bitsE_195(dstp->bits), __get__ZN9_nodemask4bitsE_196(srcp->bits), n, nbits);
}






template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_197_0 {
  typedef TJP__ZN9_nodemask4bitsE_197_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_197(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_197_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __first_node( nodemask_t *srcp)
{
 return ({ int __min1 = ((1 << 6)); int __min2 = (find_first_bit(__get__ZN9_nodemask4bitsE_197(srcp->bits), (1 << 6))); __min1 < __min2 ? __min1: __min2; });
}



template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_198_0 {
  typedef TJP__ZN9_nodemask4bitsE_198_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_198(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_198_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __next_node(int n, nodemask_t *srcp)
{
 return ({ int __min1 = ((1 << 6)); int __min2 = (find_next_bit(__get__ZN9_nodemask4bitsE_198(srcp->bits), (1 << 6), n+1)); __min1 < __min2 ? __min1: __min2; });
}

static inline void init_nodemask_of_node(nodemask_t *mask, int node)
{
 __nodes_clear(&(*mask), (1 << 6));
 __node_set((node), &(*mask));
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_199_0 {
  typedef TJP__ZN9_nodemask4bitsE_199_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_199(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_199_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __first_unset_node( nodemask_t *maskp)
{
 return ({ int __min1 = ((1 << 6)); int __min2 = (find_first_zero_bit(__get__ZN9_nodemask4bitsE_199(maskp->bits), (1 << 6))); __min1 < __min2 ? __min1: __min2; })
                                                  ;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_200_0 {
  typedef TJP__ZN9_nodemask4bitsE_200_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_200(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_200_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __nodemask_scnprintf(char *buf, int len,
     nodemask_t *srcp, int nbits)
{
 return bitmap_scnprintf(buf, len, __get__ZN9_nodemask4bitsE_200(srcp->bits), nbits);
}




template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_201_0 {
  typedef TJP__ZN9_nodemask4bitsE_201_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_201(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_201_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __nodemask_parse_user( char *buf, int len,
     nodemask_t *dstp, int nbits)
{
 return bitmap_parse_user(buf, len, __get__ZN9_nodemask4bitsE_201(dstp->bits), nbits);
}




template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_202_0 {
  typedef TJP__ZN9_nodemask4bitsE_202_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_202(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_202_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __nodelist_scnprintf(char *buf, int len,
     nodemask_t *srcp, int nbits)
{
 return bitmap_scnlistprintf(buf, len, __get__ZN9_nodemask4bitsE_202(srcp->bits), nbits);
}



template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_203_0 {
  typedef TJP__ZN9_nodemask4bitsE_203_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_203(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_203_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __nodelist_parse( char *buf, nodemask_t *dstp, int nbits)
{
 return bitmap_parselist(buf, __get__ZN9_nodemask4bitsE_203(dstp->bits), nbits);
}




template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_204_0 {
  typedef TJP__ZN9_nodemask4bitsE_204_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_204(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_204_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_205_0 {
  typedef TJP__ZN9_nodemask4bitsE_205_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_205(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_205_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int __node_remap(int oldbit,
  nodemask_t *oldp, nodemask_t *newp, int nbits)
{
 return bitmap_bitremap(oldbit, __get__ZN9_nodemask4bitsE_204(oldp->bits), __get__ZN9_nodemask4bitsE_205(newp->bits), nbits);
}




template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_206_0 {
  typedef TJP__ZN9_nodemask4bitsE_206_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_206(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_206_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_207_0 {
  typedef TJP__ZN9_nodemask4bitsE_207_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_207(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_207_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_208_0 {
  typedef TJP__ZN9_nodemask4bitsE_208_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_208(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_208_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_209_0 {
  typedef TJP__ZN9_nodemask4bitsE_209_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_209(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_209_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void __nodes_remap(nodemask_t *dstp, nodemask_t *srcp,
  nodemask_t *oldp, nodemask_t *newp, int nbits)
{
 bitmap_remap(__get__ZN9_nodemask4bitsE_206(dstp->bits), __get__ZN9_nodemask4bitsE_207(srcp->bits), __get__ZN9_nodemask4bitsE_208(oldp->bits), __get__ZN9_nodemask4bitsE_209(newp->bits), nbits);
}




template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_210_0 {
  typedef TJP__ZN9_nodemask4bitsE_210_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_210(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_210_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_211_0 {
  typedef TJP__ZN9_nodemask4bitsE_211_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_211(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_211_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_212_0 {
  typedef TJP__ZN9_nodemask4bitsE_212_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_212(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_212_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void __nodes_onto(nodemask_t *dstp, nodemask_t *origp,
  nodemask_t *relmapp, int nbits)
{
 bitmap_onto(__get__ZN9_nodemask4bitsE_210(dstp->bits), __get__ZN9_nodemask4bitsE_211(origp->bits), __get__ZN9_nodemask4bitsE_212(relmapp->bits), nbits);
}




template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_213_0 {
  typedef TJP__ZN9_nodemask4bitsE_213_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_213(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_213_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_214_0 {
  typedef TJP__ZN9_nodemask4bitsE_214_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_214(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_214_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline void __nodes_fold(nodemask_t *dstp, nodemask_t *origp,
  int sz, int nbits)
{
 bitmap_fold(__get__ZN9_nodemask4bitsE_213(dstp->bits), __get__ZN9_nodemask4bitsE_214(origp->bits), sz, nbits);
}
enum node_states {
 N_POSSIBLE,
 N_ONLINE,
 N_NORMAL_MEMORY,



 N_HIGH_MEMORY = N_NORMAL_MEMORY,


 N_MEMORY,



 N_CPU,
 NR_NODE_STATES
};






extern nodemask_t node_states[NR_NODE_STATES];



template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_215_0 {
  typedef TJP__ZN9_nodemask4bitsE_215_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_215(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_215_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9_nodemask4bitsE_217_0 {
  typedef TJP__ZN9_nodemask4bitsE_217_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 1;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN9_nodemask4bitsE_217(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN9_nodemask4bitsE_217_0< unsigned long int *, ::_nodemask , unsigned long int [1] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
static inline int node_state(int node, enum node_states state)
{
 return (__builtin_constant_p(((node))) ? constant_test_bit(((node)), (__get__ZN9_nodemask4bitsE_215((node_states[state]).bits))) : variable_test_bit(((node)), (__get__ZN9_nodemask4bitsE_217((node_states[state]).bits))));
}

static inline void node_set_state(int node, enum node_states state)
{
 __node_set(node, &node_states[state]);
}

static inline void node_clear_state(int node, enum node_states state)
{
 __node_clear(node, &node_states[state]);
}

static inline int num_node_state(enum node_states state)
{
 return __nodes_weight(&(node_states[state]), (1 << 6));
}







extern int nr_node_ids;
extern int nr_online_nodes;

static inline void node_set_online(int nid)
{
 node_set_state(nid, N_ONLINE);
 nr_online_nodes = num_node_state(N_ONLINE);
}

static inline void node_set_offline(int nid)
{
 node_clear_state(nid, N_ONLINE);
 nr_online_nodes = num_node_state(N_ONLINE);
}
extern int node_random( nodemask_t *maskp);
struct nodemask_scratch {
  template <typename, int = 0> struct __BYPASSnodemask_scratch {};
  template <typename, int> friend struct __BYPASSnodemask_scratch;
 nodemask_t mask1;
 nodemask_t mask2;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
enum pageblock_bits {
 PB_migrate,
 PB_migrate_end = PB_migrate + 3 - 1,


 PB_migrate_skip,

 NR_PAGEBLOCK_BITS
};
struct page;


unsigned long get_pageblock_flags_group(struct page *page,
     int start_bitidx, int end_bitidx);
void set_pageblock_flags_group(struct page *page, unsigned long flags,
     int start_bitidx, int end_bitidx);




enum {
 MIGRATE_UNMOVABLE,
 MIGRATE_RECLAIMABLE,
 MIGRATE_MOVABLE,
 MIGRATE_PCPTYPES,
 MIGRATE_RESERVE = MIGRATE_PCPTYPES,
 MIGRATE_CMA,


 MIGRATE_ISOLATE,

 MIGRATE_TYPES
};
extern int page_group_by_mobility_disabled;

static inline int get_pageblock_migratetype(struct page *page)
{
 return get_pageblock_flags_group(page, PB_migrate, PB_migrate_end);
}

struct free_area {
  template <typename, int = 0> struct __BYPASSfree_area {};
  template <typename, int> friend struct __BYPASSfree_area;
 struct list_head free_list[MIGRATE_TYPES];
 unsigned long nr_free;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct pglist_data;
struct zone_padding {
  template <typename, int = 0> struct __BYPASSzone_padding {};
  template <typename, int> friend struct __BYPASSzone_padding;
 char x[0];

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__((__aligned__(1 << (6))));





enum zone_stat_item {

 NR_FREE_PAGES,
 NR_ALLOC_BATCH,
 NR_LRU_BASE,
 NR_INACTIVE_ANON = NR_LRU_BASE,
 NR_ACTIVE_ANON,
 NR_INACTIVE_FILE,
 NR_ACTIVE_FILE,
 NR_UNEVICTABLE,
 NR_MLOCK,
 NR_ANON_PAGES,
 NR_FILE_MAPPED,

 NR_FILE_PAGES,
 NR_FILE_DIRTY,
 NR_WRITEBACK,
 NR_SLAB_RECLAIMABLE,
 NR_SLAB_UNRECLAIMABLE,
 NR_PAGETABLE,
 NR_KERNEL_STACK,

 NR_UNSTABLE_NFS,
 NR_BOUNCE,
 NR_VMSCAN_WRITE,
 NR_VMSCAN_IMMEDIATE,
 NR_WRITEBACK_TEMP,
 NR_ISOLATED_ANON,
 NR_ISOLATED_FILE,
 NR_SHMEM,
 NR_DIRTIED,
 NR_WRITTEN,

 NUMA_HIT,
 NUMA_MISS,
 NUMA_FOREIGN,
 NUMA_INTERLEAVE_HIT,
 NUMA_LOCAL,
 NUMA_OTHER,

 NR_ANON_TRANSPARENT_HUGEPAGES,
 NR_FREE_CMA_PAGES,
 NR_VM_ZONE_STAT_ITEMS };
enum lru_list {
 LRU_INACTIVE_ANON = 0,
 LRU_ACTIVE_ANON = 0 + 1,
 LRU_INACTIVE_FILE = 0 + 2,
 LRU_ACTIVE_FILE = 0 + 2 + 1,
 LRU_UNEVICTABLE,
 NR_LRU_LISTS
};





static inline int is_file_lru(enum lru_list lru)
{
 return (lru == LRU_INACTIVE_FILE || lru == LRU_ACTIVE_FILE);
}

static inline int is_active_lru(enum lru_list lru)
{
 return (lru == LRU_ACTIVE_ANON || lru == LRU_ACTIVE_FILE);
}

static inline int is_unevictable_lru(enum lru_list lru)
{
 return (lru == LRU_UNEVICTABLE);
}

struct zone_reclaim_stat {
  template <typename, int = 0> struct __BYPASSzone_reclaim_stat {};
  template <typename, int> friend struct __BYPASSzone_reclaim_stat;
 unsigned long recent_rotated[2];
 unsigned long recent_scanned[2];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct lruvec {
  template <typename, int = 0> struct __BYPASSlruvec {};
  template <typename, int> friend struct __BYPASSlruvec;
 struct list_head lists[NR_LRU_LISTS];
 struct zone_reclaim_stat reclaim_stat;

 struct zone *zone;


  friend class ::Introspect;
  friend class ::MyIntrospect;
};
typedef unsigned isolate_mode_t;

enum zone_watermarks {
 WMARK_MIN,
 WMARK_LOW,
 WMARK_HIGH,
 NR_WMARK
};





struct per_cpu_pages {
  template <typename, int = 0> struct __BYPASSper_cpu_pages {};
  template <typename, int> friend struct __BYPASSper_cpu_pages;
 int count;
 int high;
 int batch;


 struct list_head lists[MIGRATE_PCPTYPES];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct per_cpu_pageset {
  template <typename, int = 0> struct __BYPASSper_cpu_pageset {};
  template <typename, int> friend struct __BYPASSper_cpu_pageset;
 struct per_cpu_pages pcp;

 s8 expire;


 s8 stat_threshold;
 s8 vm_stat_diff[NR_VM_ZONE_STAT_ITEMS];


  friend class ::Introspect;
  friend class ::MyIntrospect;
};



enum zone_type {
 ZONE_DMA,







 ZONE_DMA32,






 ZONE_NORMAL,
 ZONE_MOVABLE,
 __MAX_NR_ZONES
};



struct zone {
  template <typename, int = 0> struct __BYPASSzone {};
  template <typename, int> friend struct __BYPASSzone;



 unsigned long watermark[NR_WMARK];






 unsigned long percpu_drift_mark;
 unsigned long lowmem_reserve[4];





 unsigned long dirty_balance_reserve;


 int node;



 unsigned long min_unmapped_pages;
 unsigned long min_slab_pages;

 struct per_cpu_pageset *pageset;



 spinlock_t lock;


 bool compact_blockskip_flush;


 unsigned long compact_cached_free_pfn;
 unsigned long compact_cached_migrate_pfn;



 seqlock_t span_seqlock;

 struct free_area free_area[11];
 unsigned int compact_considered;
 unsigned int compact_defer_shift;
 int compact_order_failed;


 struct zone_padding _pad1_;


 spinlock_t lru_lock;
 struct lruvec lruvec;

 unsigned long pages_scanned;
 unsigned long flags;


 atomic_long_t vm_stat[NR_VM_ZONE_STAT_ITEMS];





 unsigned int inactive_ratio;


 struct zone_padding _pad2_;
 wait_queue_head_t * wait_table;
 unsigned long wait_table_hash_nr_entries;
 unsigned long wait_table_bits;




 struct pglist_data *zone_pgdat;

 unsigned long zone_start_pfn;
 unsigned long spanned_pages;
 unsigned long present_pages;
 unsigned long managed_pages;




 char *name;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__((__aligned__(1 << (6))));

typedef enum {
 ZONE_RECLAIM_LOCKED,
 ZONE_OOM_LOCKED,
 ZONE_CONGESTED,


 ZONE_TAIL_LRU_DIRTY,



 ZONE_WRITEBACK,


} zone_flags_t;

static inline void zone_set_flag(struct zone *zone, zone_flags_t flag)
{
 set_bit(flag, &zone->flags);
}

static inline int zone_test_and_set_flag(struct zone *zone, zone_flags_t flag)
{
 return test_and_set_bit(flag, &zone->flags);
}

static inline void zone_clear_flag(struct zone *zone, zone_flags_t flag)
{
 clear_bit(flag, &zone->flags);
}

static inline int zone_is_reclaim_congested( struct zone *zone)
{
 return (__builtin_constant_p((ZONE_CONGESTED)) ? constant_test_bit((ZONE_CONGESTED), (&zone->flags)) : variable_test_bit((ZONE_CONGESTED), (&zone->flags)));
}

static inline int zone_is_reclaim_dirty( struct zone *zone)
{
 return (__builtin_constant_p((ZONE_TAIL_LRU_DIRTY)) ? constant_test_bit((ZONE_TAIL_LRU_DIRTY), (&zone->flags)) : variable_test_bit((ZONE_TAIL_LRU_DIRTY), (&zone->flags)));
}

static inline int zone_is_reclaim_writeback( struct zone *zone)
{
 return (__builtin_constant_p((ZONE_WRITEBACK)) ? constant_test_bit((ZONE_WRITEBACK), (&zone->flags)) : variable_test_bit((ZONE_WRITEBACK), (&zone->flags)));
}

static inline int zone_is_reclaim_locked( struct zone *zone)
{
 return (__builtin_constant_p((ZONE_RECLAIM_LOCKED)) ? constant_test_bit((ZONE_RECLAIM_LOCKED), (&zone->flags)) : variable_test_bit((ZONE_RECLAIM_LOCKED), (&zone->flags)));
}

static inline int zone_is_oom_locked( struct zone *zone)
{
 return (__builtin_constant_p((ZONE_OOM_LOCKED)) ? constant_test_bit((ZONE_OOM_LOCKED), (&zone->flags)) : variable_test_bit((ZONE_OOM_LOCKED), (&zone->flags)));
}

static inline unsigned long zone_end_pfn( struct zone *zone)
{
 return zone->zone_start_pfn + zone->spanned_pages;
}

static inline bool zone_spans_pfn( struct zone *zone, unsigned long pfn)
{
 return zone->zone_start_pfn <= pfn && pfn < zone_end_pfn(zone);
}

static inline bool zone_is_initialized(struct zone *zone)
{
 return !!zone->wait_table;
}

static inline bool zone_is_empty(struct zone *zone)
{
 return zone->spanned_pages == 0;
}
struct zonelist_cache {
  template <typename, int = 0> struct __BYPASSzonelist_cache {};
  template <typename, int> friend struct __BYPASSzonelist_cache;
 unsigned short z_to_n[((1 << 6) * 4)];
 unsigned long fullzones[(((((1 << 6) * 4)) + (8 * sizeof(long)) - 1) / (8 * sizeof(long)))];
 unsigned long last_full_zap;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct zoneref {
  template <typename, int = 0> struct __BYPASSzoneref {};
  template <typename, int> friend struct __BYPASSzoneref;
 struct zone *zone;
 int zone_idx;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct zonelist {
  template <typename, int = 0> struct __BYPASSzonelist {};
  template <typename, int> friend struct __BYPASSzonelist;
 struct zonelist_cache *zlcache_ptr;
 struct zoneref _zonerefs[((1 << 6) * 4) + 1];

 struct zonelist_cache zlcache;


  friend class ::Introspect;
  friend class ::MyIntrospect;
};


struct node_active_region {
  template <typename, int = 0> struct __BYPASSnode_active_region {};
  template <typename, int> friend struct __BYPASSnode_active_region;
 unsigned long start_pfn;
 unsigned long end_pfn;
 int nid;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};




extern struct page *mem_map;
struct bootmem_data;
typedef struct pglist_data {
  template <typename, int = 0> struct __BYPASSpglist_data {};
  template <typename, int> friend struct __BYPASSpglist_data;
 struct zone node_zones[4];
 struct zonelist node_zonelists[2];
 int nr_zones;
 spinlock_t node_size_lock;

 unsigned long node_start_pfn;
 unsigned long node_present_pages;
 unsigned long node_spanned_pages;

 int node_id;
 nodemask_t reclaim_nodes;
 wait_queue_head_t kswapd_wait;
 wait_queue_head_t pfmemalloc_wait;
 struct task_struct *kswapd;
 int kswapd_max_order;
 enum zone_type classzone_idx;





 spinlock_t numabalancing_migrate_lock;


 unsigned long numabalancing_migrate_next_window;


 unsigned long numabalancing_migrate_nr_pages;


  friend class ::Introspect;
  friend class ::MyIntrospect;
} pg_data_t;
static inline unsigned long pgdat_end_pfn(pg_data_t *pgdat)
{
 return pgdat->node_start_pfn + pgdat->node_spanned_pages;
}

static inline bool pgdat_is_empty(pg_data_t *pgdat)
{
 return !pgdat->node_start_pfn && !pgdat->node_spanned_pages;
}





struct mutex {
  template <typename, int = 0> struct __BYPASSmutex {};
  template <typename, int> friend struct __BYPASSmutex;

 atomic_t count;
 spinlock_t wait_lock;
 struct list_head wait_list;

 struct task_struct *owner;


 void *spin_mlock;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};





struct mutex_waiter {
  template <typename, int = 0> struct __BYPASSmutex_waiter {};
  template <typename, int> friend struct __BYPASSmutex_waiter;
 struct list_head list;
 struct task_struct *task;




  friend class ::Introspect;
  friend class ::MyIntrospect;
};
extern int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock);
struct rw_semaphore;





struct rw_semaphore {
  template <typename, int = 0> struct __BYPASSrw_semaphore {};
  template <typename, int> friend struct __BYPASSrw_semaphore;
 long count;
 raw_spinlock_t wait_lock;
 struct list_head wait_list;




  friend class ::Introspect;
  friend class ::MyIntrospect;
};

extern struct rw_semaphore *rwsem_down_read_failed(struct rw_semaphore *sem);
extern struct rw_semaphore *rwsem_down_write_failed(struct rw_semaphore *sem);
extern struct rw_semaphore *rwsem_wake(struct rw_semaphore *);
extern struct rw_semaphore *rwsem_downgrade_wake(struct rw_semaphore *sem);


static inline void __down_read(struct rw_semaphore *sem)
{
 asm ("# beginning down_read\n\t"
       ".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " " " "incq" " " "(%1)\n\t"

       "  jns        1f\n"
       "  call call_rwsem_down_read_failed\n"
       "1:\n\t"
       "# ending down_read\n\t"
       : "+m" (sem->count)
       : "a" (sem)
       : "memory", "cc");
}




static inline int __down_read_trylock(struct rw_semaphore *sem)
{
 long result, tmp;
 asm ("# beginning __down_read_trylock\n\t"
       "  mov          %0,%1\n\t"
       "1:\n\t"
       "  mov          %1,%2\n\t"
       "  add          %3,%2\n\t"
       "  jle	     2f\n\t"
       ".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "  cmpxchg  %2,%0\n\t"
       "  jnz	     1b\n\t"
       "2:\n\t"
       "# ending __down_read_trylock\n\t"
       : "+m" (sem->count), "=&a" (result), "=&r" (tmp)
       : "i" (0x00000001L)
       : "memory", "cc");
 return result >= 0 ? 1 : 0;
}




static inline void __down_write_nested(struct rw_semaphore *sem, int subclass)
{
 long tmp;
 asm ("# beginning down_write\n\t"
       ".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "  xadd      %1,(%2)\n\t"

       "  test " " " "%k1" " " "," " " "%k1" " " "\n\t"

       "  jz        1f\n"
       "  call call_rwsem_down_write_failed\n"
       "1:\n"
       "# ending down_write"
       : "+m" (sem->count), "=d" (tmp)
       : "a" (sem), "1" (((-0xffffffffL -1) + 0x00000001L))
       : "memory", "cc");
}

static inline void __down_write(struct rw_semaphore *sem)
{
 __down_write_nested(sem, 0);
}




static inline int __down_write_trylock(struct rw_semaphore *sem)
{
 long result, tmp;
 asm ("# beginning __down_write_trylock\n\t"
       "  mov          %0,%1\n\t"
       "1:\n\t"
       "  test " " " "%k1" " " "," " " "%k1" " " "\n\t"

       "  jnz          2f\n\t"
       "  mov          %1,%2\n\t"
       "  add          %3,%2\n\t"
       ".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "  cmpxchg  %2,%0\n\t"
       "  jnz	     1b\n\t"
       "2:\n\t"
       "  sete         %b1\n\t"
       "  movzbl       %b1, %k1\n\t"
       "# ending __down_write_trylock\n\t"
       : "+m" (sem->count), "=&a" (result), "=&r" (tmp)
       : "er" (((-0xffffffffL -1) + 0x00000001L))
       : "memory", "cc");
 return result;
}




static inline void __up_read(struct rw_semaphore *sem)
{
 long tmp;
 asm ("# beginning __up_read\n\t"
       ".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "  xadd      %1,(%2)\n\t"

       "  jns        1f\n\t"
       "  call call_rwsem_wake\n"
       "1:\n"
       "# ending __up_read\n"
       : "+m" (sem->count), "=d" (tmp)
       : "a" (sem), "1" (-0x00000001L)
       : "memory", "cc");
}




static inline void __up_write(struct rw_semaphore *sem)
{
 long tmp;
 asm ("# beginning __up_write\n\t"
       ".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "  xadd      %1,(%2)\n\t"

       "  jns        1f\n\t"
       "  call call_rwsem_wake\n"
       "1:\n\t"
       "# ending __up_write\n"
       : "+m" (sem->count), "=d" (tmp)
       : "a" (sem), "1" (-((-0xffffffffL -1) + 0x00000001L))
       : "memory", "cc");
}




static inline void __downgrade_write(struct rw_semaphore *sem)
{
 asm ("# beginning __downgrade_write\n\t"
       ".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " " " "addq" " " "%2,(%1)\n\t"




       "  jns       1f\n\t"
       "  call call_rwsem_downgrade_wake\n"
       "1:\n\t"
       "# ending __downgrade_write\n"
       : "+m" (sem->count)
       : "a" (sem), "er" (-(-0xffffffffL -1))
       : "memory", "cc");
}




static inline void rwsem_atomic_add(long delta, struct rw_semaphore *sem)
{
 asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " " " "addq" " " "%1,%0"
       : "+m" (sem->count)
       : "er" (delta));
}




static inline long rwsem_atomic_update(long delta, struct rw_semaphore *sem)
{
 return delta + ({ __typeof__ (*(((&sem->count)))) __ret = (((delta))); switch (sizeof(*(((&sem->count))))) { case 1: asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "xadd" "b %b0, %1\n" : "+q" (__ret), "+m" (*(((&sem->count)))) : : "memory", "cc"); break; case 2: asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "xadd" "w %w0, %1\n" : "+r" (__ret), "+m" (*(((&sem->count)))) : : "memory", "cc"); break; case 4: asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "xadd" "l %0, %1\n" : "+r" (__ret), "+m" (*(((&sem->count)))) : : "memory", "cc"); break; case 8: asm (".pushsection .smp_locks,\"a\"\n" ".balign 4\n" ".long 671f - .\n" ".popsection\n" "671:" "\n\tlock; " "xadd" "q %q0, %1\n" : "+r" (__ret), "+m" (*(((&sem->count)))) : : "memory", "cc"); break; default: __xadd_wrong_size(); } __ret; });
}


static inline int rwsem_is_locked(struct rw_semaphore *sem)
{
 return sem->count != 0;
}
extern void __init_rwsem(struct rw_semaphore *sem, char *name,
    struct lock_class_key *key);
struct completion {
  template <typename, int = 0> struct __BYPASScompletion {};
  template <typename, int> friend struct __BYPASScompletion;
 unsigned int done;
 wait_queue_head_t wait;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
static inline void init_completion(struct completion *x)
{
 x->done = 0;
 do { static struct lock_class_key __key; __init_waitqueue_head((&x->wait), "&x->wait", &__key); } while (0);
}
static inline void reinit_completion(struct completion *x)
{
 x->done = 0;
}

extern void wait_for_completion(struct completion *);
extern void wait_for_completion_io(struct completion *);
extern int wait_for_completion_interruptible(struct completion *x);
extern int wait_for_completion_killable(struct completion *x);
extern unsigned long wait_for_completion_timeout(struct completion *x,
         unsigned long timeout);
extern unsigned long wait_for_completion_io_timeout(struct completion *x,
          unsigned long timeout);
extern long wait_for_completion_interruptible_timeout(
 struct completion *x, unsigned long timeout);
extern long wait_for_completion_killable_timeout(
 struct completion *x, unsigned long timeout);
extern bool try_wait_for_completion(struct completion *x);
extern bool completion_done(struct completion *x);

extern void complete(struct completion *);
extern void complete_all(struct completion *);






enum debug_obj_state {
 ODEBUG_STATE_NONE,
 ODEBUG_STATE_INIT,
 ODEBUG_STATE_INACTIVE,
 ODEBUG_STATE_ACTIVE,
 ODEBUG_STATE_DESTROYED,
 ODEBUG_STATE_NOTAVAILABLE,
 ODEBUG_STATE_MAX,
};

struct debug_obj_descr;
struct debug_obj {
  template <typename, int = 0> struct __BYPASSdebug_obj {};
  template <typename, int> friend struct __BYPASSdebug_obj;
 struct hlist_node node;
 enum debug_obj_state state;
 unsigned int astate;
 void *object;
 struct debug_obj_descr *descr;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct debug_obj_descr {
  template <typename, int = 0> struct __BYPASSdebug_obj_descr {};
  template <typename, int> friend struct __BYPASSdebug_obj_descr;
 char *name;
 void *(*debug_hint) (void *addr);
 int (*fixup_init) (void *addr, enum debug_obj_state state);
 int (*fixup_activate) (void *addr, enum debug_obj_state state);
 int (*fixup_destroy) (void *addr, enum debug_obj_state state);
 int (*fixup_free) (void *addr, enum debug_obj_state state);
 int (*fixup_assert_init)(void *addr, enum debug_obj_state state);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
static inline void
debug_object_init (void *addr, struct debug_obj_descr *descr) { }
static inline void
debug_object_init_on_stack(void *addr, struct debug_obj_descr *descr) { }
static inline int
debug_object_activate (void *addr, struct debug_obj_descr *descr) { return 0; }
static inline void
debug_object_deactivate(void *addr, struct debug_obj_descr *descr) { }
static inline void
debug_object_destroy (void *addr, struct debug_obj_descr *descr) { }
static inline void
debug_object_free (void *addr, struct debug_obj_descr *descr) { }
static inline void
debug_object_assert_init(void *addr, struct debug_obj_descr *descr) { }

static inline void debug_objects_early_init(void) { }
static inline void debug_objects_mem_init(void) { }





static inline void
debug_check_no_obj_freed( void *address, unsigned long size) { }

















struct timespec {
  template <typename, int = 0> struct __BYPASStimespec {};
  template <typename, int> friend struct __BYPASStimespec;
 __kernel_time_t tv_sec;
 long tv_nsec;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};


struct timeval {
  template <typename, int = 0> struct __BYPASStimeval {};
  template <typename, int> friend struct __BYPASStimeval;
 __kernel_time_t tv_sec;
 __kernel_suseconds_t tv_usec;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct timezone {
  template <typename, int = 0> struct __BYPASStimezone {};
  template <typename, int> friend struct __BYPASStimezone;
 int tz_minuteswest;
 int tz_dsttime;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct itimerspec {
  template <typename, int = 0> struct __BYPASSitimerspec {};
  template <typename, int> friend struct __BYPASSitimerspec;
 struct timespec it_interval;
 struct timespec it_value;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct itimerval {
  template <typename, int = 0> struct __BYPASSitimerval {};
  template <typename, int> friend struct __BYPASSitimerval;
 struct timeval it_interval;
 struct timeval it_value;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

extern struct timezone sys_tz;
static inline int timespec_equal( struct timespec *a,
                                 struct timespec *b)
{
 return (a->tv_sec == b->tv_sec) && (a->tv_nsec == b->tv_nsec);
}






static inline int timespec_compare( struct timespec *lhs, struct timespec *rhs)
{
 if (lhs->tv_sec < rhs->tv_sec)
  return -1;
 if (lhs->tv_sec > rhs->tv_sec)
  return 1;
 return lhs->tv_nsec - rhs->tv_nsec;
}

static inline int timeval_compare( struct timeval *lhs, struct timeval *rhs)
{
 if (lhs->tv_sec < rhs->tv_sec)
  return -1;
 if (lhs->tv_sec > rhs->tv_sec)
  return 1;
 return lhs->tv_usec - rhs->tv_usec;
}

extern unsigned long mktime( unsigned int year, unsigned int mon,
       unsigned int day, unsigned int hour,
       unsigned int min, unsigned int sec);

extern void set_normalized_timespec(struct timespec *ts, time_t sec, s64 nsec);






extern struct timespec timespec_add_safe( struct timespec lhs,
      struct timespec rhs);


static inline struct timespec timespec_add(struct timespec lhs,
      struct timespec rhs)
{
 struct timespec ts_delta;
 set_normalized_timespec(&ts_delta, lhs.tv_sec + rhs.tv_sec,
    lhs.tv_nsec + rhs.tv_nsec);
 return ts_delta;
}




static inline struct timespec timespec_sub(struct timespec lhs,
      struct timespec rhs)
{
 struct timespec ts_delta;
 set_normalized_timespec(&ts_delta, lhs.tv_sec - rhs.tv_sec,
    lhs.tv_nsec - rhs.tv_nsec);
 return ts_delta;
}
static inline bool timespec_valid( struct timespec *ts)
{

 if (ts->tv_sec < 0)
  return _false;

 if ((unsigned long)ts->tv_nsec >= 1000000000L)
  return _false;
 return _true;
}

static inline bool timespec_valid_strict( struct timespec *ts)
{
 if (!timespec_valid(ts))
  return _false;

 if ((unsigned long long)ts->tv_sec >= (((s64)~((u64)1 << 63)) / 1000000000L))
  return _false;
 return _true;
}

extern bool persistent_clock_exist;

static inline bool has_persistent_clock(void)
{
 return persistent_clock_exist;
}

extern void read_persistent_clock(struct timespec *ts);
extern void read_boot_clock(struct timespec *ts);
extern int persistent_clock_is_local;
extern int update_persistent_clock(struct timespec now);
void timekeeping_init(void);
extern int timekeeping_suspended;

unsigned long get_seconds(void);
struct timespec current_kernel_time(void);
struct timespec __current_kernel_time(void);
struct timespec get_monotonic_coarse(void);
void get_xtime_and_monotonic_and_sleep_offset(struct timespec *xtim,
    struct timespec *wtom, struct timespec *sleep);
void timekeeping_inject_sleeptime(struct timespec *delta);
extern void do_gettimeofday(struct timeval *tv);
extern int do_settimeofday( struct timespec *tv);
extern int do_sys_settimeofday( struct timespec *tv,
          struct timezone *tz);

extern long do_utimes(int dfd, char *filename, struct timespec *times, int flags);
struct itimerval;
extern int do_setitimer(int which, struct itimerval *value,
   struct itimerval *ovalue);
extern unsigned int alarm_setitimer(unsigned int seconds);
extern int do_getitimer(int which, struct itimerval *value);
extern int __getnstimeofday(struct timespec *tv);
extern void getnstimeofday(struct timespec *tv);
extern void getrawmonotonic(struct timespec *ts);
extern void getnstime_raw_and_real(struct timespec *ts_raw,
  struct timespec *ts_real);
extern void getboottime(struct timespec *ts);
extern void monotonic_to_bootbased(struct timespec *ts);
extern void get_monotonic_boottime(struct timespec *ts);

extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
extern int timekeeping_valid_for_hres(void);
extern u64 timekeeping_max_deferment(void);
extern int timekeeping_inject_offset(struct timespec *ts);
extern s32 timekeeping_get_tai_offset(void);
extern void timekeeping_set_tai_offset(s32 tai_offset);
extern void timekeeping_clocktai(struct timespec *ts);

struct tms;
extern void do_sys_times(struct tms *);





struct tm {
  template <typename, int = 0> struct __BYPASStm {};
  template <typename, int> friend struct __BYPASStm;




 int tm_sec;

 int tm_min;

 int tm_hour;

 int tm_mday;

 int tm_mon;

 long tm_year;

 int tm_wday;

 int tm_yday;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

void time_to_tm(time_t totalsecs, int offset, struct tm *result);
static inline s64 timespec_to_ns( struct timespec *ts)
{
 return ((s64) ts->tv_sec * 1000000000L) + ts->tv_nsec;
}
static inline s64 timeval_to_ns( struct timeval *tv)
{
 return ((s64) tv->tv_sec * 1000000000L) +
  tv->tv_usec * 1000L;
}







extern struct timespec ns_to_timespec( s64 nsec);







extern struct timeval ns_to_timeval( s64 nsec);
static inline __attribute__((always_inline)) void timespec_add_ns(struct timespec *a, u64 ns)
{
 a->tv_sec += __iter_div_u64_rem(a->tv_nsec + ns, 1000000000L, &ns);
 a->tv_nsec = ns;
}







struct timex {
  template <typename, int = 0> struct __BYPASStimex {};
  template <typename, int> friend struct __BYPASStimex;
 unsigned int modes;
 long offset;
 long freq;
 long maxerror;
 long esterror;
 int status;
 long constant;
 long precision;
 long tolerance;


 struct timeval time;
 long tick;

 long ppsfreq;
 long jitter;
 int shift;
 long stabil;
 long jitcnt;
 long calcnt;
 long errcnt;
 long stbcnt;

 int tai;

 int :32; int :32; int :32; int :32;
 int :32; int :32; int :32; int :32;
 int :32; int :32; int :32;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

















typedef unsigned long long cycles_t;

extern unsigned int cpu_khz;
extern unsigned int tsc_khz;

extern void disable_TSC(void);

static inline cycles_t get_cycles(void)
{
 unsigned long long ret = 0;





 (ret = paravirt_read_tsc());

 return ret;
}

static inline __attribute__((always_inline)) cycles_t vget_cycles(void)
{
 return (cycles_t)__native_read_tsc();
}

extern void tsc_init(void);
extern void mark_tsc_unstable(char *reason);
extern int unsynchronized_tsc(void);
extern int check_tsc_unstable(void);
extern int check_tsc_disabled(void);
extern unsigned long native_calibrate_tsc(void);

extern int tsc_clocksource_reliable;





extern void check_tsc_sync_source(int cpu);
extern void check_tsc_sync_target(void);

extern int notsc_setup(char *);
extern void tsc_save_sched_clock_state(void);
extern void tsc_restore_sched_clock_state(void);
extern unsigned long tick_usec;
extern unsigned long tick_nsec;
extern int do_adjtimex(struct timex *);
extern void hardpps( struct timespec *, struct timespec *);

int read_current_timer(unsigned long *timer_val);
void ntp_notify_cmos_timer(void);
extern int register_refined_jiffies(long clock_tick_rate);
extern u64 __attribute__((section(".data"))) jiffies_64;
extern unsigned long __attribute__((section(".data"))) jiffies;





template <typename TResult, typename TThat, typename TTarget> struct TJP_jiffies_297_0 {
  typedef TJP_jiffies_297_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int __get_jiffies_297(unsigned long int *source) {
  unsigned long int __result_buffer;
  typedef TJP_jiffies_297_0< unsigned long int , void *, unsigned long int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int &)__result_buffer;
}
static inline u64 get_jiffies_64(void)
{
 return (u64)__get_jiffies_297(&jiffies);
}
extern unsigned long preset_lpj;
extern unsigned int jiffies_to_msecs( unsigned long j);
extern unsigned int jiffies_to_usecs( unsigned long j);
extern unsigned long msecs_to_jiffies( unsigned int m);
extern unsigned long usecs_to_jiffies( unsigned int u);
extern unsigned long timespec_to_jiffies( struct timespec *value);
extern void jiffies_to_timespec( unsigned long jiffies,
    struct timespec *value);
extern unsigned long timeval_to_jiffies( struct timeval *value);
extern void jiffies_to_timeval( unsigned long jiffies,
          struct timeval *value);

extern clock_t jiffies_to_clock_t(unsigned long x);
static inline clock_t jiffies_delta_to_clock_t(long delta)
{
 return jiffies_to_clock_t(({ typeof(0L) _max1 = (0L); typeof(delta) _max2 = (delta); (void) (&_max1 == &_max2); _max1 > _max2 ? _max1 : _max2; }));
}

extern unsigned long clock_t_to_jiffies(unsigned long x);
extern u64 jiffies_64_to_clock_t(u64 x);
extern u64 nsec_to_clock_t(u64 x);
extern u64 nsecs_to_jiffies64(u64 n);
extern unsigned long nsecs_to_jiffies(u64 n);
union ktime {
 s64 tv64;
};

typedef union ktime ktime_t;
static inline ktime_t ktime_set( long secs, unsigned long nsecs)
{

 if (__builtin_expect(!!(secs >= (((s64)~((u64)1 << 63)) / 1000000000L)), 0))



                return ({ ktime_t var; var.tv64 = ((s64)~((u64)1 << 63)); var; });





        return ({ ktime_t var; var.tv64 = (s64)secs * 1000000000L + (s64)nsecs; var; });

}
static inline ktime_t timespec_to_ktime(struct timespec ts)
{
 return ktime_set(ts.tv_sec, ts.tv_nsec);
}


static inline ktime_t timeval_to_ktime(struct timeval tv)
{
 return ktime_set(tv.tv_sec, tv.tv_usec * 1000L);
}
static inline int ktime_equal( ktime_t cmp1, ktime_t cmp2)
{
 return cmp1.tv64 == cmp2.tv64;
}
static inline int ktime_compare( ktime_t cmp1, ktime_t cmp2)
{
 if (cmp1.tv64 < cmp2.tv64)
  return -1;
 if (cmp1.tv64 > cmp2.tv64)
  return 1;
 return 0;
}

static inline s64 ktime_to_us( ktime_t kt)
{
 struct timeval tv = ns_to_timeval((kt).tv64);
 return (s64) tv.tv_sec * 1000000L + tv.tv_usec;
}

static inline s64 ktime_to_ms( ktime_t kt)
{
 struct timeval tv = ns_to_timeval((kt).tv64);
 return (s64) tv.tv_sec * 1000L + tv.tv_usec / 1000L;
}

static inline s64 ktime_us_delta( ktime_t later, ktime_t earlier)
{
       return ktime_to_us(({ ({ ktime_t var; var.tv64 = (later).tv64 - (earlier).tv64; var; }); }));
}

static inline ktime_t ktime_add_us( ktime_t kt, u64 usec)
{
 return ({ ({ ktime_t var; var.tv64 = (kt).tv64 + (usec * 1000L); var; }); });
}

static inline ktime_t ktime_add_ms( ktime_t kt, u64 msec)
{
 return ({ ({ ktime_t var; var.tv64 = (kt).tv64 + (msec * 1000000L); var; }); });
}

static inline ktime_t ktime_sub_us( ktime_t kt, u64 usec)
{
 return ({ ({ ktime_t var; var.tv64 = (kt).tv64 - (usec * 1000L); var; }); });
}

extern ktime_t ktime_add_safe( ktime_t lhs, ktime_t rhs);
static inline bool ktime_to_timespec_cond( ktime_t kt,
             struct timespec *ts)
{
 if (kt.tv64) {
  *ts = ns_to_timespec((kt).tv64);
  return _true;
 } else {
  return _false;
 }
}
extern void ktime_get_ts(struct timespec *ts);




static inline ktime_t ns_to_ktime(u64 ns)
{



 static ktime_t ktime_zero = { 0 };


 return ({ ({ ktime_t var; var.tv64 = (ktime_zero).tv64 + (ns); var; }); });
}

static inline ktime_t ms_to_ktime(u64 ms)
{



 static ktime_t ktime_zero = { 0 };


 return ktime_add_ms(ktime_zero, ms);
}




struct tvec_base;

struct timer_list {
  template <typename, int = 0> struct __BYPASStimer_list {};
  template <typename, int> friend struct __BYPASStimer_list;




 struct list_head entry;
 unsigned long expires;
 struct tvec_base *base;

 void (*function)(unsigned long);
 unsigned long data;

 int slack;


 int start_pid;
 void *start_site;
 char start_comm[16];





  friend class ::Introspect;
  friend class ::MyIntrospect;
};

extern struct tvec_base boot_tvec_bases;
void init_timer_key(struct timer_list *timer, unsigned int flags,
      char *name, struct lock_class_key *key);







static inline void destroy_timer_on_stack(struct timer_list *timer) { }
static inline void init_timer_on_stack_key(struct timer_list *timer,
        unsigned int flags, char *name,
        struct lock_class_key *key)
{
 init_timer_key(timer, flags, name, key);
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9list_head4nextE_324_0 {
  typedef TJP__ZN9list_head4nextE_324_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head * __get__ZN9list_head4nextE_324(list_head * *source) {
  ::list_head *__result_buffer;
  typedef TJP__ZN9list_head4nextE_324_0< ::list_head *, ::list_head , ::list_head * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN10timer_list5entryE_325_0 {
  typedef TJP__ZN10timer_list5entryE_325_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline list_head __get__ZN10timer_list5entryE_325(list_head *source) {
  AC::ResultBuffer< ::list_head  > __result_buffer;
  typedef TJP__ZN10timer_list5entryE_325_0< ::list_head , ::timer_list , ::list_head  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::list_head &)__result_buffer;
}
static inline int timer_pending( struct timer_list * timer)
{
 return __get__ZN9list_head4nextE_324(&__get__ZN10timer_list5entryE_325(&timer->entry).next) != 0;
}

extern void add_timer_on(struct timer_list *timer, int cpu);
extern int del_timer(struct timer_list * timer);
extern int mod_timer(struct timer_list *timer, unsigned long expires);
extern int mod_timer_pending(struct timer_list *timer, unsigned long expires);
extern int mod_timer_pinned(struct timer_list *timer, unsigned long expires);

extern void set_timer_slack(struct timer_list *time, int slack_hz);
extern unsigned long get_next_timer_interrupt(unsigned long now);






extern int timer_stats_active;



extern void init_timer_stats(void);

extern void timer_stats_update_stats(void *timer, pid_t pid, void *startf,
         void *timerf, char *comm,
         unsigned int timer_flag);

extern void __timer_stats_timer_set_start_info(struct timer_list *timer,
            void *addr);

static inline void timer_stats_timer_set_start_info(struct timer_list *timer)
{
 if (__builtin_expect(!!(!timer_stats_active), 1))
  return;
 __timer_stats_timer_set_start_info(timer, __builtin_return_address(0));
}

static inline void timer_stats_timer_clear_start_info(struct timer_list *timer)
{
 timer->start_site = 0;
}
extern void add_timer(struct timer_list *timer);

extern int try_to_del_timer_sync(struct timer_list *timer);


  extern int del_timer_sync(struct timer_list *timer);






extern void init_timers(void);
extern void run_local_timers(void);






unsigned long __round_jiffies(unsigned long j, int cpu);
unsigned long __round_jiffies_relative(unsigned long j, int cpu);
unsigned long round_jiffies(unsigned long j);
unsigned long round_jiffies_relative(unsigned long j);

unsigned long __round_jiffies_up(unsigned long j, int cpu);
unsigned long __round_jiffies_up_relative(unsigned long j, int cpu);
unsigned long round_jiffies_up(unsigned long j);
unsigned long round_jiffies_up_relative(unsigned long j);







struct workqueue_struct;

struct work_struct;
typedef void (*work_func_t)(struct work_struct *work);
void delayed_work_timer_fn(unsigned long __data);







enum {
 WORK_STRUCT_PENDING_BIT = 0,
 WORK_STRUCT_DELAYED_BIT = 1,
 WORK_STRUCT_PWQ_BIT = 2,
 WORK_STRUCT_LINKED_BIT = 3,




 WORK_STRUCT_COLOR_SHIFT = 4,


 WORK_STRUCT_COLOR_BITS = 4,

 WORK_STRUCT_PENDING = 1 << WORK_STRUCT_PENDING_BIT,
 WORK_STRUCT_DELAYED = 1 << WORK_STRUCT_DELAYED_BIT,
 WORK_STRUCT_PWQ = 1 << WORK_STRUCT_PWQ_BIT,
 WORK_STRUCT_LINKED = 1 << WORK_STRUCT_LINKED_BIT,



 WORK_STRUCT_STATIC = 0,






 WORK_NR_COLORS = (1 << WORK_STRUCT_COLOR_BITS) - 1,
 WORK_NO_COLOR = WORK_NR_COLORS,


 WORK_CPU_UNBOUND = 256,
 WORK_CPU_END = 256 + 1,






 WORK_STRUCT_FLAG_BITS = WORK_STRUCT_COLOR_SHIFT +
      WORK_STRUCT_COLOR_BITS,


 WORK_OFFQ_FLAG_BASE = WORK_STRUCT_COLOR_SHIFT,

 WORK_OFFQ_CANCELING = (1 << WORK_OFFQ_FLAG_BASE),






 WORK_OFFQ_FLAG_BITS = 1,
 WORK_OFFQ_POOL_SHIFT = WORK_OFFQ_FLAG_BASE + WORK_OFFQ_FLAG_BITS,
 WORK_OFFQ_LEFT = 64 - WORK_OFFQ_POOL_SHIFT,
 WORK_OFFQ_POOL_BITS = WORK_OFFQ_LEFT <= 31 ? WORK_OFFQ_LEFT : 31,
 WORK_OFFQ_POOL_NONE = (1LU << WORK_OFFQ_POOL_BITS) - 1,


 WORK_STRUCT_FLAG_MASK = (1UL << WORK_STRUCT_FLAG_BITS) - 1,
 WORK_STRUCT_WQ_DATA_MASK = ~WORK_STRUCT_FLAG_MASK,
 WORK_STRUCT_NO_POOL = (unsigned long)WORK_OFFQ_POOL_NONE << WORK_OFFQ_POOL_SHIFT,


 WORK_BUSY_PENDING = 1 << 0,
 WORK_BUSY_RUNNING = 1 << 1,


 WORKER_DESC_LEN = 24,
};

struct work_struct {
  template <typename, int = 0> struct __BYPASSwork_struct {};
  template <typename, int> friend struct __BYPASSwork_struct;
 atomic_long_t data;
 struct list_head entry;
 work_func_t func;




  friend class ::Introspect;
  friend class ::MyIntrospect;
};





struct delayed_work {
  template <typename, int = 0> struct __BYPASSdelayed_work {};
  template <typename, int> friend struct __BYPASSdelayed_work;
 struct work_struct work;
 struct timer_list timer;


 struct workqueue_struct *wq;
 int cpu;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct workqueue_attrs {
  template <typename, int = 0> struct __BYPASSworkqueue_attrs {};
  template <typename, int> friend struct __BYPASSworkqueue_attrs;
 int nice;
 cpumask_var_t cpumask;
 bool no_numa;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

static inline struct delayed_work *to_delayed_work(struct work_struct *work)
{
 return ({ typeof( ((struct delayed_work *)0)->work ) *__mptr = (work); (struct delayed_work *)( (char *)__mptr - ((size_t) &((struct delayed_work *)0)->work) );});
}

struct execute_work {
  template <typename, int = 0> struct __BYPASSexecute_work {};
  template <typename, int> friend struct __BYPASSexecute_work;
 struct work_struct work;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
static inline void __init_work(struct work_struct *work, int onstack) { }
static inline void destroy_work_on_stack(struct work_struct *work) { }
static inline unsigned int work_static(struct work_struct *work) { return 0; }
enum {




 WQ_NON_REENTRANT = 1 << 0,

 WQ_UNBOUND = 1 << 1,
 WQ_FREEZABLE = 1 << 2,
 WQ_MEM_RECLAIM = 1 << 3,
 WQ_HIGHPRI = 1 << 4,
 WQ_CPU_INTENSIVE = 1 << 5,
 WQ_SYSFS = 1 << 6,
 WQ_POWER_EFFICIENT = 1 << 7,

 __WQ_DRAINING = 1 << 16,
 __WQ_ORDERED = 1 << 17,

 WQ_MAX_ACTIVE = 512,
 WQ_MAX_UNBOUND_PER_CPU = 4,
 WQ_DFL_ACTIVE = WQ_MAX_ACTIVE / 2,
};
extern struct workqueue_struct *system_wq;
extern struct workqueue_struct *system_long_wq;
extern struct workqueue_struct *system_unbound_wq;
extern struct workqueue_struct *system_freezable_wq;
extern struct workqueue_struct *system_power_efficient_wq;
extern struct workqueue_struct *system_freezable_power_efficient_wq;

static inline struct workqueue_struct * __system_nrt_wq(void)
{
 return system_wq;
}

static inline struct workqueue_struct * __system_nrt_freezable_wq(void)
{
 return system_freezable_wq;
}





extern struct workqueue_struct *
__alloc_workqueue_key( char *fmt, unsigned int flags, int max_active,
 struct lock_class_key *key, char *lock_name, ...) __attribute__((format(printf, 1, 6)));
extern void destroy_workqueue(struct workqueue_struct *wq);

struct workqueue_attrs *alloc_workqueue_attrs(gfp_t gfp_mask);
void free_workqueue_attrs(struct workqueue_attrs *attrs);
int apply_workqueue_attrs(struct workqueue_struct *wq,
     struct workqueue_attrs *attrs);

extern bool queue_work_on(int cpu, struct workqueue_struct *wq,
   struct work_struct *work);
extern bool queue_delayed_work_on(int cpu, struct workqueue_struct *wq,
   struct delayed_work *work, unsigned long delay);
extern bool mod_delayed_work_on(int cpu, struct workqueue_struct *wq,
   struct delayed_work *dwork, unsigned long delay);

extern void flush_workqueue(struct workqueue_struct *wq);
extern void drain_workqueue(struct workqueue_struct *wq);
extern void flush_scheduled_work(void);

extern int schedule_on_each_cpu(work_func_t func);

int execute_in_process_context(work_func_t fn, struct execute_work *);

extern bool flush_work(struct work_struct *work);
extern bool cancel_work_sync(struct work_struct *work);

extern bool flush_delayed_work(struct delayed_work *dwork);
extern bool cancel_delayed_work(struct delayed_work *dwork);
extern bool cancel_delayed_work_sync(struct delayed_work *dwork);

extern void workqueue_set_max_active(struct workqueue_struct *wq,
         int max_active);
extern bool current_is_workqueue_rescuer(void);
extern bool workqueue_congested(int cpu, struct workqueue_struct *wq);
extern unsigned int work_busy(struct work_struct *work);
extern __attribute__((format(printf, 1, 2))) void set_worker_desc( char *fmt, ...);
extern void print_worker_info( char *log_lvl, struct task_struct *task);
static inline bool queue_work(struct workqueue_struct *wq,
         struct work_struct *work)
{
 return queue_work_on(WORK_CPU_UNBOUND, wq, work);
}
static inline bool queue_delayed_work(struct workqueue_struct *wq,
          struct delayed_work *dwork,
          unsigned long delay)
{
 return queue_delayed_work_on(WORK_CPU_UNBOUND, wq, dwork, delay);
}
static inline bool mod_delayed_work(struct workqueue_struct *wq,
        struct delayed_work *dwork,
        unsigned long delay)
{
 return mod_delayed_work_on(WORK_CPU_UNBOUND, wq, dwork, delay);
}
static inline bool schedule_work_on(int cpu, struct work_struct *work)
{
 return queue_work_on(cpu, system_wq, work);
}
static inline bool schedule_work(struct work_struct *work)
{
 return queue_work(system_wq, work);
}
static inline bool schedule_delayed_work_on(int cpu, struct delayed_work *dwork,
         unsigned long delay)
{
 return queue_delayed_work_on(cpu, system_wq, dwork, delay);
}
static inline bool schedule_delayed_work(struct delayed_work *dwork,
      unsigned long delay)
{
 return queue_delayed_work(system_wq, dwork, delay);
}




static inline bool keventd_up(void)
{
 return system_wq != 0;
}






static inline bool __cancel_delayed_work(struct delayed_work *work)
{
 bool ret;

 ret = del_timer(&work->timer);
 if (ret)
  clear_bit(WORK_STRUCT_PENDING_BIT, ((unsigned long *)(&(&work->work)->data)));
 return ret;
}


static inline bool flush_work_sync(struct work_struct *work)
{
 return flush_work(work);
}


static inline bool flush_delayed_work_sync(struct delayed_work *dwork)
{
 return flush_delayed_work(dwork);
}







long work_on_cpu(int cpu, long (*fn)(void *), void *arg);



extern void freeze_workqueues_begin(void);
extern bool freeze_workqueues_busy(void);
extern void thaw_workqueues(void);



int workqueue_sysfs_register(struct workqueue_struct *wq);

struct srcu_struct_array {
  template <typename, int = 0> struct __BYPASSsrcu_struct_array {};
  template <typename, int> friend struct __BYPASSsrcu_struct_array;
 unsigned long c[2];
 unsigned long seq[2];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct rcu_batch {
  template <typename, int = 0> struct __BYPASSrcu_batch {};
  template <typename, int> friend struct __BYPASSrcu_batch;
 struct callback_head *head, **tail;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};



struct srcu_struct {
  template <typename, int = 0> struct __BYPASSsrcu_struct {};
  template <typename, int> friend struct __BYPASSsrcu_struct;
 unsigned completed;
 struct srcu_struct_array *per_cpu_ref;
 spinlock_t queue_lock;
 bool running;

 struct rcu_batch batch_queue;

 struct rcu_batch batch_check0;

 struct rcu_batch batch_check1;
 struct rcu_batch batch_done;
 struct delayed_work work;




  friend class ::Introspect;
  friend class ::MyIntrospect;
};
int init_srcu_struct(struct srcu_struct *sp);




void process_srcu(struct work_struct *work);
void call_srcu(struct srcu_struct *sp, struct callback_head *head,
  void (*func)(struct callback_head *head));

void cleanup_srcu_struct(struct srcu_struct *sp);
int __srcu_read_lock(struct srcu_struct *sp) ;
void __srcu_read_unlock(struct srcu_struct *sp, int idx) ;
void synchronize_srcu(struct srcu_struct *sp);
void synchronize_srcu_expedited(struct srcu_struct *sp);
long srcu_batches_completed(struct srcu_struct *sp);
void srcu_barrier(struct srcu_struct *sp);
static inline int srcu_read_lock_held(struct srcu_struct *sp)
{
 return 1;
}
static inline int srcu_read_lock(struct srcu_struct *sp)
{
 int retval = __srcu_read_lock(sp);

 ;
 return retval;
}
static inline void srcu_read_unlock(struct srcu_struct *sp, int idx)

{
 ;
 __srcu_read_unlock(sp, idx);
}
static inline void smp_mb__after_srcu_read_unlock(void)
{

}
typedef int (*notifier_fn_t)(struct notifier_block *nb,
   unsigned long action, void *data);

struct notifier_block {
  template <typename, int = 0> struct __BYPASSnotifier_block {};
  template <typename, int> friend struct __BYPASSnotifier_block;
 notifier_fn_t notifier_call;
 struct notifier_block *next;
 int priority;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct atomic_notifier_head {
  template <typename, int = 0> struct __BYPASSatomic_notifier_head {};
  template <typename, int> friend struct __BYPASSatomic_notifier_head;
 spinlock_t lock;
 struct notifier_block *head;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct blocking_notifier_head {
  template <typename, int = 0> struct __BYPASSblocking_notifier_head {};
  template <typename, int> friend struct __BYPASSblocking_notifier_head;
 struct rw_semaphore rwsem;
 struct notifier_block *head;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct raw_notifier_head {
  template <typename, int = 0> struct __BYPASSraw_notifier_head {};
  template <typename, int> friend struct __BYPASSraw_notifier_head;
 struct notifier_block *head;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct srcu_notifier_head {
  template <typename, int = 0> struct __BYPASSsrcu_notifier_head {};
  template <typename, int> friend struct __BYPASSsrcu_notifier_head;
 struct mutex mutex;
 struct srcu_struct srcu;
 struct notifier_block *head;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
extern void srcu_init_notifier_head(struct srcu_notifier_head *nh);
extern int atomic_notifier_chain_register(struct atomic_notifier_head *nh,
  struct notifier_block *nb);
extern int blocking_notifier_chain_register(struct blocking_notifier_head *nh,
  struct notifier_block *nb);
extern int raw_notifier_chain_register(struct raw_notifier_head *nh,
  struct notifier_block *nb);
extern int srcu_notifier_chain_register(struct srcu_notifier_head *nh,
  struct notifier_block *nb);

extern int blocking_notifier_chain_cond_register(
  struct blocking_notifier_head *nh,
  struct notifier_block *nb);

extern int atomic_notifier_chain_unregister(struct atomic_notifier_head *nh,
  struct notifier_block *nb);
extern int blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,
  struct notifier_block *nb);
extern int raw_notifier_chain_unregister(struct raw_notifier_head *nh,
  struct notifier_block *nb);
extern int srcu_notifier_chain_unregister(struct srcu_notifier_head *nh,
  struct notifier_block *nb);

extern int atomic_notifier_call_chain(struct atomic_notifier_head *nh,
  unsigned long val, void *v);
extern int __atomic_notifier_call_chain(struct atomic_notifier_head *nh,
 unsigned long val, void *v, int nr_to_call, int *nr_calls);
extern int blocking_notifier_call_chain(struct blocking_notifier_head *nh,
  unsigned long val, void *v);
extern int __blocking_notifier_call_chain(struct blocking_notifier_head *nh,
 unsigned long val, void *v, int nr_to_call, int *nr_calls);
extern int raw_notifier_call_chain(struct raw_notifier_head *nh,
  unsigned long val, void *v);
extern int __raw_notifier_call_chain(struct raw_notifier_head *nh,
 unsigned long val, void *v, int nr_to_call, int *nr_calls);
extern int srcu_notifier_call_chain(struct srcu_notifier_head *nh,
  unsigned long val, void *v);
extern int __srcu_notifier_call_chain(struct srcu_notifier_head *nh,
 unsigned long val, void *v, int nr_to_call, int *nr_calls);
static inline int notifier_from_errno(int err)
{
 if (err)
  return 0x8000 | (0x0001 - err);

 return 0x0001;
}


static inline int notifier_to_errno(int ret)
{
 ret &= ~0x8000;
 return ret > 0x0001 ? 0x0001 - ret : 0;
}
extern struct blocking_notifier_head reboot_notifier_list;


struct page;
struct zone;
struct pglist_data;
struct mem_section;
struct memory_block;







enum {
 MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE = 12,
 SECTION_INFO = MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE,
 MIX_SECTION_INFO,
 NODE_INFO,
 MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE = NODE_INFO,
};


enum {
 ONLINE_KEEP,
 ONLINE_KERNEL,
 ONLINE_MOVABLE,
};




static inline
void pgdat_resize_lock(struct pglist_data *pgdat, unsigned long *flags)
{
 ;
}
static inline
void pgdat_resize_unlock(struct pglist_data *pgdat, unsigned long *flags)
{
 ;
}
static inline
void pgdat_resize_init(struct pglist_data *pgdat)
{
 ;
}







static inline unsigned zone_span_seqbegin(struct zone *zone)
{
 return 0;
}
static inline int zone_span_seqretry(struct zone *zone, unsigned iv)
{
 return 0;
}
static inline void zone_span_writelock(struct zone *zone)
{
 ;
}
static inline void zone_span_writeunlock(struct zone *zone)
{
 ;
}
static inline void zone_seqlock_init(struct zone *zone)
{
 ;
}
extern int zone_grow_free_lists(struct zone *zone, unsigned long new_nr_pages);
extern int zone_grow_waitqueues(struct zone *zone, unsigned long nr_pages);
extern int add_one_highpage(struct page *page, int pfn, int bad_ppro);

extern int online_pages(unsigned long, unsigned long, int);
extern void __offline_isolated_pages(unsigned long, unsigned long);

typedef void (*online_page_callback_t)(struct page *page);

extern int set_online_page_callback(online_page_callback_t callback);
extern int restore_online_page_callback(online_page_callback_t callback);

extern void __online_page_set_limits(struct page *page);
extern void __online_page_increment_counters(struct page *page);
extern void __online_page_free(struct page *page);

extern int try_online_node(int nid);


extern bool is_pageblock_removable_nolock(struct page *page);
extern int arch_remove_memory(u64 start, u64 size);
extern int __remove_pages(struct zone *zone, unsigned long start_pfn,
 unsigned long nr_pages);



extern int __add_pages(int nid, struct zone *zone, unsigned long start_pfn,
 unsigned long nr_pages);


extern int memory_add_physaddr_to_nid(u64 start);
extern pg_data_t *node_data[];
static inline void arch_refresh_nodedata(int nid, pg_data_t *pgdat)
{
 node_data[nid] = pgdat;
}
extern void register_page_bootmem_info_node(struct pglist_data *pgdat);





extern void put_page_bootmem(struct page *page);
extern void get_page_bootmem(unsigned long ingo, struct page *page,
        unsigned long type);







void lock_memory_hotplug(void);
void unlock_memory_hotplug(void);
extern int is_mem_section_removable(unsigned long pfn, unsigned long nr_pages);
extern void try_offline_node(int nid);
extern int offline_pages(unsigned long start_pfn, unsigned long nr_pages);
extern void remove_memory(int nid, u64 start, u64 size);
extern int walk_memory_range(unsigned long start_pfn, unsigned long end_pfn,
  void *arg, int (*func)(struct memory_block *, void *));
extern int add_memory(int nid, u64 start, u64 size);
extern int arch_add_memory(int nid, u64 start, u64 size);
extern int offline_pages(unsigned long start_pfn, unsigned long nr_pages);
extern bool is_memblock_offlined(struct memory_block *mem);
extern void remove_memory(int nid, u64 start, u64 size);
extern int sparse_add_one_section(struct zone *zone, unsigned long start_pfn);
extern void sparse_remove_one_section(struct zone *zone, struct mem_section *ms);
extern struct page *sparse_decode_mem_map(unsigned long coded_mem_map,
       unsigned long pnum);

extern struct mutex zonelists_mutex;
void build_all_zonelists(pg_data_t *pgdat, struct zone *zone);
void wakeup_kswapd(struct zone *zone, int order, enum zone_type classzone_idx);
bool zone_watermark_ok(struct zone *z, int order, unsigned long mark,
  int classzone_idx, int alloc_flags);
bool zone_watermark_ok_safe(struct zone *z, int order, unsigned long mark,
  int classzone_idx, int alloc_flags);
enum memmap_context {
 MEMMAP_EARLY,
 MEMMAP_HOTPLUG,
};
extern int init_currently_empty_zone(struct zone *zone, unsigned long start_pfn,
         unsigned long size,
         enum memmap_context context);

extern void lruvec_init(struct lruvec *lruvec);

static inline struct zone *lruvec_zone(struct lruvec *lruvec)
{

 return lruvec->zone;



}


void memory_present(int nid, unsigned long start, unsigned long end);







static inline int local_memory_node(int node_id) { return node_id; };
static inline int populated_zone(struct zone *zone)
{
 return (!!zone->present_pages);
}

extern int movable_zone;

static inline int zone_movable_is_highmem(void)
{



 return 0;

}

static inline int is_highmem_idx(enum zone_type idx)
{




 return 0;

}







static inline int is_highmem(struct zone *zone)
{






 return 0;

}


struct ctl_table;
int min_free_kbytes_sysctl_handler(struct ctl_table *, int,
     void *, size_t *, loff_t *);
extern int sysctl_lowmem_reserve_ratio[4 -1];
int lowmem_reserve_ratio_sysctl_handler(struct ctl_table *, int,
     void *, size_t *, loff_t *);
int percpu_pagelist_fraction_sysctl_handler(struct ctl_table *, int,
     void *, size_t *, loff_t *);
int sysctl_min_unmapped_ratio_sysctl_handler(struct ctl_table *, int,
   void *, size_t *, loff_t *);
int sysctl_min_slab_ratio_sysctl_handler(struct ctl_table *, int,
   void *, size_t *, loff_t *);

extern int numa_zonelist_order_handler(struct ctl_table *, int,
   void *, size_t *, loff_t *);
extern char numa_zonelist_order[];








struct mpf_intel {
  template <typename, int = 0> struct __BYPASSmpf_intel {};
  template <typename, int> friend struct __BYPASSmpf_intel;
 char signature[4];
 unsigned int physptr;
 unsigned char length;
 unsigned char specification;
 unsigned char checksum;
 unsigned char feature1;
 unsigned char feature2;
 unsigned char feature3;
 unsigned char feature4;
 unsigned char feature5;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};



struct mpc_table {
  template <typename, int = 0> struct __BYPASSmpc_table {};
  template <typename, int> friend struct __BYPASSmpc_table;
 char signature[4];
 unsigned short length;
 char spec;
 char checksum;
 char oem[8];
 char productid[12];
 unsigned int oemptr;
 unsigned short oemsize;
 unsigned short oemcount;
 unsigned int lapic;
 unsigned int reserved;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct mpc_cpu {
  template <typename, int = 0> struct __BYPASSmpc_cpu {};
  template <typename, int> friend struct __BYPASSmpc_cpu;
 unsigned char type;
 unsigned char apicid;
 unsigned char apicver;
 unsigned char cpuflag;
 unsigned int cpufeature;
 unsigned int featureflag;
 unsigned int reserved[2];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct mpc_bus {
  template <typename, int = 0> struct __BYPASSmpc_bus {};
  template <typename, int> friend struct __BYPASSmpc_bus;
 unsigned char type;
 unsigned char busid;
 unsigned char bustype[6];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct mpc_ioapic {
  template <typename, int = 0> struct __BYPASSmpc_ioapic {};
  template <typename, int> friend struct __BYPASSmpc_ioapic;
 unsigned char type;
 unsigned char apicid;
 unsigned char apicver;
 unsigned char flags;
 unsigned int apicaddr;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct mpc_intsrc {
  template <typename, int = 0> struct __BYPASSmpc_intsrc {};
  template <typename, int> friend struct __BYPASSmpc_intsrc;
 unsigned char type;
 unsigned char irqtype;
 unsigned short irqflag;
 unsigned char srcbus;
 unsigned char srcbusirq;
 unsigned char dstapic;
 unsigned char dstirq;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

enum mp_irq_source_types {
 mp_INT = 0,
 mp_NMI = 1,
 mp_SMI = 2,
 mp_ExtINT = 3
};







struct mpc_lintsrc {
  template <typename, int = 0> struct __BYPASSmpc_lintsrc {};
  template <typename, int> friend struct __BYPASSmpc_lintsrc;
 unsigned char type;
 unsigned char irqtype;
 unsigned short irqflag;
 unsigned char srcbusid;
 unsigned char srcbusirq;
 unsigned char destapic;
 unsigned char destapiclint;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};



struct mpc_oemtable {
  template <typename, int = 0> struct __BYPASSmpc_oemtable {};
  template <typename, int> friend struct __BYPASSmpc_oemtable;
 char signature[4];
 unsigned short length;
 char rev;
 char checksum;
 char mpc[8];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
enum mp_bustype {
 MP_BUS_ISA = 1,
 MP_BUS_EISA,
 MP_BUS_PCI,
};







struct screen_info {
  template <typename, int = 0> struct __BYPASSscreen_info {};
  template <typename, int> friend struct __BYPASSscreen_info;
 __u8 orig_x;
 __u8 orig_y;
 __u16 ext_mem_k;
 __u16 orig_video_page;
 __u8 orig_video_mode;
 __u8 orig_video_cols;
 __u8 flags;
 __u8 unused2;
 __u16 orig_video_ega_bx;
 __u16 unused3;
 __u8 orig_video_lines;
 __u8 orig_video_isVGA;
 __u16 orig_video_points;


 __u16 lfb_width;
 __u16 lfb_height;
 __u16 lfb_depth;
 __u32 lfb_base;
 __u32 lfb_size;
 __u16 cl_magic, cl_offset;
 __u16 lfb_linelength;
 __u8 red_size;
 __u8 red_pos;
 __u8 green_size;
 __u8 green_pos;
 __u8 blue_size;
 __u8 blue_pos;
 __u8 rsvd_size;
 __u8 rsvd_pos;
 __u16 vesapm_seg;
 __u16 vesapm_off;
 __u16 pages;
 __u16 vesa_attributes;
 __u32 capabilities;
 __u8 _reserved[6];

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__((packed));

extern struct screen_info screen_info;
typedef unsigned short apm_event_t;
typedef unsigned short apm_eventinfo_t;

struct apm_bios_info {
  template <typename, int = 0> struct __BYPASSapm_bios_info {};
  template <typename, int> friend struct __BYPASSapm_bios_info;
 __u16 version;
 __u16 cseg;
 __u32 offset;
 __u16 cseg_16;
 __u16 dseg;
 __u16 flags;
 __u16 cseg_len;
 __u16 cseg_16_len;
 __u16 dseg_len;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct apm_info {
  template <typename, int = 0> struct __BYPASSapm_info {};
  template <typename, int> friend struct __BYPASSapm_info;
 struct apm_bios_info bios;
 unsigned short connection_version;
 int get_power_status_broken;
 int get_power_status_swabinminutes;
 int allow_ints;
 int forbid_idle;
 int realmode_power_off;
 int disabled;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
extern struct apm_info apm_info;
struct edd_device_params {
  template <typename, int = 0> struct __BYPASSedd_device_params {};
  template <typename, int> friend struct __BYPASSedd_device_params;
 __u16 length;
 __u16 info_flags;
 __u32 num_default_cylinders;
 __u32 num_default_heads;
 __u32 sectors_per_track;
 __u64 number_of_sectors;
 __u16 bytes_per_sector;
 __u32 dpte_ptr;
 __u16 key;
 __u8 device_path_info_length;
 __u8 reserved2;
 __u16 reserved3;
 __u8 host_bus_type[4];
 __u8 interface_type[8];
 union {
  struct {
   __u16 base_address;
   __u16 reserved1;
   __u32 reserved2;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed)) isa;
  struct {
   __u8 bus;
   __u8 slot;
   __u8 function;
   __u8 channel;
   __u32 reserved;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed)) pci;

  struct {
   __u64 reserved;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed)) ibnd;
  struct {
   __u64 reserved;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed)) xprs;
  struct {
   __u64 reserved;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed)) htpt;
  struct {
   __u64 reserved;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed)) unknown;
 } interface_path;
 union {
  struct {
   __u8 device;
   __u8 reserved1;
   __u16 reserved2;
   __u32 reserved3;
   __u64 reserved4;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed)) ata;
  struct {
   __u8 device;
   __u8 lun;
   __u8 reserved1;
   __u8 reserved2;
   __u32 reserved3;
   __u64 reserved4;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed)) atapi;
  struct {
   __u16 id;
   __u64 lun;
   __u16 reserved1;
   __u32 reserved2;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed)) scsi;
  struct {
   __u64 serial_number;
   __u64 reserved;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed)) usb;
  struct {
   __u64 eui;
   __u64 reserved;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed)) i1394;
  struct {
   __u64 wwid;
   __u64 lun;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed)) fibre;
  struct {
   __u64 identity_tag;
   __u64 reserved;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed)) i2o;
  struct {
   __u32 array_number;
   __u32 reserved1;
   __u64 reserved2;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed)) raid;
  struct {
   __u8 device;
   __u8 reserved1;
   __u16 reserved2;
   __u32 reserved3;
   __u64 reserved4;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed)) sata;
  struct {
   __u64 reserved1;
   __u64 reserved2;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed)) unknown;
 } device_path;
 __u8 reserved4;
 __u8 checksum;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed));

struct edd_info {
  template <typename, int = 0> struct __BYPASSedd_info {};
  template <typename, int> friend struct __BYPASSedd_info;
 __u8 device;
 __u8 version;
 __u16 interface_support;
 __u16 legacy_max_cylinder;
 __u8 legacy_max_head;
 __u8 legacy_sectors_per_track;
 struct edd_device_params params;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed));

struct edd {
  template <typename, int = 0> struct __BYPASSedd {};
  template <typename, int> friend struct __BYPASSedd;
 unsigned int mbr_signature[16];
 struct edd_info edd_info[6];
 unsigned char mbr_signature_nr;
 unsigned char edd_info_nr;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};


extern struct edd edd;
struct e820entry {
  template <typename, int = 0> struct __BYPASSe820entry {};
  template <typename, int> friend struct __BYPASSe820entry;
 __u64 addr;
 __u64 size;
 __u32 type;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__((packed));

struct e820map {
  template <typename, int = 0> struct __BYPASSe820map {};
  template <typename, int> friend struct __BYPASSe820map;
 __u32 nr_map;
 struct e820entry map[(128 + 3 * (1 << 6))];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};


extern struct e820map e820;
extern struct e820map e820_saved;

extern unsigned long pci_mem_start;
extern int e820_any_mapped(u64 start, u64 end, unsigned type);
extern int e820_all_mapped(u64 start, u64 end, unsigned type);
extern void e820_add_region(u64 start, u64 size, int type);
extern void e820_print_map(char *who);
extern int
sanitize_e820_map(struct e820entry *biosmap, int max_nr_map, u32 *pnr_map);
extern u64 e820_update_range(u64 start, u64 size, unsigned old_type,
          unsigned new_type);
extern u64 e820_remove_range(u64 start, u64 size, unsigned old_type,
        int checktype);
extern void update_e820(void);
extern void e820_setup_gap(void);
extern int e820_search_gap(unsigned long *gapstart, unsigned long *gapsize,
   unsigned long start_addr, unsigned long long end_addr);
struct setup_data;
extern void parse_e820_ext(u64 phys_addr, u32 data_len);



extern void e820_mark_nosave_regions(unsigned long limit_pfn);







extern void early_memtest(unsigned long start, unsigned long end);






extern unsigned long e820_end_of_ram_pfn(void);
extern unsigned long e820_end_of_low_ram_pfn(void);
extern u64 early_reserve_e820(u64 sizet, u64 align);

void memblock_x86_fill(void);
void memblock_find_dma_reserve(void);

extern void finish_e820_parsing(void);
extern void e820_reserve_resources(void);
extern void e820_reserve_resources_late(void);
extern void setup_memory_map(void);
extern char *default_machine_specific_memory_setup(void);





static inline bool is_ISA_range(u64 s, u64 e)
{
 return s >= 0xa0000 && e <= 0x100000;
}


struct resource {
  template <typename, int = 0> struct __BYPASSresource {};
  template <typename, int> friend struct __BYPASSresource;
 resource_size_t start;
 resource_size_t end;
 char *name;
 unsigned long flags;
 struct resource *parent, *sibling, *child;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
extern struct resource ioport_resource;
extern struct resource iomem_resource;

extern struct resource *request_resource_conflict(struct resource *root, struct resource *_new);
extern int request_resource(struct resource *root, struct resource *_new);
extern int release_resource(struct resource *_new);
void release_child_resources(struct resource *_new);
extern void reserve_region_with_split(struct resource *root,
        resource_size_t start, resource_size_t end,
        char *name);
extern struct resource *insert_resource_conflict(struct resource *parent, struct resource *_new);
extern int insert_resource(struct resource *parent, struct resource *_new);
extern void insert_resource_expand_to_fit(struct resource *root, struct resource *_new);
extern void arch_remove_reservations(struct resource *avail);
extern int allocate_resource(struct resource *root, struct resource *_new,
        resource_size_t size, resource_size_t min,
        resource_size_t max, resource_size_t align,
        resource_size_t (*alignf)(void *,
             struct resource *,
             resource_size_t,
             resource_size_t),
        void *alignf_data);
struct resource *lookup_resource(struct resource *root, resource_size_t start);
int adjust_resource(struct resource *res, resource_size_t start,
      resource_size_t size);
resource_size_t resource_alignment(struct resource *res);
static inline resource_size_t resource_size( struct resource *res)
{
 return res->end - res->start + 1;
}
static inline unsigned long resource_type( struct resource *res)
{
 return res->flags & 0x00001f00;
}
extern struct resource * __request_region(struct resource *,
     resource_size_t start,
     resource_size_t n,
     char *name, int flags);






extern int __check_region(struct resource *, resource_size_t, resource_size_t);
extern void __release_region(struct resource *, resource_size_t,
    resource_size_t);

extern int release_mem_region_adjustable(struct resource *, resource_size_t,
    resource_size_t);


static inline int check_region(resource_size_t s,
      resource_size_t n)
{
 return __check_region(&ioport_resource, s, n);
}


struct device;





extern struct resource * __devm_request_region(struct device *dev,
    struct resource *parent, resource_size_t start,
    resource_size_t n, char *name);






extern void __devm_release_region(struct device *dev, struct resource *parent,
      resource_size_t start, resource_size_t n);
extern int iomem_map_sanity_check(resource_size_t addr, unsigned long size);
extern int iomem_is_exclusive(u64 addr);

extern int
walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,
  void *arg, int (*func)(unsigned long, unsigned long, void *));


static inline bool resource_overlaps(struct resource *r1, struct resource *r2)
{
       return (r1->start <= r2->end && r1->end >= r2->start);
}
struct ist_info {
  template <typename, int = 0> struct __BYPASSist_info {};
  template <typename, int> friend struct __BYPASSist_info;
 __u32 signature;
 __u32 command;
 __u32 event;
 __u32 perf_level;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};


extern struct ist_info ist_info;






struct edid_info {
  template <typename, int = 0> struct __BYPASSedid_info {};
  template <typename, int> friend struct __BYPASSedid_info;
 unsigned char dummy[128];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};


extern struct edid_info edid_info;


struct setup_data {
  template <typename, int = 0> struct __BYPASSsetup_data {};
  template <typename, int> friend struct __BYPASSsetup_data;
 __u64 next;
 __u32 type;
 __u32 len;
 __u8 data[0];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct setup_header {
  template <typename, int = 0> struct __BYPASSsetup_header {};
  template <typename, int> friend struct __BYPASSsetup_header;
 __u8 setup_sects;
 __u16 root_flags;
 __u32 syssize;
 __u16 ram_size;
 __u16 vid_mode;
 __u16 root_dev;
 __u16 boot_flag;
 __u16 jump;
 __u32 header;
 __u16 version;
 __u32 realmode_swtch;
 __u16 start_sys;
 __u16 kernel_version;
 __u8 type_of_loader;
 __u8 loadflags;
 __u16 setup_move_size;
 __u32 code32_start;
 __u32 ramdisk_image;
 __u32 ramdisk_size;
 __u32 bootsect_kludge;
 __u16 heap_end_ptr;
 __u8 ext_loader_ver;
 __u8 ext_loader_type;
 __u32 cmd_line_ptr;
 __u32 initrd_addr_max;
 __u32 kernel_alignment;
 __u8 relocatable_kernel;
 __u8 min_alignment;
 __u16 xloadflags;
 __u32 cmdline_size;
 __u32 hardware_subarch;
 __u64 hardware_subarch_data;
 __u32 payload_offset;
 __u32 payload_length;
 __u64 setup_data;
 __u64 pref_address;
 __u32 init_size;
 __u32 handover_offset;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__((packed));

struct sys_desc_table {
  template <typename, int = 0> struct __BYPASSsys_desc_table {};
  template <typename, int> friend struct __BYPASSsys_desc_table;
 __u16 length;
 __u8 table[14];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};


struct olpc_ofw_header {
  template <typename, int = 0> struct __BYPASSolpc_ofw_header {};
  template <typename, int> friend struct __BYPASSolpc_ofw_header;
 __u32 ofw_magic;
 __u32 ofw_version;
 __u32 cif_handler;
 __u32 irq_desc_table;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__((packed));

struct efi_info {
  template <typename, int = 0> struct __BYPASSefi_info {};
  template <typename, int> friend struct __BYPASSefi_info;
 __u32 efi_loader_signature;
 __u32 efi_systab;
 __u32 efi_memdesc_size;
 __u32 efi_memdesc_version;
 __u32 efi_memmap;
 __u32 efi_memmap_size;
 __u32 efi_systab_hi;
 __u32 efi_memmap_hi;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};


struct boot_params {
  template <typename, int = 0> struct __BYPASSboot_params {};
  template <typename, int> friend struct __BYPASSboot_params;
 struct screen_info screen_info;
 struct apm_bios_info apm_bios_info;
 __u8 _pad2[4];
 __u64 tboot_addr;
 struct ist_info ist_info;
 __u8 _pad3[16];
 __u8 hd0_info[16];
 __u8 hd1_info[16];
 struct sys_desc_table sys_desc_table;
 struct olpc_ofw_header olpc_ofw_header;
 __u32 ext_ramdisk_image;
 __u32 ext_ramdisk_size;
 __u32 ext_cmd_line_ptr;
 __u8 _pad4[116];
 struct edid_info edid_info;
 struct efi_info efi_info;
 __u32 alt_mem_k;
 __u32 scratch;
 __u8 e820_entries;
 __u8 eddbuf_entries;
 __u8 edd_mbr_sig_buf_entries;
 __u8 kbd_status;
 __u8 _pad5[3];
 __u8 sentinel;
 __u8 _pad6[1];
 struct setup_header hdr;
 __u8 _pad7[0x290-0x1f1-sizeof(struct setup_header)];
 __u32 edd_mbr_sig_buffer[16];
 struct e820entry e820_map[128];
 __u8 _pad8[48];
 struct edd_info eddbuf[6];
 __u8 _pad9[276];

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__((packed));

enum {
 X86_SUBARCH_PC = 0,
 X86_SUBARCH_LGUEST,
 X86_SUBARCH_XEN,
 X86_SUBARCH_INTEL_MID,
 X86_SUBARCH_CE4100,
 X86_NR_SUBARCHS,
};

struct mpc_bus;
struct mpc_cpu;
struct mpc_table;
struct cpuinfo_x86;
struct x86_init_mpparse {
  template <typename, int = 0> struct __BYPASSx86_init_mpparse {};
  template <typename, int> friend struct __BYPASSx86_init_mpparse;
 void (*mpc_record)(unsigned int mode);
 void (*setup_ioapic_ids)(void);
 int (*mpc_apic_id)(struct mpc_cpu *m);
 void (*smp_read_mpc_oem)(struct mpc_table *mpc);
 void (*mpc_oem_pci_bus)(struct mpc_bus *m);
 void (*mpc_oem_bus_info)(struct mpc_bus *m, char *name);
 void (*find_smp_config)(void);
 void (*get_smp_config)(unsigned int early);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct x86_init_resources {
  template <typename, int = 0> struct __BYPASSx86_init_resources {};
  template <typename, int> friend struct __BYPASSx86_init_resources;
 void (*probe_roms)(void);
 void (*reserve_resources)(void);
 char *(*memory_setup)(void);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct x86_init_irqs {
  template <typename, int = 0> struct __BYPASSx86_init_irqs {};
  template <typename, int> friend struct __BYPASSx86_init_irqs;
 void (*pre_vector_init)(void);
 void (*intr_init)(void);
 void (*trap_init)(void);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};






struct x86_init_oem {
  template <typename, int = 0> struct __BYPASSx86_init_oem {};
  template <typename, int> friend struct __BYPASSx86_init_oem;
 void (*arch_setup)(void);
 void (*banner)(void);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct x86_init_paging {
  template <typename, int = 0> struct __BYPASSx86_init_paging {};
  template <typename, int> friend struct __BYPASSx86_init_paging;
 void (*pagetable_init)(void);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct x86_init_timers {
  template <typename, int = 0> struct __BYPASSx86_init_timers {};
  template <typename, int> friend struct __BYPASSx86_init_timers;
 void (*setup_percpu_clockev)(void);
 void (*tsc_pre_init)(void);
 void (*timer_init)(void);
 void (*wallclock_init)(void);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};





struct x86_init_iommu {
  template <typename, int = 0> struct __BYPASSx86_init_iommu {};
  template <typename, int> friend struct __BYPASSx86_init_iommu;
 int (*iommu_init)(void);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct x86_init_pci {
  template <typename, int = 0> struct __BYPASSx86_init_pci {};
  template <typename, int> friend struct __BYPASSx86_init_pci;
 int (*arch_init)(void);
 int (*init)(void);
 void (*init_irq)(void);
 void (*fixup_irqs)(void);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};





struct x86_init_ops {
  template <typename, int = 0> struct __BYPASSx86_init_ops {};
  template <typename, int> friend struct __BYPASSx86_init_ops;
 struct x86_init_resources resources;
 struct x86_init_mpparse mpparse;
 struct x86_init_irqs irqs;
 struct x86_init_oem oem;
 struct x86_init_paging paging;
 struct x86_init_timers timers;
 struct x86_init_iommu iommu;
 struct x86_init_pci pci;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};






struct x86_cpuinit_ops {
  template <typename, int = 0> struct __BYPASSx86_cpuinit_ops {};
  template <typename, int> friend struct __BYPASSx86_cpuinit_ops;
 void (*setup_percpu_clockev)(void);
 void (*early_percpu_clock_init)(void);
 void (*fixup_cpu_id)(struct cpuinfo_x86 *c, int node);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct timespec;
struct x86_platform_ops {
  template <typename, int = 0> struct __BYPASSx86_platform_ops {};
  template <typename, int> friend struct __BYPASSx86_platform_ops;
 unsigned long (*calibrate_tsc)(void);
 void (*get_wallclock)(struct timespec *ts);
 int (*set_wallclock)( struct timespec *ts);
 void (*iommu_shutdown)(void);
 bool (*is_untracked_pat_range)(u64 start, u64 end);
 void (*nmi_init)(void);
 unsigned char (*get_nmi_reason)(void);
 int (*i8042_detect)(void);
 void (*save_sched_clock_state)(void);
 void (*restore_sched_clock_state)(void);
 void (*apic_post_init)(void);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct pci_dev;
struct msi_msg;
struct msi_desc;

struct x86_msi_ops {
  template <typename, int = 0> struct __BYPASSx86_msi_ops {};
  template <typename, int> friend struct __BYPASSx86_msi_ops;
 int (*setup_msi_irqs)(struct pci_dev *dev, int nvec, int type);
 void (*compose_msi_msg)(struct pci_dev *dev, unsigned int irq,
    unsigned int dest, struct msi_msg *msg,
          u8 hpet_id);
 void (*teardown_msi_irq)(unsigned int irq);
 void (*teardown_msi_irqs)(struct pci_dev *dev);
 void (*restore_msi_irqs)(struct pci_dev *dev, int irq);
 int (*setup_hpet_msi)(unsigned int irq, unsigned int id);
 u32 (*msi_mask_irq)(struct msi_desc *desc, u32 mask, u32 flag);
 u32 (*msix_mask_irq)(struct msi_desc *desc, u32 flag);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct IO_APIC_route_entry;
struct io_apic_irq_attr;
struct irq_data;
struct cpumask;

struct x86_io_apic_ops {
  template <typename, int = 0> struct __BYPASSx86_io_apic_ops {};
  template <typename, int> friend struct __BYPASSx86_io_apic_ops;
 void (*init) (void);
 unsigned int (*read) (unsigned int apic, unsigned int reg);
 void (*write) (unsigned int apic, unsigned int reg, unsigned int value);
 void (*modify) (unsigned int apic, unsigned int reg, unsigned int value);
 void (*disable)(void);
 void (*print_entries)(unsigned int apic, unsigned int nr_entries);
 int (*set_affinity)(struct irq_data *data,
     struct cpumask *mask,
     bool force);
 int (*setup_entry)(int irq, struct IO_APIC_route_entry *entry,
           unsigned int destination, int vector,
           struct io_apic_irq_attr *attr);
 void (*eoi_ioapic_pin)(int apic, int pin, int vector);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

extern struct x86_init_ops x86_init;
extern struct x86_cpuinit_ops x86_cpuinit;
extern struct x86_platform_ops x86_platform;
extern struct x86_msi_ops x86_msi;
extern struct x86_io_apic_ops x86_io_apic_ops;
extern void x86_init_noop(void);
extern void x86_init_uint_noop(unsigned int unused);
struct local_apic {
  template <typename, int = 0> struct __BYPASSlocal_apic {};
  template <typename, int> friend struct __BYPASSlocal_apic;

        struct { unsigned int __reserved[4]; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __reserved_01;

        struct { unsigned int __reserved[4]; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __reserved_02;

        struct {
  unsigned int __reserved_1 : 24,
   phys_apic_id : 4,
   __reserved_2 : 4;
  unsigned int __reserved[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} id;

       
 struct {
  unsigned int version : 8,
   __reserved_1 : 8,
   max_lvt : 8,
   __reserved_2 : 8;
  unsigned int __reserved[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} version;

        struct { unsigned int __reserved[4]; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __reserved_03;

        struct { unsigned int __reserved[4]; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __reserved_04;

        struct { unsigned int __reserved[4]; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __reserved_05;

        struct { unsigned int __reserved[4]; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __reserved_06;

        struct {
  unsigned int priority : 8,
   __reserved_1 : 24;
  unsigned int __reserved_2[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} tpr;

       
 struct {
  unsigned int priority : 8,
   __reserved_1 : 24;
  unsigned int __reserved_2[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} apr;

       
 struct {
  unsigned int priority : 8,
   __reserved_1 : 24;
  unsigned int __reserved_2[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} ppr;

        struct {
  unsigned int eoi;
  unsigned int __reserved[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} eoi;

        struct { unsigned int __reserved[4]; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __reserved_07;

        struct {
  unsigned int __reserved_1 : 24,
   logical_dest : 8;
  unsigned int __reserved_2[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} ldr;

        struct {
  unsigned int __reserved_1 : 28,
   model : 4;
  unsigned int __reserved_2[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} dfr;

        struct {
  unsigned int spurious_vector : 8,
   apic_enabled : 1,
   focus_cpu : 1,
   __reserved_2 : 22;
  unsigned int __reserved_3[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} svr;

        struct {
         unsigned int bitfield;
  unsigned int __reserved[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} isr [8];

        struct {
         unsigned int bitfield;
  unsigned int __reserved[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} tmr [8];

        struct {
         unsigned int bitfield;
  unsigned int __reserved[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} irr [8];

        union {
  struct {
   unsigned int send_cs_error : 1,
    receive_cs_error : 1,
    send_accept_error : 1,
    receive_accept_error : 1,
    __reserved_1 : 1,
    send_illegal_vector : 1,
    receive_illegal_vector : 1,
    illegal_register_address : 1,
    __reserved_2 : 24;
   unsigned int __reserved_3[3];
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} error_bits;
  struct {
   unsigned int errors;
   unsigned int __reserved_3[3];
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} all_errors;
 } esr;

        struct { unsigned int __reserved[4]; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __reserved_08;

        struct { unsigned int __reserved[4]; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __reserved_09;

        struct { unsigned int __reserved[4]; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __reserved_10;

        struct { unsigned int __reserved[4]; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __reserved_11;

        struct { unsigned int __reserved[4]; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __reserved_12;

        struct { unsigned int __reserved[4]; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __reserved_13;

        struct { unsigned int __reserved[4]; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __reserved_14;

        struct {
  unsigned int vector : 8,
   delivery_mode : 3,
   destination_mode : 1,
   delivery_status : 1,
   __reserved_1 : 1,
   level : 1,
   trigger : 1,
   __reserved_2 : 2,
   shorthand : 2,
   __reserved_3 : 12;
  unsigned int __reserved_4[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} icr1;

        struct {
  union {
   unsigned int __reserved_1 : 24,
    phys_dest : 4,
    __reserved_2 : 4;
   unsigned int __reserved_3 : 24,
    logical_dest : 8;
  } dest;
  unsigned int __reserved_4[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} icr2;

        struct {
  unsigned int vector : 8,
   __reserved_1 : 4,
   delivery_status : 1,
   __reserved_2 : 3,
   mask : 1,
   timer_mode : 1,
   __reserved_3 : 14;
  unsigned int __reserved_4[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} lvt_timer;

        struct {
  unsigned int vector : 8,
   delivery_mode : 3,
   __reserved_1 : 1,
   delivery_status : 1,
   __reserved_2 : 3,
   mask : 1,
   __reserved_3 : 15;
  unsigned int __reserved_4[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} lvt_thermal;

        struct {
  unsigned int vector : 8,
   delivery_mode : 3,
   __reserved_1 : 1,
   delivery_status : 1,
   __reserved_2 : 3,
   mask : 1,
   __reserved_3 : 15;
  unsigned int __reserved_4[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} lvt_pc;

        struct {
  unsigned int vector : 8,
   delivery_mode : 3,
   __reserved_1 : 1,
   delivery_status : 1,
   polarity : 1,
   remote_irr : 1,
   trigger : 1,
   mask : 1,
   __reserved_2 : 15;
  unsigned int __reserved_3[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} lvt_lint0;

        struct {
  unsigned int vector : 8,
   delivery_mode : 3,
   __reserved_1 : 1,
   delivery_status : 1,
   polarity : 1,
   remote_irr : 1,
   trigger : 1,
   mask : 1,
   __reserved_2 : 15;
  unsigned int __reserved_3[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} lvt_lint1;

        struct {
  unsigned int vector : 8,
   __reserved_1 : 4,
   delivery_status : 1,
   __reserved_2 : 3,
   mask : 1,
   __reserved_3 : 15;
  unsigned int __reserved_4[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} lvt_error;

        struct {
  unsigned int initial_count;
  unsigned int __reserved_2[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} timer_icr;

       
 struct {
  unsigned int curr_count;
  unsigned int __reserved_2[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} timer_ccr;

        struct { unsigned int __reserved[4]; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __reserved_16;

        struct { unsigned int __reserved[4]; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __reserved_17;

        struct { unsigned int __reserved[4]; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __reserved_18;

        struct { unsigned int __reserved[4]; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __reserved_19;

        struct {
  unsigned int divisor : 4,
   __reserved_1 : 28;
  unsigned int __reserved_2[3];
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} timer_dcr;

        struct { unsigned int __reserved[4]; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __reserved_20;


  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed));
enum ioapic_irq_destination_types {
 dest_Fixed = 0,
 dest_LowestPrio = 1,
 dest_SMI = 2,
 dest__reserved_1 = 3,
 dest_NMI = 4,
 dest_INIT = 5,
 dest__reserved_2 = 6,
 dest_ExtINT = 7
};

extern int apic_version[];
extern int pic_mode;
extern unsigned long mp_bus_not_pci[(((256) + (8 * sizeof(long)) - 1) / (8 * sizeof(long)))];

extern unsigned int boot_cpu_physical_apicid;
extern unsigned int max_physical_apicid;
extern int mpc_default_type;
extern unsigned long mp_lapic_addr;


extern int smp_found_config;




static inline void get_smp_config(void)
{
 x86_init.mpparse.get_smp_config(0);
}

static inline void early_get_smp_config(void)
{
 x86_init.mpparse.get_smp_config(1);
}

static inline void find_smp_config(void)
{
 x86_init.mpparse.find_smp_config();
}


extern void early_reserve_e820_mpc_new(void);
extern int enable_update_mptable;
extern int default_mpc_apic_id(struct mpc_cpu *m);
extern void default_smp_read_mpc_oem(struct mpc_table *mpc);

extern void default_mpc_oem_bus_info(struct mpc_bus *m, char *str);



extern void default_find_smp_config(void);
extern void default_get_smp_config(unsigned int early);
int generic_processor_info(int apicid, int version);

extern void mp_register_ioapic(int id, u32 address, u32 gsi_base);
extern void mp_override_legacy_irq(u8 bus_irq, u8 polarity, u8 trigger,
       u32 gsi);
extern void mp_config_acpi_legacy_irqs(void);
struct device;
extern int mp_register_gsi(struct device *dev, u32 gsi, int edge_level,
     int active_high_low);




struct physid_mask {
  template <typename, int = 0> struct __BYPASSphysid_mask {};
  template <typename, int> friend struct __BYPASSphysid_mask;
 unsigned long mask[(((32768) + (8 * sizeof(long)) - 1) / (8 * sizeof(long)))];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

typedef struct physid_mask physid_mask_t;
static inline unsigned long physids_coerce(physid_mask_t *map)
{
 return map->mask[0];
}

static inline void physids_promote(unsigned long physids, physid_mask_t *map)
{
 bitmap_zero((*map).mask, 32768);
 map->mask[0] = physids;
}

static inline void physid_set_mask_of_physid(int physid, physid_mask_t *map)
{
 bitmap_zero((*map).mask, 32768);
 set_bit(physid, (*map).mask);
}




extern physid_mask_t phys_cpu_present_map;

extern int generic_mps_oem_check(struct mpc_table *, char *, char *);

extern int default_acpi_madt_oem_check(char *, char *);




extern void (*pm_power_off)(void);
extern void (*pm_power_off_prepare)(void);

struct device;

extern void pm_vt_switch_required(struct device *dev, bool required);
extern void pm_vt_switch_unregister(struct device *dev);
struct device;


extern char power_group_name[];




typedef struct pm_message {
  template <typename, int = 0> struct __BYPASSpm_message {};
  template <typename, int> friend struct __BYPASSpm_message;
 int event;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} pm_message_t;
struct dev_pm_ops {
  template <typename, int = 0> struct __BYPASSdev_pm_ops {};
  template <typename, int> friend struct __BYPASSdev_pm_ops;
 int (*prepare)(struct device *dev);
 void (*complete)(struct device *dev);
 int (*suspend)(struct device *dev);
 int (*resume)(struct device *dev);
 int (*freeze)(struct device *dev);
 int (*thaw)(struct device *dev);
 int (*poweroff)(struct device *dev);
 int (*restore)(struct device *dev);
 int (*suspend_late)(struct device *dev);
 int (*resume_early)(struct device *dev);
 int (*freeze_late)(struct device *dev);
 int (*thaw_early)(struct device *dev);
 int (*poweroff_late)(struct device *dev);
 int (*restore_early)(struct device *dev);
 int (*suspend_noirq)(struct device *dev);
 int (*resume_noirq)(struct device *dev);
 int (*freeze_noirq)(struct device *dev);
 int (*thaw_noirq)(struct device *dev);
 int (*poweroff_noirq)(struct device *dev);
 int (*restore_noirq)(struct device *dev);
 int (*runtime_suspend)(struct device *dev);
 int (*runtime_resume)(struct device *dev);
 int (*runtime_idle)(struct device *dev);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
enum rpm_status {
 RPM_ACTIVE = 0,
 RPM_RESUMING,
 RPM_SUSPENDED,
 RPM_SUSPENDING,
};
enum rpm_request {
 RPM_REQ_NONE = 0,
 RPM_REQ_IDLE,
 RPM_REQ_SUSPEND,
 RPM_REQ_AUTOSUSPEND,
 RPM_REQ_RESUME,
};

struct wakeup_source;

struct pm_domain_data {
  template <typename, int = 0> struct __BYPASSpm_domain_data {};
  template <typename, int> friend struct __BYPASSpm_domain_data;
 struct list_head list_node;
 struct device *dev;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct pm_subsys_data {
  template <typename, int = 0> struct __BYPASSpm_subsys_data {};
  template <typename, int> friend struct __BYPASSpm_subsys_data;
 spinlock_t lock;
 unsigned int refcount;

 struct list_head clock_list;





  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct dev_pm_info {
  template <typename, int = 0> struct __BYPASSdev_pm_info {};
  template <typename, int> friend struct __BYPASSdev_pm_info;
 pm_message_t power_state;
 unsigned int can_wakeup:1;
 unsigned int async_suspend:1;
 bool is_prepared:1;
 bool is_suspended:1;
 bool ignore_children:1;
 bool early_init:1;
 spinlock_t lock;

 struct list_head entry;
 struct completion completion;
 struct wakeup_source *wakeup;
 bool wakeup_path:1;
 bool syscore:1;




 struct timer_list suspend_timer;
 unsigned long timer_expires;
 struct work_struct work;
 wait_queue_head_t wait_queue;
 atomic_t usage_count;
 atomic_t child_count;
 unsigned int disable_depth:3;
 unsigned int idle_notification:1;
 unsigned int request_pending:1;
 unsigned int deferred_resume:1;
 unsigned int run_wake:1;
 unsigned int runtime_auto:1;
 unsigned int no_callbacks:1;
 unsigned int irq_safe:1;
 unsigned int use_autosuspend:1;
 unsigned int timer_autosuspends:1;
 unsigned int memalloc_noio:1;
 enum rpm_request request;
 enum rpm_status runtime_status;
 int runtime_error;
 int autosuspend_delay;
 unsigned long last_busy;
 unsigned long active_jiffies;
 unsigned long suspended_jiffies;
 unsigned long accounting_timestamp;

 struct pm_subsys_data *subsys_data;
 struct dev_pm_qos *qos;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

extern void update_pm_runtime_accounting(struct device *dev);
extern int dev_pm_get_subsys_data(struct device *dev);
extern int dev_pm_put_subsys_data(struct device *dev);






struct dev_pm_domain {
  template <typename, int = 0> struct __BYPASSdev_pm_domain {};
  template <typename, int> friend struct __BYPASSdev_pm_domain;
 struct dev_pm_ops ops;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
extern void device_pm_lock(void);
extern void dpm_resume_start(pm_message_t state);
extern void dpm_resume_end(pm_message_t state);
extern void dpm_resume(pm_message_t state);
extern void dpm_complete(pm_message_t state);

extern void device_pm_unlock(void);
extern int dpm_suspend_end(pm_message_t state);
extern int dpm_suspend_start(pm_message_t state);
extern int dpm_suspend(pm_message_t state);
extern int dpm_prepare(pm_message_t state);

extern void __suspend_report_result( char *function, void *fn, int ret);






extern int device_pm_wait_for_dev(struct device *sub, struct device *dev);
extern void dpm_for_each_dev(void *data, void (*fn)(struct device *, void *));

extern int pm_generic_prepare(struct device *dev);
extern int pm_generic_suspend_late(struct device *dev);
extern int pm_generic_suspend_noirq(struct device *dev);
extern int pm_generic_suspend(struct device *dev);
extern int pm_generic_resume_early(struct device *dev);
extern int pm_generic_resume_noirq(struct device *dev);
extern int pm_generic_resume(struct device *dev);
extern int pm_generic_freeze_noirq(struct device *dev);
extern int pm_generic_freeze_late(struct device *dev);
extern int pm_generic_freeze(struct device *dev);
extern int pm_generic_thaw_noirq(struct device *dev);
extern int pm_generic_thaw_early(struct device *dev);
extern int pm_generic_thaw(struct device *dev);
extern int pm_generic_restore_noirq(struct device *dev);
extern int pm_generic_restore_early(struct device *dev);
extern int pm_generic_restore(struct device *dev);
extern int pm_generic_poweroff_noirq(struct device *dev);
extern int pm_generic_poweroff_late(struct device *dev);
extern int pm_generic_poweroff(struct device *dev);
extern void pm_generic_complete(struct device *dev);
enum dpm_order {
 DPM_ORDER_NONE,
 DPM_ORDER_DEV_AFTER_PARENT,
 DPM_ORDER_PARENT_BEFORE_DEV,
 DPM_ORDER_DEV_LAST,
};












extern __attribute__((section(".data..percpu" ""))) __typeof__(int) x86_cpu_to_node_map; extern __typeof__(int) *x86_cpu_to_node_map_early_ptr; extern __typeof__(int) x86_cpu_to_node_map_early_map[];

template <typename TResult, typename TThat, typename TTarget> struct TJP___per_cpu_offset_362_0 {
  typedef TJP___per_cpu_offset_362_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int __get___per_cpu_offset_362(unsigned long int *source) {
  unsigned long int __result_buffer;
  typedef TJP___per_cpu_offset_362_0< unsigned long int , void *, unsigned long int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int &)__result_buffer;
}
static inline int early_cpu_to_node(int cpu)
{
 return *((x86_cpu_to_node_map_early_ptr) ? &(x86_cpu_to_node_map_early_ptr)[cpu] : &(*({ do { void *__vpp_verify = (typeof(((&(x86_cpu_to_node_map))) + 0))0; (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __asm__ ("" : "=r"(__ptr) : "0"((typeof(*(&(x86_cpu_to_node_map))) *)(&(x86_cpu_to_node_map)))); (typeof((typeof(*(&(x86_cpu_to_node_map))) *)(&(x86_cpu_to_node_map)))) (__ptr + (((__get___per_cpu_offset_362(&__per_cpu_offset[cpu]))))); }); })));
}




extern cpumask_var_t node_to_cpumask_map[(1 << 6)];





static inline struct cpumask *cpumask_of_node(int node)
{
 return node_to_cpumask_map[node];
}


extern void setup_node_to_cpumask_map(void);
extern int __node_distance(int, int);

extern struct cpumask *cpu_coregroup_mask(int cpu);
static inline void arch_fix_phys_package_id(int num, u32 slot)
{
}

struct pci_bus;
void x86_pci_root_bus_resources(int bus, struct list_head *resources);
extern int get_mp_bus_to_node(int busnum);
extern void set_mp_bus_to_node(int busnum, int node);
extern int numa_off;
extern s16 __apicid_to_node[32768];
extern nodemask_t numa_nodes_parsed __attribute__ ((__section__(".init.data")));

extern int __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) numa_add_memblk(int nodeid, u64 start, u64 end);
extern void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) numa_set_distance(int from, int to, int distance);

static inline void set_apicid_to_node(int apicid, s16 node)
{
 __apicid_to_node[apicid] = node;
}

extern int numa_cpu_node(int cpu);
extern void numa_set_node(int cpu, int node);
extern void numa_clear_node(int cpu);
extern void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) init_cpu_to_node(void);
extern void numa_add_cpu(int cpu);
extern void numa_remove_cpu(int cpu);

typedef struct {
 void *ldt;
 int size;



 unsigned short ia32_compat;


 struct mutex lock;
 void *vdso;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} mm_context_t;


void leave_mm(int cpu);





static inline unsigned char readb( void *addr) { unsigned char ret; asm ("mov" "b" " %1,%0":"=q" (ret) :"m" (*( unsigned char *)addr) :"memory"); return ret; }
static inline unsigned short readw( void *addr) { unsigned short ret; asm ("mov" "w" " %1,%0":"=r" (ret) :"m" (*( unsigned short *)addr) :"memory"); return ret; }
static inline unsigned int readl( void *addr) { unsigned int ret; asm ("mov" "l" " %1,%0":"=r" (ret) :"m" (*( unsigned int *)addr) :"memory"); return ret; }

static inline unsigned char __readb( void *addr) { unsigned char ret; asm ("mov" "b" " %1,%0":"=q" (ret) :"m" (*( unsigned char *)addr) ); return ret; }
static inline unsigned short __readw( void *addr) { unsigned short ret; asm ("mov" "w" " %1,%0":"=r" (ret) :"m" (*( unsigned short *)addr) ); return ret; }
static inline unsigned int __readl( void *addr) { unsigned int ret; asm ("mov" "l" " %1,%0":"=r" (ret) :"m" (*( unsigned int *)addr) ); return ret; }

static inline void writeb(unsigned char val, void *addr) { asm ("mov" "b" " %0,%1": :"q" (val), "m" (*( unsigned char *)addr) :"memory"); }
static inline void writew(unsigned short val, void *addr) { asm ("mov" "w" " %0,%1": :"r" (val), "m" (*( unsigned short *)addr) :"memory"); }
static inline void writel(unsigned int val, void *addr) { asm ("mov" "l" " %0,%1": :"r" (val), "m" (*( unsigned int *)addr) :"memory"); }

static inline void __writeb(unsigned char val, void *addr) { asm ("mov" "b" " %0,%1": :"q" (val), "m" (*( unsigned char *)addr) ); }
static inline void __writew(unsigned short val, void *addr) { asm ("mov" "w" " %0,%1": :"r" (val), "m" (*( unsigned short *)addr) ); }
static inline void __writel(unsigned int val, void *addr) { asm ("mov" "l" " %0,%1": :"r" (val), "m" (*( unsigned int *)addr) ); }
static inline unsigned long readq( void *addr) { unsigned long ret; asm ("mov" "q" " %1,%0":"=r" (ret) :"m" (*( unsigned long *)addr) :"memory"); return ret; }
static inline void writeq(unsigned long val, void *addr) { asm ("mov" "q" " %0,%1": :"r" (val), "m" (*( unsigned long *)addr) :"memory"); }
static inline phys_addr_t virt_to_phys( void *address)
{
 return __phys_addr_nodebug((unsigned long)(address));
}
static inline void *phys_to_virt(phys_addr_t address)
{
 return ((void *)((unsigned long)(address)+((unsigned long)(0xffff880000000000UL))));
}
static inline unsigned int isa_virt_to_bus( void *address)
{
 return (unsigned int)virt_to_phys(address);
}
extern void *ioremap_nocache(resource_size_t offset, unsigned long size);
extern void *ioremap_cache(resource_size_t offset, unsigned long size);
extern void *ioremap_prot(resource_size_t offset, unsigned long size,
    unsigned long prot_val);




static inline void *ioremap(resource_size_t offset, unsigned long size)
{
 return ioremap_nocache(offset, size);
}

extern void iounmap( void *addr);

extern void set_iounmap_nonlazy(void);



extern unsigned int ioread8(void *);
extern unsigned int ioread16(void *);
extern unsigned int ioread16be(void *);
extern unsigned int ioread32(void *);
extern unsigned int ioread32be(void *);

extern void iowrite8(u8, void *);
extern void iowrite16(u16, void *);
extern void iowrite16be(u16, void *);
extern void iowrite32(u32, void *);
extern void iowrite32be(u32, void *);
extern void ioread8_rep(void *port, void *buf, unsigned long count);
extern void ioread16_rep(void *port, void *buf, unsigned long count);
extern void ioread32_rep(void *port, void *buf, unsigned long count);

extern void iowrite8_rep(void *port, void *buf, unsigned long count);
extern void iowrite16_rep(void *port, void *buf, unsigned long count);
extern void iowrite32_rep(void *port, void *buf, unsigned long count);



extern void *ioport_map(unsigned long port, unsigned int nr);
extern void ioport_unmap(void *);
struct pci_dev;
extern void pci_iounmap(struct pci_dev *dev, void *);






struct pci_dev;


extern void *pci_iomap(struct pci_dev *dev, int bar, unsigned long max);








struct rb_node {
  template <typename, int = 0> struct __BYPASSrb_node {};
  template <typename, int> friend struct __BYPASSrb_node;
 unsigned long __rb_parent_color;
 struct rb_node *rb_right;
 struct rb_node *rb_left;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__((aligned(sizeof(long))));


struct rb_root {
  template <typename, int = 0> struct __BYPASSrb_root {};
  template <typename, int> friend struct __BYPASSrb_root;
 struct rb_node *rb_node;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
extern void rb_insert_color(struct rb_node *, struct rb_root *);
extern void rb_erase(struct rb_node *, struct rb_root *);



extern struct rb_node *rb_next( struct rb_node *);
extern struct rb_node *rb_prev( struct rb_node *);
extern struct rb_node *rb_first( struct rb_root *);
extern struct rb_node *rb_last( struct rb_root *);


extern struct rb_node *rb_first_postorder( struct rb_root *);
extern struct rb_node *rb_next_postorder( struct rb_node *);


extern void rb_replace_node(struct rb_node *victim, struct rb_node *_new,
       struct rb_root *root);

static inline void rb_link_node(struct rb_node * node, struct rb_node * parent,
    struct rb_node ** rb_link)
{
 node->__rb_parent_color = (unsigned long)parent;
 node->rb_left = node->rb_right = 0;

 *rb_link = node;
}

struct vm_area_struct;
struct vm_struct {
  template <typename, int = 0> struct __BYPASSvm_struct {};
  template <typename, int> friend struct __BYPASSvm_struct;
 struct vm_struct *next;
 void *addr;
 unsigned long size;
 unsigned long flags;
 struct page **pages;
 unsigned int nr_pages;
 phys_addr_t phys_addr;
 void *caller;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct vmap_area {
  template <typename, int = 0> struct __BYPASSvmap_area {};
  template <typename, int> friend struct __BYPASSvmap_area;
 unsigned long va_start;
 unsigned long va_end;
 unsigned long flags;
 struct rb_node rb_node;
 struct list_head list;
 struct list_head purge_list;
 struct vm_struct *vm;
 struct callback_head callback_head;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};




extern void vm_unmap_ram( void *mem, unsigned int count);
extern void *vm_map_ram(struct page **pages, unsigned int count,
    int node, pgprot_t prot);
extern void vm_unmap_aliases(void);


extern void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) vmalloc_init(void);






extern void *vmalloc(unsigned long size);
extern void *vzalloc(unsigned long size);
extern void *vmalloc_user(unsigned long size);
extern void *vmalloc_node(unsigned long size, int node);
extern void *vzalloc_node(unsigned long size, int node);
extern void *vmalloc_exec(unsigned long size);
extern void *vmalloc_32(unsigned long size);
extern void *vmalloc_32_user(unsigned long size);
extern void *__vmalloc(unsigned long size, gfp_t gfp_mask, pgprot_t prot);
extern void *__vmalloc_node_range(unsigned long size, unsigned long align,
   unsigned long start, unsigned long end, gfp_t gfp_mask,
   pgprot_t prot, int node, void *caller);
extern void vfree( void *addr);

extern void *vmap(struct page **pages, unsigned int count,
   unsigned long flags, pgprot_t prot);
extern void vunmap( void *addr);

extern int remap_vmalloc_range_partial(struct vm_area_struct *vma,
           unsigned long uaddr, void *kaddr,
           unsigned long size);

extern int remap_vmalloc_range(struct vm_area_struct *vma, void *addr,
       unsigned long pgoff);
void vmalloc_sync_all(void);






template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN9vm_struct4sizeE_364_0 {
  typedef TJP__ZN9vm_struct4sizeE_364_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int __get__ZN9vm_struct4sizeE_364(unsigned long int *source) {
  unsigned long int __result_buffer;
  typedef TJP__ZN9vm_struct4sizeE_364_0< unsigned long int , ::vm_struct , unsigned long int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int &)__result_buffer;
}
static inline size_t get_vm_area_size( struct vm_struct *area)
{

 return __get__ZN9vm_struct4sizeE_364(&area->size) - ((1UL) << 12);
}

extern struct vm_struct *get_vm_area(unsigned long size, unsigned long flags);
extern struct vm_struct *get_vm_area_caller(unsigned long size,
     unsigned long flags, void *caller);
extern struct vm_struct *__get_vm_area(unsigned long size, unsigned long flags,
     unsigned long start, unsigned long end);
extern struct vm_struct *__get_vm_area_caller(unsigned long size,
     unsigned long flags,
     unsigned long start, unsigned long end,
     void *caller);
extern struct vm_struct *remove_vm_area( void *addr);
extern struct vm_struct *find_vm_area( void *addr);

extern int map_vm_area(struct vm_struct *area, pgprot_t prot,
   struct page ***pages);

extern int map_kernel_range_noflush(unsigned long start, unsigned long size,
        pgprot_t prot, struct page **pages);
extern void unmap_kernel_range_noflush(unsigned long addr, unsigned long size);
extern void unmap_kernel_range(unsigned long addr, unsigned long size);
extern struct vm_struct *alloc_vm_area(size_t size, pte_t **ptes);
extern void free_vm_area(struct vm_struct *area);


extern long vread(char *buf, char *addr, unsigned long count);
extern long vwrite(char *buf, char *addr, unsigned long count);




extern struct list_head vmap_area_list;
extern __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) void vm_area_add_early(struct vm_struct *vm);
extern __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) void vm_area_register_early(struct vm_struct *vm, size_t align);



struct vm_struct **pcpu_get_vm_areas( unsigned long *offsets,
         size_t *sizes, int nr_vms,
         size_t align);

void pcpu_free_vm_areas(struct vm_struct **vms, int nr_vms);
struct vmalloc_info {
  template <typename, int = 0> struct __BYPASSvmalloc_info {};
  template <typename, int> friend struct __BYPASSvmalloc_info;
 unsigned long used;
 unsigned long largest_chunk;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};



extern void get_vmalloc_info(struct vmalloc_info *vmi);






static inline void
memset_io( void *addr, unsigned char val, size_t count)
{
 memset((void *)addr, val, count);
}

static inline void
memcpy_fromio(void *dst, void *src, size_t count)
{
 memcpy(dst, ( void *)src, count);
}

static inline void
memcpy_toio( void *dst, void *src, size_t count)
{
 memcpy((void *)dst, src, count);
}
static inline void flush_write_buffers(void)
{



}



extern void native_io_delay(void);

extern int io_delay_type;
extern void io_delay_init(void);
static inline void outb(unsigned char value, int port) { asm ("out" "b" " %" "b" "0, %w1" : : "a"(value), "Nd"(port)); } static inline unsigned char inb(int port) { unsigned char value; asm ("in" "b" " %w1, %" "b" "0" : "=a"(value) : "Nd"(port)); return value; } static inline void outb_p(unsigned char value, int port) { outb(value, port); slow_down_io(); } static inline unsigned char inb_p(int port) { unsigned char value = inb(port); slow_down_io(); return value; } static inline void outsb(int port, void *addr, unsigned long count) { asm ("rep; outs" "b" : "+S"(addr), "+c"(count) : "d"(port)); } static inline void insb(int port, void *addr, unsigned long count) { asm ("rep; ins" "b" : "+D"(addr), "+c"(count) : "d"(port)); }
static inline void outw(unsigned short value, int port) { asm ("out" "w" " %" "w" "0, %w1" : : "a"(value), "Nd"(port)); } static inline unsigned short inw(int port) { unsigned short value; asm ("in" "w" " %w1, %" "w" "0" : "=a"(value) : "Nd"(port)); return value; } static inline void outw_p(unsigned short value, int port) { outw(value, port); slow_down_io(); } static inline unsigned short inw_p(int port) { unsigned short value = inw(port); slow_down_io(); return value; } static inline void outsw(int port, void *addr, unsigned long count) { asm ("rep; outs" "w" : "+S"(addr), "+c"(count) : "d"(port)); } static inline void insw(int port, void *addr, unsigned long count) { asm ("rep; ins" "w" : "+D"(addr), "+c"(count) : "d"(port)); }
static inline void outl(unsigned int value, int port) { asm ("out" "l" " %" "" "0, %w1" : : "a"(value), "Nd"(port)); } static inline unsigned int inl(int port) { unsigned int value; asm ("in" "l" " %w1, %" "" "0" : "=a"(value) : "Nd"(port)); return value; } static inline void outl_p(unsigned int value, int port) { outl(value, port); slow_down_io(); } static inline unsigned int inl_p(int port) { unsigned int value = inl(port); slow_down_io(); return value; } static inline void outsl(int port, void *addr, unsigned long count) { asm ("rep; outs" "l" : "+S"(addr), "+c"(count) : "d"(port)); } static inline void insl(int port, void *addr, unsigned long count) { asm ("rep; ins" "l" : "+D"(addr), "+c"(count) : "d"(port)); }

extern void *xlate_dev_mem_ptr(unsigned long phys);
extern void unxlate_dev_mem_ptr(unsigned long phys, void *addr);

extern int ioremap_change_attr(unsigned long vaddr, unsigned long size,
    unsigned long prot_val);
extern void *ioremap_wc(resource_size_t offset, unsigned long size);






extern void early_ioremap_init(void);
extern void early_ioremap_reset(void);
extern void *early_ioremap(resource_size_t phys_addr,
       unsigned long size);
extern void *early_memremap(resource_size_t phys_addr,
        unsigned long size);
extern void early_iounmap(void *addr, unsigned long size);
extern void fixup_early_ioremap(void);
extern bool is_early_ioremap_ptep(pte_t *ptep);





enum xen_domain_type {
 XEN_NATIVE,
 XEN_PV_DOMAIN,
 XEN_HVM_DOMAIN,
};


extern enum xen_domain_type xen_domain_type;
typedef unsigned long xen_pfn_t;

typedef unsigned long xen_ulong_t;


typedef unsigned char * __guest_handle_uchar;
typedef unsigned int * __guest_handle_uint;
typedef char * __guest_handle_char;
typedef int * __guest_handle_int;
typedef void * __guest_handle_void;
typedef uint64_t * __guest_handle_uint64_t;
typedef uint32_t * __guest_handle_uint32_t;
typedef xen_pfn_t * __guest_handle_xen_pfn_t;
typedef xen_ulong_t * __guest_handle_xen_ulong_t;
struct trap_info {
  template <typename, int = 0> struct __BYPASStrap_info {};
  template <typename, int> friend struct __BYPASStrap_info;
    uint8_t vector;
    uint8_t flags;
    uint16_t cs;
    unsigned long address;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
typedef struct trap_info * __guest_handle_trap_info;

struct arch_shared_info {
  template <typename, int = 0> struct __BYPASSarch_shared_info {};
  template <typename, int> friend struct __BYPASSarch_shared_info;
    unsigned long max_pfn;

    unsigned long pfn_to_mfn_frame_list_list;
    unsigned long nmi_reason;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};





struct iret_context {
  template <typename, int = 0> struct __BYPASSiret_context {};
  template <typename, int> friend struct __BYPASSiret_context;

    uint64_t rax, r11, rcx, flags, rip, cs, rflags, rsp, ss;


  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct cpu_user_regs {
  template <typename, int = 0> struct __BYPASScpu_user_regs {};
  template <typename, int> friend struct __BYPASScpu_user_regs;
    uint64_t r15;
    uint64_t r14;
    uint64_t r13;
    uint64_t r12;
    union { uint64_t rbp, ebp; uint32_t _ebp; };
    union { uint64_t rbx, ebx; uint32_t _ebx; };
    uint64_t r11;
    uint64_t r10;
    uint64_t r9;
    uint64_t r8;
    union { uint64_t rax, eax; uint32_t _eax; };
    union { uint64_t rcx, ecx; uint32_t _ecx; };
    union { uint64_t rdx, edx; uint32_t _edx; };
    union { uint64_t rsi, esi; uint32_t _esi; };
    union { uint64_t rdi, edi; uint32_t _edi; };
    uint32_t error_code;
    uint32_t entry_vector;
    union { uint64_t rip, eip; uint32_t _eip; };
    uint16_t cs, _pad0[1];
    uint8_t saved_upcall_mask;
    uint8_t _pad1[3];
    union { uint64_t rflags, eflags; uint32_t _eflags; };
    union { uint64_t rsp, esp; uint32_t _esp; };
    uint16_t ss, _pad2[3];
    uint16_t es, _pad3[3];
    uint16_t ds, _pad4[3];
    uint16_t fs, _pad5[3];
    uint16_t gs, _pad6[3];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
typedef struct cpu_user_regs * __guest_handle_cpu_user_regs;






struct arch_vcpu_info {
  template <typename, int = 0> struct __BYPASSarch_vcpu_info {};
  template <typename, int> friend struct __BYPASSarch_vcpu_info;
    unsigned long cr2;
    unsigned long pad;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

typedef unsigned long xen_callback_t;


struct pvclock_vcpu_time_info {
  template <typename, int = 0> struct __BYPASSpvclock_vcpu_time_info {};
  template <typename, int> friend struct __BYPASSpvclock_vcpu_time_info;
 u32 version;
 u32 pad0;
 u64 tsc_timestamp;
 u64 system_time;
 u32 tsc_to_system_mul;
 s8 tsc_shift;
 u8 flags;
 u8 pad[2];

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__((__packed__));

struct pvclock_wall_clock {
  template <typename, int = 0> struct __BYPASSpvclock_wall_clock {};
  template <typename, int> friend struct __BYPASSpvclock_wall_clock;
 u32 version;
 u32 sec;
 u32 nsec;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__((__packed__));






struct vcpu_guest_context {
  template <typename, int = 0> struct __BYPASSvcpu_guest_context {};
  template <typename, int> friend struct __BYPASSvcpu_guest_context;

    struct { char x[512]; 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} fpu_ctxt;



    unsigned long flags;
    struct cpu_user_regs user_regs;
    struct trap_info trap_ctxt[256];
    unsigned long ldt_base, ldt_ents;
    unsigned long gdt_frames[16], gdt_ents;
    unsigned long kernel_ss, kernel_sp;

    unsigned long ctrlreg[8];
    unsigned long debugreg[8];






    unsigned long event_callback_eip;
    unsigned long failsafe_callback_eip;
    unsigned long syscall_callback_eip;

    unsigned long vm_assist;


    uint64_t fs_base;
    uint64_t gs_base_kernel;
    uint64_t gs_base_user;


  friend class ::Introspect;
  friend class ::MyIntrospect;
};
typedef struct vcpu_guest_context * __guest_handle_vcpu_guest_context;
struct mmuext_op {
  template <typename, int = 0> struct __BYPASSmmuext_op {};
  template <typename, int> friend struct __BYPASSmmuext_op;
 unsigned int cmd;
 union {

  xen_pfn_t mfn;

  unsigned long linear_addr;
 } arg1;
 union {

  unsigned int nr_ents;

  void *vcpumask;
 } arg2;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
typedef struct mmuext_op * __guest_handle_mmuext_op;
typedef uint16_t domid_t;
struct mmu_update {
  template <typename, int = 0> struct __BYPASSmmu_update {};
  template <typename, int> friend struct __BYPASSmmu_update;
    uint64_t ptr;
    uint64_t val;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
typedef struct mmu_update * __guest_handle_mmu_update;





struct multicall_entry {
  template <typename, int = 0> struct __BYPASSmulticall_entry {};
  template <typename, int> friend struct __BYPASSmulticall_entry;
    unsigned long op;
    long result;
    unsigned long args[6];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
typedef struct multicall_entry * __guest_handle_multicall_entry;







struct vcpu_time_info {
  template <typename, int = 0> struct __BYPASSvcpu_time_info {};
  template <typename, int> friend struct __BYPASSvcpu_time_info;
 uint32_t version;
 uint32_t pad0;
 uint64_t tsc_timestamp;
 uint64_t system_time;






 uint32_t tsc_to_system_mul;
 int8_t tsc_shift;
 int8_t pad1[3];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct vcpu_info {
  template <typename, int = 0> struct __BYPASSvcpu_info {};
  template <typename, int> friend struct __BYPASSvcpu_info;
 uint8_t evtchn_upcall_pending;
 uint8_t evtchn_upcall_mask;
 xen_ulong_t evtchn_pending_sel;
 struct arch_vcpu_info arch;
 struct pvclock_vcpu_time_info time;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};





struct shared_info {
  template <typename, int = 0> struct __BYPASSshared_info {};
  template <typename, int> friend struct __BYPASSshared_info;
 struct vcpu_info vcpu_info[32];
 xen_ulong_t evtchn_pending[sizeof(xen_ulong_t) * 8];
 xen_ulong_t evtchn_mask[sizeof(xen_ulong_t) * 8];





 struct pvclock_wall_clock wc;

 struct arch_shared_info arch;


  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct start_info {
  template <typename, int = 0> struct __BYPASSstart_info {};
  template <typename, int> friend struct __BYPASSstart_info;

 char magic[32];
 unsigned long nr_pages;
 unsigned long shared_info;
 uint32_t flags;
 xen_pfn_t store_mfn;
 uint32_t store_evtchn;
 union {
  struct {
   xen_pfn_t mfn;
   uint32_t evtchn;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} domU;
  struct {
   uint32_t info_off;
   uint32_t info_size;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} dom0;
 } console;

 unsigned long pt_base;
 unsigned long nr_pt_frames;
 unsigned long mfn_list;
 unsigned long mod_start;
 unsigned long mod_len;
 int8_t cmd_line[1024];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct dom0_vga_console_info {
  template <typename, int = 0> struct __BYPASSdom0_vga_console_info {};
  template <typename, int> friend struct __BYPASSdom0_vga_console_info;
 uint8_t video_type;




 union {
  struct {

   uint16_t font_height;

   uint16_t cursor_x, cursor_y;

   uint16_t rows, columns;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} text_mode_3;

  struct {

   uint16_t width, height;

   uint16_t bytes_per_line;

   uint16_t bits_per_pixel;

   uint32_t lfb_base;
   uint32_t lfb_size;

   uint8_t red_pos, red_size;
   uint8_t green_pos, green_size;
   uint8_t blue_pos, blue_size;
   uint8_t rsvd_pos, rsvd_size;


   uint32_t gbl_caps;

   uint16_t mode_attrs;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} vesa_lfb;
 } u;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};






typedef uint64_t cpumap_t;

typedef uint8_t xen_domain_handle_t[16];







struct tmem_op {
  template <typename, int = 0> struct __BYPASStmem_op {};
  template <typename, int> friend struct __BYPASStmem_op;
 uint32_t cmd;
 int32_t pool_id;
 union {
  struct {
   uint64_t uuid[2];
   uint32_t flags;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} _new;
  struct {
   uint64_t oid[3];
   uint32_t index;
   uint32_t tmem_offset;
   uint32_t pfn_offset;
   uint32_t len;
   __guest_handle_void gmfn;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
} gen;
 } u;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

typedef u64 * __guest_handle_u64;
extern struct shared_info *HYPERVISOR_shared_info;
extern struct start_info *xen_start_info;



static inline uint32_t xen_cpuid_base(void)
{
 return hypervisor_cpuid_base("XenVMMXenVMM", 2);
}


extern bool xen_hvm_need_lapic(void);

static inline bool xen_x2apic_para_available(void)
{
 return xen_hvm_need_lapic();
}
struct bio_vec;

extern bool xen_biovec_phys_mergeable( struct bio_vec *vec1,
          struct bio_vec *vec2);
extern int arch_phys_wc_add(unsigned long base,
      unsigned long size);
extern void arch_phys_wc_del(int handle);


struct real_mode_header {
  template <typename, int = 0> struct __BYPASSreal_mode_header {};
  template <typename, int> friend struct __BYPASSreal_mode_header;
 u32 text_start;
 u32 ro_end;

 u32 trampoline_start;
 u32 trampoline_status;
 u32 trampoline_header;

 u32 trampoline_pgd;



 u32 wakeup_start;
 u32 wakeup_header;


 u32 machine_real_restart_asm;

 u32 machine_real_restart_seg;


  friend class ::Introspect;
  friend class ::MyIntrospect;
};


struct trampoline_header {
  template <typename, int = 0> struct __BYPASStrampoline_header {};
  template <typename, int> friend struct __BYPASStrampoline_header;






 u64 start;
 u64 efer;
 u32 cr4;


  friend class ::Introspect;
  friend class ::MyIntrospect;
};

extern struct real_mode_header *real_mode_header;
extern unsigned char real_mode_blob_end[];

extern unsigned long init_rsp;
extern unsigned long initial_code;
extern unsigned long initial_gs;

extern unsigned char real_mode_blob[];
extern unsigned char real_mode_relocs[];





extern unsigned char secondary_startup_64[];


void reserve_real_mode(void);
void setup_real_mode(void);
int __acpi_acquire_global_lock(unsigned int *lock);
int __acpi_release_global_lock(unsigned int *lock);
extern int acpi_lapic;
extern int acpi_ioapic;
extern int acpi_noirq;
extern int acpi_strict;
extern int acpi_disabled;
extern int acpi_pci_disabled;
extern int acpi_skip_timer_override;
extern int acpi_use_timer_override;
extern int acpi_fix_pin2_polarity;
extern int acpi_disable_cmcff;

extern u8 acpi_sci_flags;
extern int acpi_sci_override_gsi;
void acpi_pic_sci_set_trigger(unsigned int, u16);

extern int (*__acpi_register_gsi)(struct device *dev, u32 gsi,
      int trigger, int polarity);

static inline void disable_acpi(void)
{
 acpi_disabled = 1;
 acpi_pci_disabled = 1;
 acpi_noirq = 1;
}

extern int acpi_gsi_to_irq(u32 gsi, unsigned int *irq);

static inline void acpi_noirq_set(void) { acpi_noirq = 1; }
static inline void acpi_disable_pci(void)
{
 acpi_pci_disabled = 1;
 acpi_noirq_set();
}


extern int (*acpi_suspend_lowlevel)(void);







static inline unsigned int acpi_processor_cstate_check(unsigned int max_cstate)
{






 if (boot_cpu_data.x86 == 0x0F &&
     boot_cpu_data.x86_vendor == 2 &&
     boot_cpu_data.x86_model <= 0x05 &&
     boot_cpu_data.x86_mask < 0x0A)
  return 1;
 else if (amd_e400_c1e_detected)
  return 1;
 else
  return max_cstate;
}


template <typename TResult, typename TThat, typename TTarget> struct TJP___per_cpu_offset_374_0 {
  typedef TJP___per_cpu_offset_374_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int __get___per_cpu_offset_374(unsigned long int *source) {
  unsigned long int __result_buffer;
  typedef TJP___per_cpu_offset_374_0< unsigned long int , void *, unsigned long int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int &)__result_buffer;
}
static inline bool arch_has_acpi_pdc(void)
{
 struct cpuinfo_x86 *c = &(*({ do { void *__vpp_verify = (typeof(((&(cpu_info))) + 0))0; (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __asm__ ("" : "=r"(__ptr) : "0"((typeof(*(&(cpu_info))) *)(&(cpu_info)))); (typeof((typeof(*(&(cpu_info))) *)(&(cpu_info)))) (__ptr + (((__get___per_cpu_offset_374(&__per_cpu_offset[0]))))); }); }));
 return (c->x86_vendor == 0 ||
  c->x86_vendor == 5);
}


template <typename TResult, typename TThat, typename TTarget> struct TJP___per_cpu_offset_377_0 {
  typedef TJP___per_cpu_offset_377_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int __get___per_cpu_offset_377(unsigned long int *source) {
  unsigned long int __result_buffer;
  typedef TJP___per_cpu_offset_377_0< unsigned long int , void *, unsigned long int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int &)__result_buffer;
}
static inline void arch_acpi_set_pdc_bits(u32 *buf)
{
 struct cpuinfo_x86 *c = &(*({ do { void *__vpp_verify = (typeof(((&(cpu_info))) + 0))0; (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __asm__ ("" : "=r"(__ptr) : "0"((typeof(*(&(cpu_info))) *)(&(cpu_info)))); (typeof((typeof(*(&(cpu_info))) *)(&(cpu_info)))) (__ptr + (((__get___per_cpu_offset_377(&__per_cpu_offset[0]))))); }); }));

 buf[2] |= ((0x0010) | (0x0008) | (0x0002) | (0x0100) | (0x0200));

 if ((__builtin_constant_p((4*32+ 7)) && ( ((((4*32+ 7))>>5)==0 && (1UL<<(((4*32+ 7))&31) & ((1<<((0*32+ 0) & 31))|0|(1<<((0*32+ 5) & 31))|(1<<((0*32+ 6) & 31))| (1<<((0*32+ 8) & 31))|0|(1<<((0*32+24) & 31))|(1<<((0*32+15) & 31))| (1<<((0*32+25) & 31))|(1<<((0*32+26) & 31))))) || ((((4*32+ 7))>>5)==1 && (1UL<<(((4*32+ 7))&31) & ((1<<((1*32+29) & 31))|0))) || ((((4*32+ 7))>>5)==2 && (1UL<<(((4*32+ 7))&31) & 0)) || ((((4*32+ 7))>>5)==3 && (1UL<<(((4*32+ 7))&31) & ((1<<((3*32+20) & 31))))) || ((((4*32+ 7))>>5)==4 && (1UL<<(((4*32+ 7))&31) & (0))) || ((((4*32+ 7))>>5)==5 && (1UL<<(((4*32+ 7))&31) & 0)) || ((((4*32+ 7))>>5)==6 && (1UL<<(((4*32+ 7))&31) & 0)) || ((((4*32+ 7))>>5)==7 && (1UL<<(((4*32+ 7))&31) & 0)) || ((((4*32+ 7))>>5)==8 && (1UL<<(((4*32+ 7))&31) & 0)) || ((((4*32+ 7))>>5)==9 && (1UL<<(((4*32+ 7))&31) & 0)) ) ? 1 : (__builtin_constant_p(((4*32+ 7))) ? constant_test_bit(((4*32+ 7)), ((unsigned long *)((c)->x86_capability))) : variable_test_bit(((4*32+ 7)), ((unsigned long *)((c)->x86_capability))))))
  buf[2] |= ((0x0008) | (0x0002) | (0x0020) | (0x0800) | (0x0001));

 if ((__builtin_constant_p((0*32+22)) && ( ((((0*32+22))>>5)==0 && (1UL<<(((0*32+22))&31) & ((1<<((0*32+ 0) & 31))|0|(1<<((0*32+ 5) & 31))|(1<<((0*32+ 6) & 31))| (1<<((0*32+ 8) & 31))|0|(1<<((0*32+24) & 31))|(1<<((0*32+15) & 31))| (1<<((0*32+25) & 31))|(1<<((0*32+26) & 31))))) || ((((0*32+22))>>5)==1 && (1UL<<(((0*32+22))&31) & ((1<<((1*32+29) & 31))|0))) || ((((0*32+22))>>5)==2 && (1UL<<(((0*32+22))&31) & 0)) || ((((0*32+22))>>5)==3 && (1UL<<(((0*32+22))&31) & ((1<<((3*32+20) & 31))))) || ((((0*32+22))>>5)==4 && (1UL<<(((0*32+22))&31) & (0))) || ((((0*32+22))>>5)==5 && (1UL<<(((0*32+22))&31) & 0)) || ((((0*32+22))>>5)==6 && (1UL<<(((0*32+22))&31) & 0)) || ((((0*32+22))>>5)==7 && (1UL<<(((0*32+22))&31) & 0)) || ((((0*32+22))>>5)==8 && (1UL<<(((0*32+22))&31) & 0)) || ((((0*32+22))>>5)==9 && (1UL<<(((0*32+22))&31) & 0)) ) ? 1 : (__builtin_constant_p(((0*32+22))) ? constant_test_bit(((0*32+22)), ((unsigned long *)((c)->x86_capability))) : variable_test_bit(((0*32+22)), ((unsigned long *)((c)->x86_capability))))))
  buf[2] |= (0x0004);




 if (!(__builtin_constant_p((4*32+ 3)) && ( ((((4*32+ 3))>>5)==0 && (1UL<<(((4*32+ 3))&31) & ((1<<((0*32+ 0) & 31))|0|(1<<((0*32+ 5) & 31))|(1<<((0*32+ 6) & 31))| (1<<((0*32+ 8) & 31))|0|(1<<((0*32+24) & 31))|(1<<((0*32+15) & 31))| (1<<((0*32+25) & 31))|(1<<((0*32+26) & 31))))) || ((((4*32+ 3))>>5)==1 && (1UL<<(((4*32+ 3))&31) & ((1<<((1*32+29) & 31))|0))) || ((((4*32+ 3))>>5)==2 && (1UL<<(((4*32+ 3))&31) & 0)) || ((((4*32+ 3))>>5)==3 && (1UL<<(((4*32+ 3))&31) & ((1<<((3*32+20) & 31))))) || ((((4*32+ 3))>>5)==4 && (1UL<<(((4*32+ 3))&31) & (0))) || ((((4*32+ 3))>>5)==5 && (1UL<<(((4*32+ 3))&31) & 0)) || ((((4*32+ 3))>>5)==6 && (1UL<<(((4*32+ 3))&31) & 0)) || ((((4*32+ 3))>>5)==7 && (1UL<<(((4*32+ 3))&31) & 0)) || ((((4*32+ 3))>>5)==8 && (1UL<<(((4*32+ 3))&31) & 0)) || ((((4*32+ 3))>>5)==9 && (1UL<<(((4*32+ 3))&31) & 0)) ) ? 1 : (__builtin_constant_p(((4*32+ 3))) ? constant_test_bit(((4*32+ 3)), ((unsigned long *)((c)->x86_capability))) : variable_test_bit(((4*32+ 3)), ((unsigned long *)((c)->x86_capability))))))
  buf[2] &= ~((0x0200));
}
extern int acpi_numa;
extern int x86_acpi_numa_init(void);





typedef u64 cycle_t;
struct clocksource;
struct module;


struct arch_clocksource_data {
  template <typename, int = 0> struct __BYPASSarch_clocksource_data {};
  template <typename, int> friend struct __BYPASSarch_clocksource_data;
 int vclock_mode;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct cyclecounter {
  template <typename, int = 0> struct __BYPASScyclecounter {};
  template <typename, int> friend struct __BYPASScyclecounter;
 cycle_t (*read)( struct cyclecounter *cc);
 cycle_t mask;
 u32 mult;
 u32 shift;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct timecounter {
  template <typename, int = 0> struct __BYPASStimecounter {};
  template <typename, int> friend struct __BYPASStimecounter;
 struct cyclecounter *cc;
 cycle_t cycle_last;
 u64 nsec;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
static inline u64 cyclecounter_cyc2ns( struct cyclecounter *cc,
          cycle_t cycles)
{
 u64 ret = (u64)cycles;
 ret = (ret * cc->mult) >> cc->shift;
 return ret;
}
extern void timecounter_init(struct timecounter *tc,
        struct cyclecounter *cc,
        u64 start_tstamp);
extern u64 timecounter_read(struct timecounter *tc);
extern u64 timecounter_cyc2time(struct timecounter *tc,
    cycle_t cycle_tstamp);
struct clocksource {
  template <typename, int = 0> struct __BYPASSclocksource {};
  template <typename, int> friend struct __BYPASSclocksource;




 cycle_t (*read)(struct clocksource *cs);
 cycle_t cycle_last;
 cycle_t mask;
 u32 mult;
 u32 shift;
 u64 max_idle_ns;
 u32 maxadj;

 struct arch_clocksource_data archdata;


 char *name;
 struct list_head list;
 int rating;
 int (*enable)(struct clocksource *cs);
 void (*disable)(struct clocksource *cs);
 unsigned long flags;
 void (*suspend)(struct clocksource *cs);
 void (*resume)(struct clocksource *cs);




 struct list_head wd_list;
 cycle_t cs_last;
 cycle_t wd_last;

 struct module *owner;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__((__aligned__((1 << (6)))));
static inline u32 clocksource_khz2mult(u32 khz, u32 shift_constant)
{







 u64 tmp = ((u64)1000000) << shift_constant;

 tmp += khz/2;
 ({ uint32_t __base = (khz); uint32_t __rem; __rem = ((uint64_t)(tmp)) % __base; (tmp) = ((uint64_t)(tmp)) / __base; __rem; });

 return (u32)tmp;
}
static inline u32 clocksource_hz2mult(u32 hz, u32 shift_constant)
{







 u64 tmp = ((u64)1000000000) << shift_constant;

 tmp += hz/2;
 ({ uint32_t __base = (hz); uint32_t __rem; __rem = ((uint64_t)(tmp)) % __base; (tmp) = ((uint64_t)(tmp)) / __base; __rem; });

 return (u32)tmp;
}
static inline s64 clocksource_cyc2ns(cycle_t cycles, u32 mult, u32 shift)
{
 return ((u64) cycles * mult) >> shift;
}


extern int clocksource_register(struct clocksource*);
extern int clocksource_unregister(struct clocksource*);
extern void clocksource_touch_watchdog(void);
extern struct clocksource* clocksource_get_next(void);
extern void clocksource_change_rating(struct clocksource *cs, int rating);
extern void clocksource_suspend(void);
extern void clocksource_resume(void);
extern struct clocksource * __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((weak)) clocksource_default_clock(void);
extern void clocksource_mark_unstable(struct clocksource *cs);

extern u64
clocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask);
extern void
clocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 minsec);





extern int
__clocksource_register_scale(struct clocksource *cs, u32 scale, u32 freq);
extern void
__clocksource_updatefreq_scale(struct clocksource *cs, u32 scale, u32 freq);

static inline int clocksource_register_hz(struct clocksource *cs, u32 hz)
{
 return __clocksource_register_scale(cs, 1, hz);
}

static inline int clocksource_register_khz(struct clocksource *cs, u32 khz)
{
 return __clocksource_register_scale(cs, 1000, khz);
}

static inline void __clocksource_updatefreq_hz(struct clocksource *cs, u32 hz)
{
 __clocksource_updatefreq_scale(cs, 1, hz);
}

static inline void __clocksource_updatefreq_khz(struct clocksource *cs, u32 khz)
{
 __clocksource_updatefreq_scale(cs, 1000, khz);
}


extern int timekeeping_notify(struct clocksource *clock);

extern cycle_t clocksource_mmio_readl_up(struct clocksource *);
extern cycle_t clocksource_mmio_readl_down(struct clocksource *);
extern cycle_t clocksource_mmio_readw_up(struct clocksource *);
extern cycle_t clocksource_mmio_readw_down(struct clocksource *);

extern int clocksource_mmio_init(void *, char *,
 unsigned long, int, unsigned, cycle_t (*)(struct clocksource *));

extern int clocksource_i8253_init(void);

struct device_node;
typedef void(*clocksource_of_init_fn)(struct device_node *);
static inline void clocksource_of_init(void) {}



cycle_t pvclock_clocksource_read(struct pvclock_vcpu_time_info *src);
u8 pvclock_read_flags(struct pvclock_vcpu_time_info *src);
void pvclock_set_flags(u8 flags);
unsigned long pvclock_tsc_khz(struct pvclock_vcpu_time_info *src);
void pvclock_read_wallclock(struct pvclock_wall_clock *wall,
       struct pvclock_vcpu_time_info *vcpu,
       struct timespec *ts);
void pvclock_resume(void);

void pvclock_touch_watchdogs(void);





static inline u64 pvclock_scale_delta(u64 delta, u32 mul_frac, int shift)
{
 u64 product;



 ulong tmp;


 if (shift < 0)
  delta >>= -shift;
 else
  delta <<= shift;
 __asm__ (
  "mulq %[mul_frac] ; shrd $32, %[hi], %[lo]"
  : [lo]"=a"(product),
    [hi]"=d"(tmp)
  : "0"(delta),
    [mul_frac]"rm"((u64)mul_frac));




 return product;
}

static inline __attribute__((always_inline))
u64 pvclock_get_nsec_offset( struct pvclock_vcpu_time_info *src)
{
 u64 delta = __native_read_tsc() - src->tsc_timestamp;
 return pvclock_scale_delta(delta, src->tsc_to_system_mul,
       src->tsc_shift);
}

static inline __attribute__((always_inline))
unsigned __pvclock_read_cycles( struct pvclock_vcpu_time_info *src,
          cycle_t *cycles, u8 *flags)
{
 unsigned version;
 cycle_t ret, offset;
 u8 ret_flags;

 version = src->version;






 rdtsc_barrier();
 offset = pvclock_get_nsec_offset(src);
 ret = src->system_time + offset;
 ret_flags = src->flags;
 rdtsc_barrier();

 *cycles = ret;
 *flags = ret_flags;
 return version;
}

struct pvclock_vsyscall_time_info {
  template <typename, int = 0> struct __BYPASSpvclock_vsyscall_time_info {};
  template <typename, int> friend struct __BYPASSpvclock_vsyscall_time_info;
 struct pvclock_vcpu_time_info pvti;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__((__aligned__((1 << (6)))));




int __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) pvclock_init_vsyscall(struct pvclock_vsyscall_time_info *i,
     int size);
struct pvclock_vcpu_time_info *pvclock_get_vsyscall_time_info(int cpu);











enum vsyscall_num {
 __NR_vgettimeofday,
 __NR_vtime,
 __NR_vgetcpu,
};





extern int vgetcpu_mode;
extern struct timezone sys_tz;

static unsigned long * vvaraddr_jiffies = (void *)((-10*1024*1024 - 4096) + (0));
static int * vvaraddr_vgetcpu_mode = (void *)((-10*1024*1024 - 4096) + (16));
static struct vsyscall_gtod_data * vvaraddr_vsyscall_gtod_data = (void *)((-10*1024*1024 - 4096) + (128));

extern void map_vsyscall(void);





extern bool emulate_vsyscall(struct pt_regs *regs, unsigned long address);





static inline unsigned int __getcpu(void)
{
 unsigned int p;

 if ((*vvaraddr_vgetcpu_mode) == 1) {

  native_read_tscp(&p);
 } else {

  asm("lsl %1,%0" : "=r" (p) : "r" ((15 * 8 + 3)));
 }

 return p;
}
enum fixed_addresses {




 VSYSCALL_LAST_PAGE,
 VSYSCALL_FIRST_PAGE = VSYSCALL_LAST_PAGE
       + (((-2UL << 20)-(-10UL << 20)) >> 12) - 1,
 VVAR_PAGE,
 VSYSCALL_HPET,

 PVCLOCK_FIXMAP_BEGIN,
 PVCLOCK_FIXMAP_END = PVCLOCK_FIXMAP_BEGIN+(((256 -1)/(((1UL) << 12)/sizeof(struct pvclock_vsyscall_time_info)))+1)-1,


 FIX_DBGP_BASE,
 FIX_EARLYCON_MEM_BASE,




 FIX_APIC_BASE,


 FIX_IO_APIC_BASE_0,
 FIX_IO_APIC_BASE_END = FIX_IO_APIC_BASE_0 + 128 - 1,







 FIX_RO_IDT,
 FIX_PARAVIRT_BOOTMAP,

 FIX_TEXT_POKE1,
 FIX_TEXT_POKE0,



 __end_of_permanent_fixed_addresses,
 FIX_BTMAP_END =
  (__end_of_permanent_fixed_addresses ^
   (__end_of_permanent_fixed_addresses + (64 * 4) - 1)) &
  -512
  ? __end_of_permanent_fixed_addresses + (64 * 4) -
    (__end_of_permanent_fixed_addresses & ((64 * 4) - 1))
  : __end_of_permanent_fixed_addresses,
 FIX_BTMAP_BEGIN = FIX_BTMAP_END + (64 * 4) - 1,




 FIX_TBOOT_BASE,

 __end_of_fixed_addresses
};


extern void reserve_top_address(unsigned long reserve);






extern int fixmaps_set;

extern pte_t *kmap_pte;
extern pgprot_t kmap_prot;
extern pte_t *pkmap_page_table;

void __native_set_fixmap(enum fixed_addresses idx, pte_t pte);
void native_set_fixmap(enum fixed_addresses idx,
         phys_addr_t phys, pgprot_t flags);
extern void __this_fixmap_does_not_exist(void);






static inline __attribute__((always_inline)) unsigned long fix_to_virt( unsigned int idx)
{
 if (idx >= __end_of_fixed_addresses)
  __this_fixmap_does_not_exist();

 return (((-2UL << 20)-((1UL) << 12)) - ((idx) << 12));
}

static inline unsigned long virt_to_fix( unsigned long vaddr)
{
 (vaddr >= ((-2UL << 20)-((1UL) << 12)) || vaddr < (((-2UL << 20)-((1UL) << 12)) - (__end_of_permanent_fixed_addresses << 12)));
 return ((((-2UL << 20)-((1UL) << 12)) - ((vaddr)&(~(((1UL) << 12)-1)))) >> 12);
}


static inline __attribute__((always_inline)) unsigned long
__set_fixmap_offset(enum fixed_addresses idx, phys_addr_t phys, pgprot_t flags)
{
 __set_fixmap(idx, phys, flags);
 return fix_to_virt(idx) + (phys & (((1UL) << 12) - 1));
}








struct notifier_block;
void idle_notifier_register(struct notifier_block *n);
void idle_notifier_unregister(struct notifier_block *n);


void enter_idle(void);
void exit_idle(void);






void amd_e400_remove_cpu(int cpu);
static inline void generic_apic_probe(void)
{
}




extern unsigned int apic_verbosity;
extern int local_apic_timer_c2_ok;

extern int disable_apic;
extern unsigned int lapic_timer_frequency;


extern void __inquire_remote_apic(int apicid);






static inline void default_inquire_remote_apic(int apicid)
{
 if (apic_verbosity >= 2)
  __inquire_remote_apic(apicid);
}
static inline bool apic_from_smp_config(void)
{
 return smp_found_config && !disable_apic;
}
extern int is_vsmp_box(void);






extern void xapic_wait_icr_idle(void);
extern u32 safe_xapic_wait_icr_idle(void);
extern void xapic_icr_write(u32, u32);
extern int setup_profiling_timer(unsigned int);

static inline void native_apic_mem_write(u32 reg, u32 v)
{
 u32 *addr = ( u32 *)((fix_to_virt(FIX_APIC_BASE)) + reg);

 asm ("661:\n\t" "movl %0, %1" "\n662:\n" ".pushsection .altinstructions,\"a\"\n" " .long 661b - .\n" " .long " "663""1""f - .\n" " .word " "(3*32+19)" "\n" " .byte " "662b-661b" "\n" " .byte " "664""1""f-""663""1""f" "\n" ".popsection\n" ".pushsection .discard,\"aw\",@progbits\n" " .byte 0xff + (" "664""1""f-""663""1""f" ") - (" "662b-661b" ")\n" ".popsection\n" ".pushsection .altinstr_replacement, \"ax\"\n" "663""1"":\n\t" "xchgl %0, %1" "\n" "664""1" ":\n\t" ".popsection" : "=r" (v), "=m" (*addr) : "i" (0), "0" (v), "m" (*addr))

                                           ;
}

static inline u32 native_apic_mem_read(u32 reg)
{
 return *(( u32 *)((fix_to_virt(FIX_APIC_BASE)) + reg));
}

extern void native_apic_wait_icr_idle(void);
extern u32 native_safe_apic_wait_icr_idle(void);
extern void native_apic_icr_write(u32 low, u32 id);
extern u64 native_apic_icr_read(void);

extern int x2apic_mode;







static inline void x2apic_wrmsr_fence(void)
{
 asm ("mfence" : : : "memory");
}

static inline void native_apic_msr_write(u32 reg, u32 v)
{
 if (reg == 0xE0 || reg == 0x20 || reg == 0xD0 ||
     reg == 0x30)
  return;

 do { paravirt_write_msr(0x800 + (reg >> 4), v, 0); } while (0);
}

static inline void native_apic_msr_eoi_write(u32 reg, u32 v)
{
 do { paravirt_write_msr(0x800 + (0xB0 >> 4), 0x0, 0); } while (0);
}

static inline u32 native_apic_msr_read(u32 reg)
{
 u64 msr;

 if (reg == 0xE0)
  return -1;

 do { int _err; msr = paravirt_read_msr(0x800 + (reg >> 4), &_err); } while (0);
 return (u32)msr;
}

static inline void native_x2apic_wait_icr_idle(void)
{

 return;
}

static inline u32 native_safe_x2apic_wait_icr_idle(void)
{

 return 0;
}

static inline void native_x2apic_icr_write(u32 low, u32 id)
{
 do { paravirt_write_msr(0x800 + (0x300 >> 4), (u32)((u64)(((__u64) id) << 32 | low)), ((u64)(((__u64) id) << 32 | low))>>32); } while (0);
}

static inline u64 native_x2apic_icr_read(void)
{
 unsigned long val;

 do { int _err; val = paravirt_read_msr(0x800 + (0x300 >> 4), &_err); } while (0);
 return val;
}

extern int x2apic_phys;
extern int x2apic_preenabled;
extern void check_x2apic(void);
extern void enable_x2apic(void);
extern void x2apic_icr_write(u32 low, u32 id);
static inline int x2apic_enabled(void)
{
 u64 msr;

 if (!(__builtin_constant_p((4*32+21)) && ( ((((4*32+21))>>5)==0 && (1UL<<(((4*32+21))&31) & ((1<<((0*32+ 0) & 31))|0|(1<<((0*32+ 5) & 31))|(1<<((0*32+ 6) & 31))| (1<<((0*32+ 8) & 31))|0|(1<<((0*32+24) & 31))|(1<<((0*32+15) & 31))| (1<<((0*32+25) & 31))|(1<<((0*32+26) & 31))))) || ((((4*32+21))>>5)==1 && (1UL<<(((4*32+21))&31) & ((1<<((1*32+29) & 31))|0))) || ((((4*32+21))>>5)==2 && (1UL<<(((4*32+21))&31) & 0)) || ((((4*32+21))>>5)==3 && (1UL<<(((4*32+21))&31) & ((1<<((3*32+20) & 31))))) || ((((4*32+21))>>5)==4 && (1UL<<(((4*32+21))&31) & (0))) || ((((4*32+21))>>5)==5 && (1UL<<(((4*32+21))&31) & 0)) || ((((4*32+21))>>5)==6 && (1UL<<(((4*32+21))&31) & 0)) || ((((4*32+21))>>5)==7 && (1UL<<(((4*32+21))&31) & 0)) || ((((4*32+21))>>5)==8 && (1UL<<(((4*32+21))&31) & 0)) || ((((4*32+21))>>5)==9 && (1UL<<(((4*32+21))&31) & 0)) ) ? 1 : (__builtin_constant_p(((4*32+21))) ? constant_test_bit(((4*32+21)), ((unsigned long *)((&boot_cpu_data)->x86_capability))) : variable_test_bit(((4*32+21)), ((unsigned long *)((&boot_cpu_data)->x86_capability))))))
  return 0;

 do { int _err; msr = paravirt_read_msr(0x0000001b, &_err); } while (0);
 if (msr & (1UL << 10))
  return 1;
 return 0;
}


static inline void x2apic_force_phys(void)
{
 x2apic_phys = 1;
}
extern void enable_IR_x2apic(void);

extern int get_physical_broadcast(void);

extern int lapic_get_maxlvt(void);
extern void clear_local_APIC(void);
extern void connect_bsp_APIC(void);
extern void disconnect_bsp_APIC(int virt_wire_setup);
extern void disable_local_APIC(void);
extern void lapic_shutdown(void);
extern int verify_local_APIC(void);
extern void sync_Arb_IDs(void);
extern void init_bsp_APIC(void);
extern void setup_local_APIC(void);
extern void end_local_APIC_setup(void);
extern void bsp_end_local_APIC_setup(void);
extern void init_apic_mappings(void);
void register_lapic_address(unsigned long address);
extern void setup_boot_APIC_clock(void);
extern void setup_secondary_APIC_clock(void);
extern int APIC_init_uniprocessor(void);
extern int apic_force_enable(unsigned long addr);





extern int apic_is_clustered_box(void);







extern int setup_APIC_eilvt(u8 lvt_off, u8 vector, u8 msg_type, u8 mask);
struct apic {
  template <typename, int = 0> struct __BYPASSapic {};
  template <typename, int> friend struct __BYPASSapic;
 char *name;

 int (*probe)(void);
 int (*acpi_madt_oem_check)(char *oem_id, char *oem_table_id);
 int (*apic_id_valid)(int apicid);
 int (*apic_id_registered)(void);

 u32 irq_delivery_mode;
 u32 irq_dest_mode;

 struct cpumask *(*target_cpus)(void);

 int disable_esr;

 int dest_logical;
 unsigned long (*check_apicid_used)(physid_mask_t *map, int apicid);
 unsigned long (*check_apicid_present)(int apicid);

 void (*vector_allocation_domain)(int cpu, struct cpumask *retmask,
      struct cpumask *mask);
 void (*init_apic_ldr)(void);

 void (*ioapic_phys_id_map)(physid_mask_t *phys_map, physid_mask_t *retmap);

 void (*setup_apic_routing)(void);
 int (*multi_timer_check)(int apic, int irq);
 int (*cpu_present_to_apicid)(int mps_cpu);
 void (*apicid_to_cpu_present)(int phys_apicid, physid_mask_t *retmap);
 void (*setup_portio_remap)(void);
 int (*check_phys_apicid_present)(int phys_apicid);
 void (*enable_apic_mode)(void);
 int (*phys_pkg_id)(int cpuid_apic, int index_msb);






 int (*mps_oem_check)(struct mpc_table *mpc, char *oem, char *productid);

 unsigned int (*get_apic_id)(unsigned long x);
 unsigned long (*set_apic_id)(unsigned int id);
 unsigned long apic_id_mask;

 int (*cpu_mask_to_apicid_and)( struct cpumask *cpumask,
          struct cpumask *andmask,
          unsigned int *apicid);


 void (*send_IPI_mask)( struct cpumask *mask, int vector);
 void (*send_IPI_mask_allbutself)( struct cpumask *mask,
      int vector);
 void (*send_IPI_allbutself)(int vector);
 void (*send_IPI_all)(int vector);
 void (*send_IPI_self)(int vector);


 int (*wakeup_secondary_cpu)(int apicid, unsigned long start_eip);

 int trampoline_phys_low;
 int trampoline_phys_high;

 void (*wait_for_init_deassert)(atomic_t *deassert);
 void (*smp_callin_clear_local_apic)(void);
 void (*inquire_remote_apic)(int apicid);


 u32 (*read)(u32 reg);
 void (*write)(u32 reg, u32 v);







 void (*eoi_write)(u32 reg, u32 v);
 u64 (*icr_read)(void);
 void (*icr_write)(u32 low, u32 high);
 void (*wait_icr_idle)(void);
 u32 (*safe_wait_icr_idle)(void);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};






extern struct apic *apic;
extern struct apic *__apicdrivers[], *__apicdrivers_end[];





extern atomic_t init_deasserted;
extern int wakeup_secondary_cpu_via_nmi(int apicid, unsigned long start_eip);




static inline u32 apic_read(u32 reg)
{
 return apic->read(reg);
}

static inline void apic_write(u32 reg, u32 val)
{
 apic->write(reg, val);
}

static inline void apic_eoi(void)
{
 apic->eoi_write(0xB0, 0x0);
}

static inline u64 apic_icr_read(void)
{
 return apic->icr_read();
}

static inline void apic_icr_write(u32 low, u32 high)
{
 apic->icr_write(low, high);
}

static inline void apic_wait_icr_idle(void)
{
 apic->wait_icr_idle();
}

static inline u32 safe_apic_wait_icr_idle(void)
{
 return apic->safe_wait_icr_idle();
}

extern void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) apic_set_eoi_write(void (*eoi_write)(u32 reg, u32 v));
static inline void ack_APIC_irq(void)
{




 apic_eoi();
}

static inline unsigned default_get_apic_id(unsigned long x)
{
 unsigned int ver = ((apic_read(0x30)) & 0xFFu);

 if (((ver) >= 0x14) || (__builtin_constant_p((3*32+26)) && ( ((((3*32+26))>>5)==0 && (1UL<<(((3*32+26))&31) & ((1<<((0*32+ 0) & 31))|0|(1<<((0*32+ 5) & 31))|(1<<((0*32+ 6) & 31))| (1<<((0*32+ 8) & 31))|0|(1<<((0*32+24) & 31))|(1<<((0*32+15) & 31))| (1<<((0*32+25) & 31))|(1<<((0*32+26) & 31))))) || ((((3*32+26))>>5)==1 && (1UL<<(((3*32+26))&31) & ((1<<((1*32+29) & 31))|0))) || ((((3*32+26))>>5)==2 && (1UL<<(((3*32+26))&31) & 0)) || ((((3*32+26))>>5)==3 && (1UL<<(((3*32+26))&31) & ((1<<((3*32+20) & 31))))) || ((((3*32+26))>>5)==4 && (1UL<<(((3*32+26))&31) & (0))) || ((((3*32+26))>>5)==5 && (1UL<<(((3*32+26))&31) & 0)) || ((((3*32+26))>>5)==6 && (1UL<<(((3*32+26))&31) & 0)) || ((((3*32+26))>>5)==7 && (1UL<<(((3*32+26))&31) & 0)) || ((((3*32+26))>>5)==8 && (1UL<<(((3*32+26))&31) & 0)) || ((((3*32+26))>>5)==9 && (1UL<<(((3*32+26))&31) & 0)) ) ? 1 : (__builtin_constant_p(((3*32+26))) ? constant_test_bit(((3*32+26)), ((unsigned long *)((&boot_cpu_data)->x86_capability))) : variable_test_bit(((3*32+26)), ((unsigned long *)((&boot_cpu_data)->x86_capability))))))
  return (x >> 24) & 0xFF;
 else
  return (x >> 24) & 0x0F;
}
extern int default_acpi_madt_oem_check(char *, char *);

extern void apic_send_IPI_self(int vector);

extern __attribute__((section(".data..percpu" ""))) __typeof__(int) x2apic_extra_bits;

extern int default_cpu_present_to_apicid(int mps_cpu);
extern int default_check_phys_apicid_present(int phys_apicid);


static inline void default_wait_for_init_deassert(atomic_t *deassert)
{
 while (!atomic_read(deassert))
  cpu_relax();
 return;
}

extern void generic_bigsmp_probe(void);








template <typename TResult, typename TThat, typename TTarget> struct TJP_cpu_online_mask_418_0 {
  typedef TJP_cpu_online_mask_418_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline cpumask * __get_cpu_online_mask_418(cpumask * *source) {
  ::cpumask *__result_buffer;
  typedef TJP_cpu_online_mask_418_0< ::cpumask *, void *, ::cpumask * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::cpumask *&)__result_buffer;
}
static inline struct cpumask *default_target_cpus(void)
{

 return __get_cpu_online_mask_418(&cpu_online_mask);



}


template <typename TResult, typename TThat, typename TTarget> struct TJP_cpu_online_mask_419_0 {
  typedef TJP_cpu_online_mask_419_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline cpumask * __get_cpu_online_mask_419(cpumask * *source) {
  ::cpumask *__result_buffer;
  typedef TJP_cpu_online_mask_419_0< ::cpumask *, void *, ::cpumask * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::cpumask *&)__result_buffer;
}
static inline struct cpumask *online_target_cpus(void)
{
 return __get_cpu_online_mask_419(&cpu_online_mask);
}

extern __attribute__((section(".data..percpu" "..readmostly"))) __typeof__(u16) x86_bios_cpu_apicid; extern __typeof__(u16) *x86_bios_cpu_apicid_early_ptr; extern __typeof__(u16) x86_bios_cpu_apicid_early_map[];


static inline unsigned int read_apic_id(void)
{
 unsigned int reg;

 reg = apic_read(0x20);

 return apic->get_apic_id(reg);
}

static inline int default_apic_id_valid(int apicid)
{
 return (apicid < 255);
}

extern void default_setup_apic_routing(void);

extern struct apic apic_noop;

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_422_0 {
  typedef TJP__ZN7cpumask4bitsE_422_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_422(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_422_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_423_0 {
  typedef TJP__ZN7cpumask4bitsE_423_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_423(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_423_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_424_0 {
  typedef TJP__ZN7cpumask4bitsE_424_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_424(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_424_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP_cpu_online_mask_425_0 {
  typedef TJP_cpu_online_mask_425_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return true;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return true;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline cpumask * __get_cpu_online_mask_425(cpumask * *source) {
  ::cpumask *__result_buffer;
  typedef TJP_cpu_online_mask_425_0< ::cpumask *, void *, ::cpumask * > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (::cpumask *&)__result_buffer;
}
static inline int
flat_cpu_mask_to_apicid_and( struct cpumask *cpumask,
       struct cpumask *andmask,
       unsigned int *apicid)
{
 unsigned long cpu_mask = (__get__ZN7cpumask4bitsE_422((cpumask)->bits))[0] &
     (__get__ZN7cpumask4bitsE_423((andmask)->bits))[0] &
     (__get__ZN7cpumask4bitsE_424((__get_cpu_online_mask_425(&cpu_online_mask))->bits))[0] &
     0xFFu;

 if (__builtin_expect(!!(cpu_mask), 1)) {
  *apicid = (unsigned int)cpu_mask;
  return 0;
 } else {
  return -22;
 }
}

extern int
default_cpu_mask_to_apicid_and( struct cpumask *cpumask,
          struct cpumask *andmask,
          unsigned int *apicid);

static inline void
flat_vector_allocation_domain(int cpu, struct cpumask *retmask,
         struct cpumask *mask)
{
 cpumask_clear(retmask);
 ((retmask)->bits)[0] = 0xFFu;
}

static inline void
default_vector_allocation_domain(int cpu, struct cpumask *retmask,
     struct cpumask *mask)
{
 cpumask_copy(retmask, (get_cpu_mask(cpu)));
}

static inline unsigned long default_check_apicid_used(physid_mask_t *map, int apicid)
{
 return (__builtin_constant_p((apicid)) ? constant_test_bit((apicid), ((*map).mask)) : variable_test_bit((apicid), ((*map).mask)));
}

static inline unsigned long default_check_apicid_present(int bit)
{
 return (__builtin_constant_p((bit)) ? constant_test_bit((bit), ((phys_cpu_present_map).mask)) : variable_test_bit((bit), ((phys_cpu_present_map).mask)));
}

static inline void default_ioapic_phys_id_map(physid_mask_t *phys_map, physid_mask_t *retmap)
{
 *retmap = *phys_map;
}


template <typename TResult, typename TThat, typename TTarget> struct TJP_nr_cpu_ids_432_0 {
  typedef TJP_nr_cpu_ids_432_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline int __get_nr_cpu_ids_432(int *source) {
  int __result_buffer;
  typedef TJP_nr_cpu_ids_432_0< int , void *, int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (int &)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_433_0 {
  typedef TJP__ZN7cpumask4bitsE_433_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_433(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_433_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_435_0 {
  typedef TJP__ZN7cpumask4bitsE_435_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_435(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_435_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP___per_cpu_offset_437_0 {
  typedef TJP___per_cpu_offset_437_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int __get___per_cpu_offset_437(unsigned long int *source) {
  unsigned long int __result_buffer;
  typedef TJP___per_cpu_offset_437_0< unsigned long int , void *, unsigned long int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int &)__result_buffer;
}
static inline int __default_cpu_present_to_apicid(int mps_cpu)
{
 if (mps_cpu < __get_nr_cpu_ids_432(&nr_cpu_ids) && (__builtin_constant_p((cpumask_check((mps_cpu)))) ? constant_test_bit((cpumask_check((mps_cpu))), ((__get__ZN7cpumask4bitsE_433(((cpu_present_mask))->bits)))) : variable_test_bit((cpumask_check((mps_cpu))), ((__get__ZN7cpumask4bitsE_435(((cpu_present_mask))->bits))))))
  return (int)(*({ do { void *__vpp_verify = (typeof(((&(x86_bios_cpu_apicid))) + 0))0; (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __asm__ ("" : "=r"(__ptr) : "0"((typeof(*(&(x86_bios_cpu_apicid))) *)(&(x86_bios_cpu_apicid)))); (typeof((typeof(*(&(x86_bios_cpu_apicid))) *)(&(x86_bios_cpu_apicid)))) (__ptr + (((__get___per_cpu_offset_437(&__per_cpu_offset[mps_cpu]))))); }); }));
 else
  return 0xFFFFu;
}

static inline int
__default_check_phys_apicid_present(int phys_apicid)
{
 return (__builtin_constant_p((phys_apicid)) ? constant_test_bit((phys_apicid), ((phys_cpu_present_map).mask)) : variable_test_bit((phys_apicid), ((phys_cpu_present_map).mask)));
}
extern int default_cpu_present_to_apicid(int mps_cpu);
extern int default_check_phys_apicid_present(int phys_apicid);



extern void irq_enter(void);
extern void irq_exit(void);

static inline void entering_irq(void)
{
 irq_enter();
 exit_idle();
}

static inline void entering_ack_irq(void)
{
 ack_APIC_irq();
 entering_irq();
}

static inline void exiting_irq(void)
{
 irq_exit();
}

static inline void exiting_ack_irq(void)
{
 irq_exit();

 ack_APIC_irq();
}

extern void ioapic_zap_locks(void);







static inline int invalid_vm86_irq(int irq)
{
 return irq < 3 || irq > 15;
}
union IO_APIC_reg_00 {
 u32 raw;
 struct {
  u32 __reserved_2 : 14,
   LTS : 1,
   delivery_type : 1,
   __reserved_1 : 8,
   ID : 8;
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed)) bits;
};

union IO_APIC_reg_01 {
 u32 raw;
 struct {
  u32 version : 8,
   __reserved_2 : 7,
   PRQ : 1,
   entries : 8,
   __reserved_1 : 8;
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed)) bits;
};

union IO_APIC_reg_02 {
 u32 raw;
 struct {
  u32 __reserved_2 : 24,
   arbitration : 4,
   __reserved_1 : 4;
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed)) bits;
};

union IO_APIC_reg_03 {
 u32 raw;
 struct {
  u32 boot_DT : 1,
   __reserved_1 : 31;
 
  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed)) bits;
};

struct IO_APIC_route_entry {
  template <typename, int = 0> struct __BYPASSIO_APIC_route_entry {};
  template <typename, int> friend struct __BYPASSIO_APIC_route_entry;
 __u32 vector : 8,
  delivery_mode : 3,



  dest_mode : 1,
  delivery_status : 1,
  polarity : 1,
  irr : 1,
  trigger : 1,
  mask : 1,
  __reserved_2 : 15;

 __u32 __reserved_3 : 24,
  dest : 8;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed));

struct IR_IO_APIC_route_entry {
  template <typename, int = 0> struct __BYPASSIR_IO_APIC_route_entry {};
  template <typename, int> friend struct __BYPASSIR_IO_APIC_route_entry;
 __u64 vector : 8,
  zero : 3,
  index2 : 1,
  delivery_status : 1,
  polarity : 1,
  irr : 1,
  trigger : 1,
  mask : 1,
  reserved : 31,
  format : 1,
  index : 15;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} __attribute__ ((packed));
extern int nr_ioapics;

extern int mpc_ioapic_id(int ioapic);
extern unsigned int mpc_ioapic_addr(int ioapic);
extern struct mp_ioapic_gsi *mp_ioapic_gsi_routing(int ioapic);




extern int mp_irq_entries;


extern struct mpc_intsrc mp_irqs[(256 * 4)];


extern int mpc_default_type;


extern int sis_apic_bug;


extern int skip_ioapic_setup;


extern int noioapicquirk;


extern int noioapicreroute;


extern int timer_through_8259;
struct io_apic_irq_attr;
struct irq_cfg;
extern int io_apic_set_pci_routing(struct device *dev, int irq,
   struct io_apic_irq_attr *irq_attr);
void setup_IO_APIC_irq_extra(u32 gsi);
extern void ioapic_insert_resources(void);

extern int native_setup_ioapic_entry(int, struct IO_APIC_route_entry *,
         unsigned int, int,
         struct io_apic_irq_attr *);
extern int native_setup_ioapic_entry(int, struct IO_APIC_route_entry *,
         unsigned int, int,
         struct io_apic_irq_attr *);
extern void eoi_ioapic_irq(unsigned int irq, struct irq_cfg *cfg);

extern void native_compose_msi_msg(struct pci_dev *pdev,
       unsigned int irq, unsigned int dest,
       struct msi_msg *msg, u8 hpet_id);
extern void native_eoi_ioapic_pin(int apic, int pin, int vector);
int io_apic_setup_irq_pin_once(unsigned int irq, int node, struct io_apic_irq_attr *attr);

extern int save_ioapic_entries(void);
extern void mask_ioapic_entries(void);
extern int restore_ioapic_entries(void);

extern int get_nr_irqs_gsi(void);

extern void setup_ioapic_ids_from_mpc(void);
extern void setup_ioapic_ids_from_mpc_nocheck(void);

struct mp_ioapic_gsi{
  template <typename, int = 0> struct __BYPASSmp_ioapic_gsi {};
  template <typename, int> friend struct __BYPASSmp_ioapic_gsi;
 u32 gsi_base;
 u32 gsi_end;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
extern struct mp_ioapic_gsi mp_gsi_routing[];
extern u32 gsi_top;
int mp_find_ioapic(u32 gsi);
int mp_find_ioapic_pin(int ioapic, u32 gsi);
void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) mp_register_ioapic(int id, u32 address, u32 gsi_base);
extern void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) pre_init_apic_IRQ0(void);

extern void mp_save_irq(struct mpc_intsrc *m);

extern void disable_ioapic_support(void);

extern void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) native_io_apic_init_mappings(void);
extern unsigned int native_io_apic_read(unsigned int apic, unsigned int reg);
extern void native_io_apic_write(unsigned int apic, unsigned int reg, unsigned int val);
extern void native_io_apic_modify(unsigned int apic, unsigned int reg, unsigned int val);
extern void native_disable_io_apic(void);
extern void native_io_apic_print_entries(unsigned int apic, unsigned int nr_entries);
extern void intel_ir_io_apic_print_entries(unsigned int apic, unsigned int nr_entries);
extern int native_ioapic_set_affinity(struct irq_data *,
          struct cpumask *,
          bool);

static inline unsigned int io_apic_read(unsigned int apic, unsigned int reg)
{
 return x86_io_apic_ops.read(apic, reg);
}

static inline void io_apic_write(unsigned int apic, unsigned int reg, unsigned int value)
{
 x86_io_apic_ops.write(apic, reg, value);
}
static inline void io_apic_modify(unsigned int apic, unsigned int reg, unsigned int value)
{
 x86_io_apic_ops.modify(apic, reg, value);
}

extern void io_apic_eoi(unsigned int apic, unsigned int vector);






extern int smp_num_siblings;
extern unsigned int num_processors;

static inline bool cpu_has_ht_siblings(void)
{
 bool has_siblings = _false;

 has_siblings = (__builtin_constant_p((0*32+28)) && ( ((((0*32+28))>>5)==0 && (1UL<<(((0*32+28))&31) & ((1<<((0*32+ 0) & 31))|0|(1<<((0*32+ 5) & 31))|(1<<((0*32+ 6) & 31))| (1<<((0*32+ 8) & 31))|0|(1<<((0*32+24) & 31))|(1<<((0*32+15) & 31))| (1<<((0*32+25) & 31))|(1<<((0*32+26) & 31))))) || ((((0*32+28))>>5)==1 && (1UL<<(((0*32+28))&31) & ((1<<((1*32+29) & 31))|0))) || ((((0*32+28))>>5)==2 && (1UL<<(((0*32+28))&31) & 0)) || ((((0*32+28))>>5)==3 && (1UL<<(((0*32+28))&31) & ((1<<((3*32+20) & 31))))) || ((((0*32+28))>>5)==4 && (1UL<<(((0*32+28))&31) & (0))) || ((((0*32+28))>>5)==5 && (1UL<<(((0*32+28))&31) & 0)) || ((((0*32+28))>>5)==6 && (1UL<<(((0*32+28))&31) & 0)) || ((((0*32+28))>>5)==7 && (1UL<<(((0*32+28))&31) & 0)) || ((((0*32+28))>>5)==8 && (1UL<<(((0*32+28))&31) & 0)) || ((((0*32+28))>>5)==9 && (1UL<<(((0*32+28))&31) & 0)) ) ? 1 : (__builtin_constant_p(((0*32+28))) ? constant_test_bit(((0*32+28)), ((unsigned long *)((&boot_cpu_data)->x86_capability))) : variable_test_bit(((0*32+28)), ((unsigned long *)((&boot_cpu_data)->x86_capability))))) && smp_num_siblings > 1;

 return has_siblings;
}

extern __attribute__((section(".data..percpu" "..readmostly"))) __typeof__(cpumask_var_t) cpu_sibling_map;
extern __attribute__((section(".data..percpu" "..readmostly"))) __typeof__(cpumask_var_t) cpu_core_map;

extern __attribute__((section(".data..percpu" "..readmostly"))) __typeof__(cpumask_var_t) cpu_llc_shared_map;
extern __attribute__((section(".data..percpu" "..readmostly"))) __typeof__(u16) cpu_llc_id;
extern __attribute__((section(".data..percpu" "..readmostly"))) __typeof__(int) cpu_number;


template <typename TResult, typename TThat, typename TTarget> struct TJP___per_cpu_offset_452_0 {
  typedef TJP___per_cpu_offset_452_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int __get___per_cpu_offset_452(unsigned long int *source) {
  unsigned long int __result_buffer;
  typedef TJP___per_cpu_offset_452_0< unsigned long int , void *, unsigned long int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int &)__result_buffer;
}
static inline struct cpumask *cpu_sibling_mask(int cpu)
{
 return (*({ do { void *__vpp_verify = (typeof(((&(cpu_sibling_map))) + 0))0; (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __asm__ ("" : "=r"(__ptr) : "0"((typeof(*(&(cpu_sibling_map))) *)(&(cpu_sibling_map)))); (typeof((typeof(*(&(cpu_sibling_map))) *)(&(cpu_sibling_map)))) (__ptr + (((__get___per_cpu_offset_452(&__per_cpu_offset[cpu]))))); }); }));
}


template <typename TResult, typename TThat, typename TTarget> struct TJP___per_cpu_offset_453_0 {
  typedef TJP___per_cpu_offset_453_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int __get___per_cpu_offset_453(unsigned long int *source) {
  unsigned long int __result_buffer;
  typedef TJP___per_cpu_offset_453_0< unsigned long int , void *, unsigned long int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int &)__result_buffer;
}
static inline struct cpumask *cpu_core_mask(int cpu)
{
 return (*({ do { void *__vpp_verify = (typeof(((&(cpu_core_map))) + 0))0; (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __asm__ ("" : "=r"(__ptr) : "0"((typeof(*(&(cpu_core_map))) *)(&(cpu_core_map)))); (typeof((typeof(*(&(cpu_core_map))) *)(&(cpu_core_map)))) (__ptr + (((__get___per_cpu_offset_453(&__per_cpu_offset[cpu]))))); }); }));
}


template <typename TResult, typename TThat, typename TTarget> struct TJP___per_cpu_offset_454_0 {
  typedef TJP___per_cpu_offset_454_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int __get___per_cpu_offset_454(unsigned long int *source) {
  unsigned long int __result_buffer;
  typedef TJP___per_cpu_offset_454_0< unsigned long int , void *, unsigned long int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int &)__result_buffer;
}
static inline struct cpumask *cpu_llc_shared_mask(int cpu)
{
 return (*({ do { void *__vpp_verify = (typeof(((&(cpu_llc_shared_map))) + 0))0; (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __asm__ ("" : "=r"(__ptr) : "0"((typeof(*(&(cpu_llc_shared_map))) *)(&(cpu_llc_shared_map)))); (typeof((typeof(*(&(cpu_llc_shared_map))) *)(&(cpu_llc_shared_map)))) (__ptr + (((__get___per_cpu_offset_454(&__per_cpu_offset[cpu]))))); }); }));
}

extern __attribute__((section(".data..percpu" "..readmostly"))) __typeof__(u16) x86_cpu_to_apicid; extern __typeof__(u16) *x86_cpu_to_apicid_early_ptr; extern __typeof__(u16) x86_cpu_to_apicid_early_map[];
extern __attribute__((section(".data..percpu" "..readmostly"))) __typeof__(u16) x86_bios_cpu_apicid; extern __typeof__(u16) *x86_bios_cpu_apicid_early_ptr; extern __typeof__(u16) x86_bios_cpu_apicid_early_map[];





extern unsigned long stack_start;

struct task_struct;

struct smp_ops {
  template <typename, int = 0> struct __BYPASSsmp_ops {};
  template <typename, int> friend struct __BYPASSsmp_ops;
 void (*smp_prepare_boot_cpu)(void);
 void (*smp_prepare_cpus)(unsigned max_cpus);
 void (*smp_cpus_done)(unsigned max_cpus);

 void (*stop_other_cpus)(int wait);
 void (*smp_send_reschedule)(int cpu);

 int (*cpu_up)(unsigned cpu, struct task_struct *tidle);
 int (*cpu_disable)(void);
 void (*cpu_die)(unsigned int cpu);
 void (*play_dead)(void);

 void (*send_call_func_ipi)( struct cpumask *mask);
 void (*send_call_func_single_ipi)(int cpu);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};


extern void set_cpu_sibling_map(int cpu);





extern struct smp_ops smp_ops;

static inline void smp_send_stop(void)
{
 smp_ops.stop_other_cpus(0);
}

static inline void stop_other_cpus(void)
{
 smp_ops.stop_other_cpus(1);
}

static inline void smp_prepare_boot_cpu(void)
{
 smp_ops.smp_prepare_boot_cpu();
}

static inline void smp_prepare_cpus(unsigned int max_cpus)
{
 smp_ops.smp_prepare_cpus(max_cpus);
}

static inline void smp_cpus_done(unsigned int max_cpus)
{
 smp_ops.smp_cpus_done(max_cpus);
}

static inline int __cpu_up(unsigned int cpu, struct task_struct *tidle)
{
 return smp_ops.cpu_up(cpu, tidle);
}

static inline int __cpu_disable(void)
{
 return smp_ops.cpu_disable();
}

static inline void __cpu_die(unsigned int cpu)
{
 smp_ops.cpu_die(cpu);
}

static inline void play_dead(void)
{
 smp_ops.play_dead();
}

static inline void smp_send_reschedule(int cpu)
{
 smp_ops.smp_send_reschedule(cpu);
}

static inline void arch_send_call_function_single_ipi(int cpu)
{
 smp_ops.send_call_func_single_ipi(cpu);
}

static inline void arch_send_call_function_ipi_mask( struct cpumask *mask)
{
 smp_ops.send_call_func_ipi(mask);
}

void cpu_disable_common(void);
void native_smp_prepare_boot_cpu(void);
void native_smp_prepare_cpus(unsigned int max_cpus);
void native_smp_cpus_done(unsigned int max_cpus);
int native_cpu_up(unsigned int cpunum, struct task_struct *tidle);
int native_cpu_disable(void);
void native_cpu_die(unsigned int cpu);
void native_play_dead(void);
void play_dead_common(void);
void wbinvd_on_cpu(int cpu);
int wbinvd_on_all_cpus(void);

void native_send_call_func_ipi( struct cpumask *mask);
void native_send_call_func_single_ipi(int cpu);
void x86_idle_thread_init(unsigned int cpu, struct task_struct *idle);

void smp_store_boot_cpu_info(void);
void smp_store_cpu_info(int id);
extern unsigned disabled_cpus;
extern int hard_smp_processor_id(void);

extern struct pglist_data *node_data[];



extern struct pglist_data *first_online_pgdat(void);
extern struct pglist_data *next_online_pgdat(struct pglist_data *pgdat);
extern struct zone *next_zone(struct zone *zone);
static inline struct zone *zonelist_zone(struct zoneref *zoneref)
{
 return zoneref->zone;
}

static inline int zonelist_zone_idx(struct zoneref *zoneref)
{
 return zoneref->zone_idx;
}

static inline int zonelist_node_idx(struct zoneref *zoneref)
{


 return zoneref->zone->node;



}
struct zoneref *next_zones_zonelist(struct zoneref *z,
     enum zone_type highest_zoneidx,
     nodemask_t *nodes,
     struct zone **zone);
static inline struct zoneref *first_zones_zonelist(struct zonelist *zonelist,
     enum zone_type highest_zoneidx,
     nodemask_t *nodes,
     struct zone **zone)
{
 return next_zones_zonelist(zonelist->_zonerefs, highest_zoneidx, nodes,
        zone);
}
struct page;
struct page_cgroup;
struct mem_section {
  template <typename, int = 0> struct __BYPASSmem_section {};
  template <typename, int> friend struct __BYPASSmem_section;
 unsigned long section_mem_map;


 unsigned long *pageblock_flags;





 struct page_cgroup *page_cgroup;
 unsigned long pad;






  friend class ::Introspect;
  friend class ::MyIntrospect;
};
extern struct mem_section *mem_section[((((1UL << (46 - 27))) + ((((1UL) << 12) / sizeof (struct mem_section))) - 1) / ((((1UL) << 12) / sizeof (struct mem_section))))];




static inline struct mem_section *__nr_to_section(unsigned long nr)
{
 if (!mem_section[((nr) / (((1UL) << 12) / sizeof (struct mem_section)))])
  return 0;
 return &mem_section[((nr) / (((1UL) << 12) / sizeof (struct mem_section)))][nr & ((((1UL) << 12) / sizeof (struct mem_section)) - 1)];
}
extern int __section_nr(struct mem_section* ms);
extern unsigned long usemap_size(void);
static inline struct page *__section_mem_map_addr(struct mem_section *section)
{
 unsigned long map = section->section_mem_map;
 map &= (~((1UL<<2)-1));
 return (struct page *)map;
}

static inline int present_section(struct mem_section *section)
{
 return (section && (section->section_mem_map & (1UL<<0)));
}

static inline int present_section_nr(unsigned long nr)
{
 return present_section(__nr_to_section(nr));
}

static inline int valid_section(struct mem_section *section)
{
 return (section && (section->section_mem_map & (1UL<<1)));
}

static inline int valid_section_nr(unsigned long nr)
{
 return valid_section(__nr_to_section(nr));
}

static inline struct mem_section *__pfn_to_section(unsigned long pfn)
{
 return __nr_to_section(((pfn) >> (27 - 12)));
}


static inline int pfn_valid(unsigned long pfn)
{
 if (((pfn) >> (27 - 12)) >= (1UL << (46 - 27)))
  return 0;
 return valid_section(__nr_to_section(((pfn) >> (27 - 12))));
}


static inline int pfn_present(unsigned long pfn)
{
 if (((pfn) >> (27 - 12)) >= (1UL << (46 - 27)))
  return 0;
 return present_section(__nr_to_section(((pfn) >> (27 - 12))));
}
void sparse_init(void);






bool early_pfn_in_nid(unsigned long pfn, int nid);
void memory_present(int nid, unsigned long start, unsigned long end);
unsigned long __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) node_memmap_size_bytes(int, unsigned long, unsigned long);
static inline int memmap_valid_within(unsigned long pfn,
     struct page *page, struct zone *zone)
{
 return 1;
}


extern void cpu_idle(void);

typedef void (*smp_call_func_t)(void *info);
struct call_single_data {
  template <typename, int = 0> struct __BYPASScall_single_data {};
  template <typename, int> friend struct __BYPASScall_single_data;
 struct list_head list;
 smp_call_func_t func;
 void *info;
 u16 flags;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};


extern unsigned int total_cpus;

int smp_call_function_single(int cpuid, smp_call_func_t func, void *info,
        int wait);




int on_each_cpu(smp_call_func_t func, void *info, int wait);





void on_each_cpu_mask( struct cpumask *mask, smp_call_func_t func,
  void *info, bool wait);






void on_each_cpu_cond(bool (*cond_func)(int cpu, void *info),
  smp_call_func_t func, void *info, bool wait,
  gfp_t gfp_flags);

void __smp_call_function_single(int cpuid, struct call_single_data *data,
    int wait);
extern void smp_send_stop(void);




extern void smp_send_reschedule(int cpu);





extern void smp_prepare_cpus(unsigned int max_cpus);




extern int __cpu_up(unsigned int cpunum, struct task_struct *tidle);




extern void smp_cpus_done(unsigned int max_cpus);




int smp_call_function(smp_call_func_t func, void *info, int wait);
void smp_call_function_many( struct cpumask *mask,
       smp_call_func_t func, void *info, bool wait);

int smp_call_function_any( struct cpumask *mask,
     smp_call_func_t func, void *info, int wait);

void kick_all_cpus_sync(void);




void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) call_function_init(void);
void generic_smp_call_function_single_interrupt(void);







void smp_prepare_boot_cpu(void);

extern unsigned int setup_max_cpus;
extern void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) setup_nr_cpu_ids(void);
extern void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) smp_init(void);
extern void arch_disable_smp_support(void);

void smp_setup_processor_id(void);






extern void *pcpu_base_addr;
extern unsigned long *pcpu_unit_offsets;

struct pcpu_group_info {
  template <typename, int = 0> struct __BYPASSpcpu_group_info {};
  template <typename, int> friend struct __BYPASSpcpu_group_info;
 int nr_units;
 unsigned long base_offset;
 unsigned int *cpu_map;


  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct pcpu_alloc_info {
  template <typename, int = 0> struct __BYPASSpcpu_alloc_info {};
  template <typename, int> friend struct __BYPASSpcpu_alloc_info;
 size_t static_size;
 size_t reserved_size;
 size_t dyn_size;
 size_t unit_size;
 size_t atom_size;
 size_t alloc_size;
 size_t __ai_size;
 int nr_groups;
 struct pcpu_group_info groups[];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

enum pcpu_fc {
 PCPU_FC_AUTO,
 PCPU_FC_EMBED,
 PCPU_FC_PAGE,

 PCPU_FC_NR,
};
extern char * pcpu_fc_names[PCPU_FC_NR];

extern enum pcpu_fc pcpu_chosen_fc;

typedef void * (*pcpu_fc_alloc_fn_t)(unsigned int cpu, size_t size,
         size_t align);
typedef void (*pcpu_fc_free_fn_t)(void *ptr, size_t size);
typedef void (*pcpu_fc_populate_pte_fn_t)(unsigned long addr);
typedef int (pcpu_fc_cpu_distance_fn_t)(unsigned int from, unsigned int to);

extern struct pcpu_alloc_info * __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) pcpu_alloc_alloc_info(int nr_groups,
            int nr_units);
extern void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) pcpu_free_alloc_info(struct pcpu_alloc_info *ai);

extern int __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) pcpu_setup_first_chunk( struct pcpu_alloc_info *ai,
      void *base_addr);


extern int __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) pcpu_embed_first_chunk(size_t reserved_size, size_t dyn_size,
    size_t atom_size,
    pcpu_fc_cpu_distance_fn_t cpu_distance_fn,
    pcpu_fc_alloc_fn_t alloc_fn,
    pcpu_fc_free_fn_t free_fn);



extern int __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) pcpu_page_first_chunk(size_t reserved_size,
    pcpu_fc_alloc_fn_t alloc_fn,
    pcpu_fc_free_fn_t free_fn,
    pcpu_fc_populate_pte_fn_t populate_pte_fn);
extern void *__alloc_reserved_percpu(size_t size, size_t align);
extern bool is_kernel_percpu_address(unsigned long addr);




extern void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) percpu_init_late(void);

extern void *__alloc_percpu(size_t size, size_t align);
extern void free_percpu(void *__pdata);
extern phys_addr_t per_cpu_ptr_to_phys(void *addr);
extern void __bad_size_call_parameter(void);
int arch_update_cpu_topology(void);
extern __attribute__((section(".data..percpu" ""))) __typeof__(int) numa_node;



static inline int numa_node_id(void)
{
 return ({ typeof((numa_node)) pscr_ret__; do { void *__vpp_verify = (typeof((&((numa_node))) + 0))0; (void)__vpp_verify; } while (0); switch(sizeof((numa_node))) { case 1: pscr_ret__ = ({ typeof(((numa_node))) pfo_ret__; switch (sizeof(((numa_node)))) { case 1: asm("mov" "b ""%%""gs"":" "%P" "1"",%0" : "=q" (pfo_ret__) : "m"((numa_node))); break; case 2: asm("mov" "w ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"((numa_node))); break; case 4: asm("mov" "l ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"((numa_node))); break; case 8: asm("mov" "q ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"((numa_node))); break; default: __bad_percpu_size(); } pfo_ret__; });break; case 2: pscr_ret__ = ({ typeof(((numa_node))) pfo_ret__; switch (sizeof(((numa_node)))) { case 1: asm("mov" "b ""%%""gs"":" "%P" "1"",%0" : "=q" (pfo_ret__) : "m"((numa_node))); break; case 2: asm("mov" "w ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"((numa_node))); break; case 4: asm("mov" "l ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"((numa_node))); break; case 8: asm("mov" "q ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"((numa_node))); break; default: __bad_percpu_size(); } pfo_ret__; });break; case 4: pscr_ret__ = ({ typeof(((numa_node))) pfo_ret__; switch (sizeof(((numa_node)))) { case 1: asm("mov" "b ""%%""gs"":" "%P" "1"",%0" : "=q" (pfo_ret__) : "m"((numa_node))); break; case 2: asm("mov" "w ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"((numa_node))); break; case 4: asm("mov" "l ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"((numa_node))); break; case 8: asm("mov" "q ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"((numa_node))); break; default: __bad_percpu_size(); } pfo_ret__; });break; case 8: pscr_ret__ = ({ typeof(((numa_node))) pfo_ret__; switch (sizeof(((numa_node)))) { case 1: asm("mov" "b ""%%""gs"":" "%P" "1"",%0" : "=q" (pfo_ret__) : "m"((numa_node))); break; case 2: asm("mov" "w ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"((numa_node))); break; case 4: asm("mov" "l ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"((numa_node))); break; case 8: asm("mov" "q ""%%""gs"":" "%P" "1"",%0" : "=r" (pfo_ret__) : "m"((numa_node))); break; default: __bad_percpu_size(); } pfo_ret__; });break; default: __bad_size_call_parameter();break; } pscr_ret__; });
}




template <typename TResult, typename TThat, typename TTarget> struct TJP___per_cpu_offset_490_0 {
  typedef TJP___per_cpu_offset_490_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int __get___per_cpu_offset_490(unsigned long int *source) {
  unsigned long int __result_buffer;
  typedef TJP___per_cpu_offset_490_0< unsigned long int , void *, unsigned long int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int &)__result_buffer;
}
static inline int cpu_to_node(int cpu)
{
 return (*({ do { void *__vpp_verify = (typeof(((&(numa_node))) + 0))0; (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __asm__ ("" : "=r"(__ptr) : "0"((typeof(*(&(numa_node))) *)(&(numa_node)))); (typeof((typeof(*(&(numa_node))) *)(&(numa_node)))) (__ptr + (((__get___per_cpu_offset_490(&__per_cpu_offset[cpu]))))); }); }));
}



static inline void set_numa_node(int node)
{
 do { do { void *__vpp_verify = (typeof((&((numa_node))) + 0))0; (void)__vpp_verify; } while (0); switch(sizeof((numa_node))) { case 1: do { typedef typeof(((numa_node))) pto_T__; if (0) { pto_T__ pto_tmp__; pto_tmp__ = ((node)); (void)pto_tmp__; } switch (sizeof(((numa_node)))) { case 1: asm("mov" "b %1,""%%""gs"":" "%P" "0" : "+m" (((numa_node))) : "qi" ((pto_T__)((node)))); break; case 2: asm("mov" "w %1,""%%""gs"":" "%P" "0" : "+m" (((numa_node))) : "ri" ((pto_T__)((node)))); break; case 4: asm("mov" "l %1,""%%""gs"":" "%P" "0" : "+m" (((numa_node))) : "ri" ((pto_T__)((node)))); break; case 8: asm("mov" "q %1,""%%""gs"":" "%P" "0" : "+m" (((numa_node))) : "re" ((pto_T__)((node)))); break; default: __bad_percpu_size(); } } while (0);break; case 2: do { typedef typeof(((numa_node))) pto_T__; if (0) { pto_T__ pto_tmp__; pto_tmp__ = ((node)); (void)pto_tmp__; } switch (sizeof(((numa_node)))) { case 1: asm("mov" "b %1,""%%""gs"":" "%P" "0" : "+m" (((numa_node))) : "qi" ((pto_T__)((node)))); break; case 2: asm("mov" "w %1,""%%""gs"":" "%P" "0" : "+m" (((numa_node))) : "ri" ((pto_T__)((node)))); break; case 4: asm("mov" "l %1,""%%""gs"":" "%P" "0" : "+m" (((numa_node))) : "ri" ((pto_T__)((node)))); break; case 8: asm("mov" "q %1,""%%""gs"":" "%P" "0" : "+m" (((numa_node))) : "re" ((pto_T__)((node)))); break; default: __bad_percpu_size(); } } while (0);break; case 4: do { typedef typeof(((numa_node))) pto_T__; if (0) { pto_T__ pto_tmp__; pto_tmp__ = ((node)); (void)pto_tmp__; } switch (sizeof(((numa_node)))) { case 1: asm("mov" "b %1,""%%""gs"":" "%P" "0" : "+m" (((numa_node))) : "qi" ((pto_T__)((node)))); break; case 2: asm("mov" "w %1,""%%""gs"":" "%P" "0" : "+m" (((numa_node))) : "ri" ((pto_T__)((node)))); break; case 4: asm("mov" "l %1,""%%""gs"":" "%P" "0" : "+m" (((numa_node))) : "ri" ((pto_T__)((node)))); break; case 8: asm("mov" "q %1,""%%""gs"":" "%P" "0" : "+m" (((numa_node))) : "re" ((pto_T__)((node)))); break; default: __bad_percpu_size(); } } while (0);break; case 8: do { typedef typeof(((numa_node))) pto_T__; if (0) { pto_T__ pto_tmp__; pto_tmp__ = ((node)); (void)pto_tmp__; } switch (sizeof(((numa_node)))) { case 1: asm("mov" "b %1,""%%""gs"":" "%P" "0" : "+m" (((numa_node))) : "qi" ((pto_T__)((node)))); break; case 2: asm("mov" "w %1,""%%""gs"":" "%P" "0" : "+m" (((numa_node))) : "ri" ((pto_T__)((node)))); break; case 4: asm("mov" "l %1,""%%""gs"":" "%P" "0" : "+m" (((numa_node))) : "ri" ((pto_T__)((node)))); break; case 8: asm("mov" "q %1,""%%""gs"":" "%P" "0" : "+m" (((numa_node))) : "re" ((pto_T__)((node)))); break; default: __bad_percpu_size(); } } while (0);break; default: __bad_size_call_parameter();break; } } while (0);
}



static inline void set_cpu_numa_node(int cpu, int node)
{
 (*({ do { void *__vpp_verify = (typeof(((&(numa_node))) + 0))0; (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __asm__ ("" : "=r"(__ptr) : "0"((typeof(*(&(numa_node))) *)(&(numa_node)))); (typeof((typeof(*(&(numa_node))) *)(&(numa_node)))) (__ptr + (((__per_cpu_offset[cpu])))); }); })) = node;
}
static inline int numa_mem_id(void)
{
 return numa_node_id();
}



static inline int cpu_to_mem(int cpu)
{
 return cpu_to_node(cpu);
}


struct vm_area_struct;
static inline int allocflags_to_migratetype(gfp_t gfp_flags)
{
 ((gfp_flags & ((( gfp_t)0x80000u)|(( gfp_t)0x08u))) == ((( gfp_t)0x80000u)|(( gfp_t)0x08u)));

 if (__builtin_expect(!!(page_group_by_mobility_disabled), 0))
  return MIGRATE_UNMOVABLE;


 return (((gfp_flags & (( gfp_t)0x08u)) != 0) << 1) |
  ((gfp_flags & (( gfp_t)0x80000u)) != 0);
}
static inline enum zone_type gfp_zone(gfp_t flags)
{
 enum zone_type z;
 int bit = ( int) (flags & ((( gfp_t)0x01u)|(( gfp_t)0x02u)|(( gfp_t)0x04u)|(( gfp_t)0x08u)));

 z = (( (ZONE_NORMAL << 0 * 2) | (ZONE_DMA << 0x01u * 2) | (ZONE_NORMAL << 0x02u * 2) | (ZONE_DMA32 << 0x04u * 2) | (ZONE_NORMAL << 0x08u * 2) | (ZONE_DMA << (0x08u | 0x01u) * 2) | (ZONE_MOVABLE << (0x08u | 0x02u) * 2) | (ZONE_DMA32 << (0x08u | 0x04u) * 2) ) >> (bit * 2)) &
      ((1 << 2) - 1);
 (0);
 return z;
}
static inline int gfp_zonelist(gfp_t flags)
{
 if ((1 || 0) && __builtin_expect(!!(flags & (( gfp_t)0x40000u)), 0))
  return 1;

 return 0;
}
static inline struct zonelist *node_zonelist(int nid, gfp_t flags)
{
 return (node_data[nid])->node_zonelists + gfp_zonelist(flags);
}


static inline void arch_free_page(struct page *page, int order) { }


static inline void arch_alloc_page(struct page *page, int order) { }


struct page *
__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order,
         struct zonelist *zonelist, nodemask_t *nodemask);

static inline struct page *
__alloc_pages(gfp_t gfp_mask, unsigned int order,
  struct zonelist *zonelist)
{
 return __alloc_pages_nodemask(gfp_mask, order, zonelist, 0);
}

static inline struct page *alloc_pages_node(int nid, gfp_t gfp_mask,
      unsigned int order)
{

 if (nid < 0)
  nid = numa_node_id();

 return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask));
}

static inline struct page *alloc_pages_exact_node(int nid, gfp_t gfp_mask,
      unsigned int order)
{
 (0);

 return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask));
}


extern struct page *alloc_pages_current(gfp_t gfp_mask, unsigned order);

static inline struct page *
alloc_pages(gfp_t gfp_mask, unsigned int order)
{
 return alloc_pages_current(gfp_mask, order);
}
extern struct page *alloc_pages_vma(gfp_t gfp_mask, int order,
   struct vm_area_struct *vma, unsigned long addr,
   int node);
extern unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order);
extern unsigned long get_zeroed_page(gfp_t gfp_mask);

void *alloc_pages_exact(size_t size, gfp_t gfp_mask);
void free_pages_exact(void *virt, size_t size);

void *alloc_pages_exact_nid(int nid, size_t size, gfp_t gfp_mask);







extern void __free_pages(struct page *page, unsigned int order);
extern void free_pages(unsigned long addr, unsigned int order);
extern void free_hot_cold_page(struct page *page, int cold);
extern void free_hot_cold_page_list(struct list_head *list, int cold);

extern void __free_memcg_kmem_pages(struct page *page, unsigned int order);
extern void free_memcg_kmem_pages(unsigned long addr, unsigned int order);




void page_alloc_init(void);
void drain_zone_pages(struct zone *zone, struct per_cpu_pages *pcp);
void drain_all_pages(void);
void drain_local_pages(void *dummy);
extern gfp_t gfp_allowed_mask;


bool gfp_pfmemalloc_allowed(gfp_t gfp_mask);

extern void pm_restrict_gfp_mask(void);
extern void pm_restore_gfp_mask(void);


extern bool pm_suspended_storage(void);
extern int alloc_contig_range(unsigned long start, unsigned long end,
         unsigned migratetype);
extern void free_contig_range(unsigned long pfn, unsigned nr_pages);


extern void init_cma_reserved_pageblock(struct page *page);
static inline void kmemleak_init(void)
{
}
static inline void kmemleak_alloc( void *ptr, size_t size, int min_count,
      gfp_t gfp)
{
}
static inline void kmemleak_alloc_recursive( void *ptr, size_t size,
         int min_count, unsigned long flags,
         gfp_t gfp)
{
}
static inline void kmemleak_alloc_percpu( void *ptr, size_t size)
{
}
static inline void kmemleak_free( void *ptr)
{
}
static inline void kmemleak_free_part( void *ptr, size_t size)
{
}
static inline void kmemleak_free_recursive( void *ptr, unsigned long flags)
{
}
static inline void kmemleak_free_percpu( void *ptr)
{
}
static inline void kmemleak_not_leak( void *ptr)
{
}
static inline void kmemleak_ignore( void *ptr)
{
}
static inline void kmemleak_scan_area( void *ptr, size_t size, gfp_t gfp)
{
}
static inline void kmemleak_erase(void **ptr)
{
}
static inline void kmemleak_no_scan( void *ptr)
{
}

struct mem_cgroup;



void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) kmem_cache_init(void);
int slab_is_available(void);

struct kmem_cache *kmem_cache_create( char *, size_t, size_t,
   unsigned long,
   void (*)(void *));
struct kmem_cache *
kmem_cache_create_memcg(struct mem_cgroup *, char *, size_t, size_t,
   unsigned long, void (*)(void *), struct kmem_cache *);
void kmem_cache_destroy(struct kmem_cache *);
int kmem_cache_shrink(struct kmem_cache *);
void kmem_cache_free(struct kmem_cache *, void *);
void * __krealloc( void *, size_t, gfp_t);
void * krealloc( void *, size_t, gfp_t);
void kfree( void *);
void kzfree( void *);
size_t ksize( void *);
extern struct kmem_cache *kmalloc_caches[(12 + 1) + 1];

extern struct kmem_cache *kmalloc_dma_caches[(12 + 1) + 1];
static inline __attribute__((always_inline)) int kmalloc_index(size_t size)
{
 if (!size)
  return 0;

 if (size <= (1 << 3))
  return 3;

 if ((1 << 3) <= 32 && size > 64 && size <= 96)
  return 1;
 if ((1 << 3) <= 64 && size > 128 && size <= 192)
  return 2;
 if (size <= 8) return 3;
 if (size <= 16) return 4;
 if (size <= 32) return 5;
 if (size <= 64) return 6;
 if (size <= 128) return 7;
 if (size <= 256) return 8;
 if (size <= 512) return 9;
 if (size <= 1024) return 10;
 if (size <= 2 * 1024) return 11;
 if (size <= 4 * 1024) return 12;
 if (size <= 8 * 1024) return 13;
 if (size <= 16 * 1024) return 14;
 if (size <= 32 * 1024) return 15;
 if (size <= 64 * 1024) return 16;
 if (size <= 128 * 1024) return 17;
 if (size <= 256 * 1024) return 18;
 if (size <= 512 * 1024) return 19;
 if (size <= 1024 * 1024) return 20;
 if (size <= 2 * 1024 * 1024) return 21;
 if (size <= 4 * 1024 * 1024) return 22;
 if (size <= 8 * 1024 * 1024) return 23;
 if (size <= 16 * 1024 * 1024) return 24;
 if (size <= 32 * 1024 * 1024) return 25;
 if (size <= 64 * 1024 * 1024) return 26;
 ;


 return -1;
}


void *__kmalloc(size_t size, gfp_t flags);
void *kmem_cache_alloc(struct kmem_cache *, gfp_t flags);


void *__kmalloc_node(size_t size, gfp_t flags, int node);
void *kmem_cache_alloc_node(struct kmem_cache *, gfp_t flags, int node);
extern void *kmem_cache_alloc_trace(struct kmem_cache *, gfp_t, size_t);


extern void *kmem_cache_alloc_node_trace(struct kmem_cache *s,
        gfp_t gfpflags,
        int node, size_t size);
struct sock;
struct kobject;





enum kobj_ns_type {
 KOBJ_NS_TYPE_NONE = 0,
 KOBJ_NS_TYPE_NET,
 KOBJ_NS_TYPES
};
struct kobj_ns_type_operations {
  template <typename, int = 0> struct __BYPASSkobj_ns_type_operations {};
  template <typename, int> friend struct __BYPASSkobj_ns_type_operations;
 enum kobj_ns_type type;
 bool (*current_may_mount)(void);
 void *(*grab_current_ns)(void);
 void *(*netlink_ns)(struct sock *sk);
 void *(*initial_ns)(void);
 void (*drop_ns)(void *);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

int kobj_ns_type_register( struct kobj_ns_type_operations *ops);
int kobj_ns_type_registered(enum kobj_ns_type type);
 struct kobj_ns_type_operations *kobj_child_ns_ops(struct kobject *parent);
 struct kobj_ns_type_operations *kobj_ns_ops(struct kobject *kobj);

bool kobj_ns_current_may_mount(enum kobj_ns_type type);
void *kobj_ns_grab_current(enum kobj_ns_type type);
 void *kobj_ns_netlink(enum kobj_ns_type type, struct sock *sk);
 void *kobj_ns_initial(enum kobj_ns_type type);
void kobj_ns_drop(enum kobj_ns_type type, void *ns);




struct stat {
  template <typename, int = 0> struct __BYPASSstat {};
  template <typename, int> friend struct __BYPASSstat;
 unsigned long st_dev;
 unsigned long st_ino;
 unsigned long st_nlink;

 unsigned int st_mode;
 unsigned int st_uid;
 unsigned int st_gid;
 unsigned int __pad0;
 unsigned long st_rdev;
 long st_size;
 long st_blksize;
 long st_blocks;

 unsigned long st_atime;
 unsigned long st_atime_nsec;
 unsigned long st_mtime;
 unsigned long st_mtime_nsec;
 unsigned long st_ctime;
 unsigned long st_ctime_nsec;
 long __unused[3];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct __old_kernel_stat {
  template <typename, int = 0> struct __BYPASS__old_kernel_stat {};
  template <typename, int> friend struct __BYPASS__old_kernel_stat;
 unsigned short st_dev;
 unsigned short st_ino;
 unsigned short st_mode;
 unsigned short st_nlink;
 unsigned short st_uid;
 unsigned short st_gid;
 unsigned short st_rdev;






 unsigned int st_size;
 unsigned int st_atime;
 unsigned int st_mtime;
 unsigned int st_ctime;


  friend class ::Introspect;
  friend class ::MyIntrospect;
};
extern int overflowuid;
extern int overflowgid;

extern void __bad_uid(void);
extern void __bad_gid(void);
extern int fs_overflowuid;
extern int fs_overflowgid;

struct user_namespace;
extern struct user_namespace init_user_ns;



typedef struct {
 uid_t val;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} kuid_t;


typedef struct {
 gid_t val;

  friend class ::Introspect;
  friend class ::MyIntrospect;
} kgid_t;




static inline uid_t __kuid_val(kuid_t uid)
{
 return uid.val;
}

static inline gid_t __kgid_val(kgid_t gid)
{
 return gid.val;
}
static inline bool uid_eq(kuid_t left, kuid_t right)
{
 return __kuid_val(left) == __kuid_val(right);
}

static inline bool gid_eq(kgid_t left, kgid_t right)
{
 return __kgid_val(left) == __kgid_val(right);
}

static inline bool uid_gt(kuid_t left, kuid_t right)
{
 return __kuid_val(left) > __kuid_val(right);
}

static inline bool gid_gt(kgid_t left, kgid_t right)
{
 return __kgid_val(left) > __kgid_val(right);
}

static inline bool uid_gte(kuid_t left, kuid_t right)
{
 return __kuid_val(left) >= __kuid_val(right);
}

static inline bool gid_gte(kgid_t left, kgid_t right)
{
 return __kgid_val(left) >= __kgid_val(right);
}

static inline bool uid_lt(kuid_t left, kuid_t right)
{
 return __kuid_val(left) < __kuid_val(right);
}

static inline bool gid_lt(kgid_t left, kgid_t right)
{
 return __kgid_val(left) < __kgid_val(right);
}

static inline bool uid_lte(kuid_t left, kuid_t right)
{
 return __kuid_val(left) <= __kuid_val(right);
}

static inline bool gid_lte(kgid_t left, kgid_t right)
{
 return __kgid_val(left) <= __kgid_val(right);
}

static inline bool uid_valid(kuid_t uid)
{
 return !uid_eq(uid, (kuid_t){ -1 });
}

static inline bool gid_valid(kgid_t gid)
{
 return !gid_eq(gid, (kgid_t){ -1 });
}



extern kuid_t make_kuid(struct user_namespace *from, uid_t uid);
extern kgid_t make_kgid(struct user_namespace *from, gid_t gid);

extern uid_t from_kuid(struct user_namespace *to, kuid_t uid);
extern gid_t from_kgid(struct user_namespace *to, kgid_t gid);
extern uid_t from_kuid_munged(struct user_namespace *to, kuid_t uid);
extern gid_t from_kgid_munged(struct user_namespace *to, kgid_t gid);

static inline bool kuid_has_mapping(struct user_namespace *ns, kuid_t uid)
{
 return from_kuid(ns, uid) != (uid_t) -1;
}

static inline bool kgid_has_mapping(struct user_namespace *ns, kgid_t gid)
{
 return from_kgid(ns, gid) != (gid_t) -1;
}

struct kstat {
  template <typename, int = 0> struct __BYPASSkstat {};
  template <typename, int> friend struct __BYPASSkstat;
 u64 ino;
 dev_t dev;
 umode_t mode;
 unsigned int nlink;
 kuid_t uid;
 kgid_t gid;
 dev_t rdev;
 loff_t size;
 struct timespec atime;
 struct timespec mtime;
 struct timespec ctime;
 unsigned long blksize;
 unsigned long long blocks;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};


struct kobject;
struct module;
struct bin_attribute;
enum kobj_ns_type;

struct attribute {
  template <typename, int = 0> struct __BYPASSattribute {};
  template <typename, int> friend struct __BYPASSattribute;
 char *name;
 umode_t mode;






  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct attribute_group {
  template <typename, int = 0> struct __BYPASSattribute_group {};
  template <typename, int> friend struct __BYPASSattribute_group;
 char *name;
 umode_t (*is_visible)(struct kobject *,
           struct attribute *, int);
 struct attribute **attrs;
 struct bin_attribute **bin_attrs;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct file;
struct vm_area_struct;

struct bin_attribute {
  template <typename, int = 0> struct __BYPASSbin_attribute {};
  template <typename, int> friend struct __BYPASSbin_attribute;
 struct attribute attr;
 size_t size;
 void *_private;
 ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *,
   char *, loff_t, size_t);
 ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *,
    char *, loff_t, size_t);
 int (*mmap)(struct file *, struct kobject *, struct bin_attribute *attr,
      struct vm_area_struct *vma);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};
struct sysfs_ops {
  template <typename, int = 0> struct __BYPASSsysfs_ops {};
  template <typename, int> friend struct __BYPASSsysfs_ops;
 ssize_t (*show)(struct kobject *, struct attribute *, char *);
 ssize_t (*store)(struct kobject *, struct attribute *, char *, size_t);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct sysfs_dirent;



int sysfs_schedule_callback(struct kobject *kobj, void (*func)(void *),
       void *data, struct module *owner);

int sysfs_create_dir_ns(struct kobject *kobj, void *ns);
void sysfs_remove_dir(struct kobject *kobj);
int sysfs_rename_dir_ns(struct kobject *kobj, char *new_name,
         void *new_ns);
int sysfs_move_dir_ns(struct kobject *kobj,
       struct kobject *new_parent_kobj,
       void *new_ns);

int sysfs_create_file_ns(struct kobject *kobj,
          struct attribute *attr,
          void *ns);
int sysfs_create_files(struct kobject *kobj,
       struct attribute **attr);
int sysfs_chmod_file(struct kobject *kobj,
      struct attribute *attr, umode_t mode);
void sysfs_remove_file_ns(struct kobject *kobj, struct attribute *attr,
     void *ns);
void sysfs_remove_files(struct kobject *kobj, struct attribute **attr);

int sysfs_create_bin_file(struct kobject *kobj,
           struct bin_attribute *attr);
void sysfs_remove_bin_file(struct kobject *kobj,
      struct bin_attribute *attr);

int sysfs_create_link(struct kobject *kobj, struct kobject *target,
       char *name);
int sysfs_create_link_nowarn(struct kobject *kobj,
       struct kobject *target,
       char *name);
void sysfs_remove_link(struct kobject *kobj, char *name);

int sysfs_rename_link_ns(struct kobject *kobj, struct kobject *target,
    char *old_name, char *new_name,
    void *new_ns);

void sysfs_delete_link(struct kobject *dir, struct kobject *targ,
   char *name);

int sysfs_create_group(struct kobject *kobj,
        struct attribute_group *grp);
int sysfs_create_groups(struct kobject *kobj,
         struct attribute_group **groups);
int sysfs_update_group(struct kobject *kobj,
         struct attribute_group *grp);
void sysfs_remove_group(struct kobject *kobj,
   struct attribute_group *grp);
void sysfs_remove_groups(struct kobject *kobj,
    struct attribute_group **groups);
int sysfs_add_file_to_group(struct kobject *kobj,
   struct attribute *attr, char *group);
void sysfs_remove_file_from_group(struct kobject *kobj,
   struct attribute *attr, char *group);
int sysfs_merge_group(struct kobject *kobj,
         struct attribute_group *grp);
void sysfs_unmerge_group(struct kobject *kobj,
         struct attribute_group *grp);
int sysfs_add_link_to_group(struct kobject *kobj, char *group_name,
       struct kobject *target, char *link_name);
void sysfs_remove_link_from_group(struct kobject *kobj, char *group_name,
      char *link_name);

void sysfs_notify(struct kobject *kobj, char *dir, char *attr);
void sysfs_notify_dirent(struct sysfs_dirent *sd);
struct sysfs_dirent *sysfs_get_dirent_ns(struct sysfs_dirent *parent_sd,
      unsigned char *name,
      void *ns);
struct sysfs_dirent *sysfs_get(struct sysfs_dirent *sd);
void sysfs_put(struct sysfs_dirent *sd);

int sysfs_init(void);
static inline int sysfs_create_file(struct kobject *kobj,
       struct attribute *attr)
{
 return sysfs_create_file_ns(kobj, attr, 0);
}

static inline void sysfs_remove_file(struct kobject *kobj,
         struct attribute *attr)
{
 return sysfs_remove_file_ns(kobj, attr, 0);
}

static inline int sysfs_rename_link(struct kobject *kobj, struct kobject *target,
        char *old_name, char *new_name)
{
 return sysfs_rename_link_ns(kobj, target, old_name, new_name, 0);
}

static inline struct sysfs_dirent *
sysfs_get_dirent(struct sysfs_dirent *parent_sd, unsigned char *name)
{
 return sysfs_get_dirent_ns(parent_sd, name, 0);
}


struct kref {
  template <typename, int = 0> struct __BYPASSkref {};
  template <typename, int> friend struct __BYPASSkref;
 atomic_t refcount;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};





static inline void kref_init(struct kref *kref)
{
 ;
}






template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7_atomic7counterE_505_0 {
  typedef TJP__ZN7_atomic7counterE_505_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline int __get__ZN7_atomic7counterE_505(int *source) {
  int __result_buffer;
  typedef TJP__ZN7_atomic7counterE_505_0< int , ::_atomic , int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (int &)__result_buffer;
}
static inline void kref_get(struct kref *kref)
{




 (((__get__ZN7_atomic7counterE_505(&(&kref->refcount)->counter) + (1))) < 2);
}
static inline int kref_sub(struct kref *kref, unsigned int count,
      void (*release)(struct kref *kref))
{
 (release == 0);

 if (1) {
  release(kref);
  return 1;
 }
 return 0;
}
static inline int kref_put(struct kref *kref, void (*release)(struct kref *kref))
{
 return kref_sub(kref, 1, release);
}
static inline int kref_put_spinlock_irqsave(struct kref *kref,
  void (*release)(struct kref *kref),
  spinlock_t *lock)
{
 unsigned long flags;

 (release == 0);
 if (atomic_add_unless(&kref->refcount, -1, 1))
  return 0;
 ;
 if (1) {
  release(kref);
  ;
  return 1;
 }
 ;
 return 0;
}

static inline int kref_put_mutex(struct kref *kref,
     void (*release)(struct kref *kref),
     struct mutex *lock)
{
 (release == 0);
 if (__builtin_expect(!!(!atomic_add_unless(&kref->refcount, -1, 1)), 0)) {
  ;
  if (__builtin_expect(!!(!1), 0)) {
   ;
   return 0;
  }
  release(kref);
  return 1;
 }
 return 0;
}
static inline int kref_get_unless_zero(struct kref *kref)
{
 return atomic_add_unless(&kref->refcount, 1, 0);
}
extern char uevent_helper[];


extern u64 uevent_seqnum;
enum kobject_action {
 KOBJ_ADD,
 KOBJ_REMOVE,
 KOBJ_CHANGE,
 KOBJ_MOVE,
 KOBJ_ONLINE,
 KOBJ_OFFLINE,
 KOBJ_MAX
};

struct kobject {
  template <typename, int = 0> struct __BYPASSkobject {};
  template <typename, int> friend struct __BYPASSkobject;
 char *name;
 struct list_head entry;
 struct kobject *parent;
 struct kset *kset;
 struct kobj_type *ktype;
 struct sysfs_dirent *sd;
 struct kref kref;



 unsigned int state_initialized:1;
 unsigned int state_in_sysfs:1;
 unsigned int state_add_uevent_sent:1;
 unsigned int state_remove_uevent_sent:1;
 unsigned int uevent_suppress:1;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

extern __attribute__((format(printf, 2, 3)))
int kobject_set_name(struct kobject *kobj, char *name, ...);
extern int kobject_set_name_vargs(struct kobject *kobj, char *fmt,
      va_list vargs);

static inline char *kobject_name( struct kobject *kobj)
{
 return kobj->name;
}

extern void kobject_init(struct kobject *kobj, struct kobj_type *ktype);
extern __attribute__((format(printf, 3, 4)))
int kobject_add(struct kobject *kobj, struct kobject *parent,
  char *fmt, ...);
extern __attribute__((format(printf, 4, 5)))
int kobject_init_and_add(struct kobject *kobj,
    struct kobj_type *ktype, struct kobject *parent,
    char *fmt, ...);

extern void kobject_del(struct kobject *kobj);

extern struct kobject * kobject_create(void);
extern struct kobject * kobject_create_and_add( char *name,
      struct kobject *parent);

extern int kobject_rename(struct kobject *, char *new_name);
extern int kobject_move(struct kobject *, struct kobject *);

extern struct kobject *kobject_get(struct kobject *kobj);
extern void kobject_put(struct kobject *kobj);

extern void *kobject_namespace(struct kobject *kobj);
extern char *kobject_get_path(struct kobject *kobj, gfp_t flag);

struct kobj_type {
  template <typename, int = 0> struct __BYPASSkobj_type {};
  template <typename, int> friend struct __BYPASSkobj_type;
 void (*release)(struct kobject *kobj);
 struct sysfs_ops *sysfs_ops;
 struct attribute **default_attrs;
 struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj);
 void *(*_namespace)(struct kobject *kobj);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct kobj_uevent_env {
  template <typename, int = 0> struct __BYPASSkobj_uevent_env {};
  template <typename, int> friend struct __BYPASSkobj_uevent_env;
 char *envp[32];
 int envp_idx;
 char buf[2048];
 int buflen;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct kset_uevent_ops {
  template <typename, int = 0> struct __BYPASSkset_uevent_ops {};
  template <typename, int> friend struct __BYPASSkset_uevent_ops;
 int (* filter)(struct kset *kset, struct kobject *kobj);
 char *(* name)(struct kset *kset, struct kobject *kobj);
 int (* uevent)(struct kset *kset, struct kobject *kobj,
        struct kobj_uevent_env *env);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

struct kobj_attribute {
  template <typename, int = 0> struct __BYPASSkobj_attribute {};
  template <typename, int> friend struct __BYPASSkobj_attribute;
 struct attribute attr;
 ssize_t (*show)(struct kobject *kobj, struct kobj_attribute *attr,
   char *buf);
 ssize_t (*store)(struct kobject *kobj, struct kobj_attribute *attr,
    char *buf, size_t count);

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

extern struct sysfs_ops kobj_sysfs_ops;

struct sock;
struct kset {
  template <typename, int = 0> struct __BYPASSkset {};
  template <typename, int> friend struct __BYPASSkset;
 struct list_head list;
 spinlock_t list_lock;
 struct kobject kobj;
 struct kset_uevent_ops *uevent_ops;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

extern void kset_init(struct kset *kset);
extern int kset_register(struct kset *kset);
extern void kset_unregister(struct kset *kset);
extern struct kset * kset_create_and_add( char *name,
      struct kset_uevent_ops *u,
      struct kobject *parent_kobj);

static inline struct kset *to_kset(struct kobject *kobj)
{
 return kobj ? ({ typeof( ((struct kset *)0)->kobj ) *__mptr = (kobj); (struct kset *)( (char *)__mptr - ((size_t) &((struct kset *)0)->kobj) );}) : 0;
}

static inline struct kset *kset_get(struct kset *k)
{
 return k ? to_kset(kobject_get(&k->kobj)) : 0;
}

static inline void kset_put(struct kset *k)
{
 kobject_put(&k->kobj);
}

static inline struct kobj_type *get_ktype(struct kobject *kobj)
{
 return kobj->ktype;
}

extern struct kobject *kset_find_obj(struct kset *, char *);


extern struct kobject *kernel_kobj;

extern struct kobject *mm_kobj;

extern struct kobject *hypervisor_kobj;

extern struct kobject *power_kobj;

extern struct kobject *firmware_kobj;

int kobject_uevent(struct kobject *kobj, enum kobject_action action);
int kobject_uevent_env(struct kobject *kobj, enum kobject_action action,
   char *envp[]);

__attribute__((format(printf, 2, 3)))
int add_uevent_var(struct kobj_uevent_env *env, char *format, ...);

int kobject_action_type( char *buf, size_t count,
   enum kobject_action *type);

enum stat_item {
 ALLOC_FASTPATH,
 ALLOC_SLOWPATH,
 FREE_FASTPATH,
 FREE_SLOWPATH,
 FREE_FROZEN,
 FREE_ADD_PARTIAL,
 FREE_REMOVE_PARTIAL,
 ALLOC_FROM_PARTIAL,
 ALLOC_SLAB,
 ALLOC_REFILL,
 ALLOC_NODE_MISMATCH,
 FREE_SLAB,
 CPUSLAB_FLUSH,
 DEACTIVATE_FULL,
 DEACTIVATE_EMPTY,
 DEACTIVATE_TO_HEAD,
 DEACTIVATE_TO_TAIL,
 DEACTIVATE_REMOTE_FREES,
 DEACTIVATE_BYPASS,
 ORDER_FALLBACK,
 CMPXCHG_DOUBLE_CPU_FAIL,
 CMPXCHG_DOUBLE_FAIL,
 CPU_PARTIAL_ALLOC,
 CPU_PARTIAL_FREE,
 CPU_PARTIAL_NODE,
 CPU_PARTIAL_DRAIN,
 NR_SLUB_STAT_ITEMS };

struct kmem_cache_cpu {
  template <typename, int = 0> struct __BYPASSkmem_cache_cpu {};
  template <typename, int> friend struct __BYPASSkmem_cache_cpu;
 void **freelist;
 unsigned long tid;
 struct page *page;
 struct page *partial;




  friend class ::Introspect;
  friend class ::MyIntrospect;
};






struct kmem_cache_order_objects {
  template <typename, int = 0> struct __BYPASSkmem_cache_order_objects {};
  template <typename, int> friend struct __BYPASSkmem_cache_order_objects;
 unsigned long x;

  friend class ::Introspect;
  friend class ::MyIntrospect;
};




struct kmem_cache {
  template <typename, int = 0> struct __BYPASSkmem_cache {};
  template <typename, int> friend struct __BYPASSkmem_cache;
 struct kmem_cache_cpu *cpu_slab;

 unsigned long flags;
 unsigned long min_partial;
 int size;
 int object_size;
 int offset;
 int cpu_partial;
 struct kmem_cache_order_objects oo;


 struct kmem_cache_order_objects max;
 struct kmem_cache_order_objects min;
 gfp_t allocflags;
 int refcount;
 void (*ctor)(void *);
 int inuse;
 int align;
 int reserved;
 char *name;
 struct list_head list;

 struct kobject kobj;
 int remote_node_defrag_ratio;

 struct kmem_cache_node *node[(1 << 6)];

  friend class ::Introspect;
  friend class ::MyIntrospect;
};


static inline __attribute__((always_inline)) void *
kmalloc_order(size_t size, gfp_t flags, unsigned int order)
{
 void *ret;

 flags |= ((( gfp_t)0x4000u) | (( gfp_t)0x100000u));
 ret = (void *) __get_free_pages(flags, order);
 kmemleak_alloc(ret, size, 1, flags);
 return ret;
}


extern void *kmalloc_order_trace(size_t size, gfp_t flags, unsigned int order);
static inline __attribute__((always_inline)) void *kmalloc_large(size_t size, gfp_t flags)
{
 unsigned int order = ( __builtin_constant_p(size) ? ( ((size) == 0UL) ? 64 - 12 : (((size) < (1UL << 12)) ? 0 : ( __builtin_constant_p((size) - 1) ? ( ((size) - 1) < 1 ? ____ilog2_NaN() : ((size) - 1) & (1ULL << 63) ? 63 : ((size) - 1) & (1ULL << 62) ? 62 : ((size) - 1) & (1ULL << 61) ? 61 : ((size) - 1) & (1ULL << 60) ? 60 : ((size) - 1) & (1ULL << 59) ? 59 : ((size) - 1) & (1ULL << 58) ? 58 : ((size) - 1) & (1ULL << 57) ? 57 : ((size) - 1) & (1ULL << 56) ? 56 : ((size) - 1) & (1ULL << 55) ? 55 : ((size) - 1) & (1ULL << 54) ? 54 : ((size) - 1) & (1ULL << 53) ? 53 : ((size) - 1) & (1ULL << 52) ? 52 : ((size) - 1) & (1ULL << 51) ? 51 : ((size) - 1) & (1ULL << 50) ? 50 : ((size) - 1) & (1ULL << 49) ? 49 : ((size) - 1) & (1ULL << 48) ? 48 : ((size) - 1) & (1ULL << 47) ? 47 : ((size) - 1) & (1ULL << 46) ? 46 : ((size) - 1) & (1ULL << 45) ? 45 : ((size) - 1) & (1ULL << 44) ? 44 : ((size) - 1) & (1ULL << 43) ? 43 : ((size) - 1) & (1ULL << 42) ? 42 : ((size) - 1) & (1ULL << 41) ? 41 : ((size) - 1) & (1ULL << 40) ? 40 : ((size) - 1) & (1ULL << 39) ? 39 : ((size) - 1) & (1ULL << 38) ? 38 : ((size) - 1) & (1ULL << 37) ? 37 : ((size) - 1) & (1ULL << 36) ? 36 : ((size) - 1) & (1ULL << 35) ? 35 : ((size) - 1) & (1ULL << 34) ? 34 : ((size) - 1) & (1ULL << 33) ? 33 : ((size) - 1) & (1ULL << 32) ? 32 : ((size) - 1) & (1ULL << 31) ? 31 : ((size) - 1) & (1ULL << 30) ? 30 : ((size) - 1) & (1ULL << 29) ? 29 : ((size) - 1) & (1ULL << 28) ? 28 : ((size) - 1) & (1ULL << 27) ? 27 : ((size) - 1) & (1ULL << 26) ? 26 : ((size) - 1) & (1ULL << 25) ? 25 : ((size) - 1) & (1ULL << 24) ? 24 : ((size) - 1) & (1ULL << 23) ? 23 : ((size) - 1) & (1ULL << 22) ? 22 : ((size) - 1) & (1ULL << 21) ? 21 : ((size) - 1) & (1ULL << 20) ? 20 : ((size) - 1) & (1ULL << 19) ? 19 : ((size) - 1) & (1ULL << 18) ? 18 : ((size) - 1) & (1ULL << 17) ? 17 : ((size) - 1) & (1ULL << 16) ? 16 : ((size) - 1) & (1ULL << 15) ? 15 : ((size) - 1) & (1ULL << 14) ? 14 : ((size) - 1) & (1ULL << 13) ? 13 : ((size) - 1) & (1ULL << 12) ? 12 : ((size) - 1) & (1ULL << 11) ? 11 : ((size) - 1) & (1ULL << 10) ? 10 : ((size) - 1) & (1ULL << 9) ? 9 : ((size) - 1) & (1ULL << 8) ? 8 : ((size) - 1) & (1ULL << 7) ? 7 : ((size) - 1) & (1ULL << 6) ? 6 : ((size) - 1) & (1ULL << 5) ? 5 : ((size) - 1) & (1ULL << 4) ? 4 : ((size) - 1) & (1ULL << 3) ? 3 : ((size) - 1) & (1ULL << 2) ? 2 : ((size) - 1) & (1ULL << 1) ? 1 : ((size) - 1) & (1ULL << 0) ? 0 : ____ilog2_NaN() ) : (sizeof((size) - 1) <= 4) ? __ilog2_u32((size) - 1) : __ilog2_u64((size) - 1) ) - 12 + 1) ) : __get_order(size) );
 return kmalloc_order_trace(size, flags, order);
}
extern void *kmalloc(size_t size, gfp_t flags);







static inline __attribute__((always_inline)) int kmalloc_size(int n)
{

 if (n > 2)
  return 1 << n;

 if (n == 1 && (1 << 3) <= 32)
  return 96;

 if (n == 2 && (1 << 3) <= 64)
  return 192;

 return 0;
}

static inline __attribute__((always_inline)) void *kmalloc_node(size_t size, gfp_t flags, int node)
{

 if (__builtin_constant_p(size) &&
  size <= (1UL << (12 + 1)) && !(flags & (( gfp_t)0x01u))) {
  int i = kmalloc_index(size);

  if (!i)
   return ((void *)16);

  return kmem_cache_alloc_node_trace(kmalloc_caches[i],
      flags, node, size);
 }

 return __kmalloc_node(size, flags, node);
}
struct memcg_cache_params {
  template <typename, int = 0> struct __BYPASSmemcg_cache_params {};
  template <typename, int> friend struct __BYPASSmemcg_cache_params;
 bool is_root_cache;
 union {
  struct kmem_cache *memcg_caches[0];
  struct {
   struct mem_cgroup *memcg;
   struct list_head list;
   struct kmem_cache *root_cache;
   bool dead;
   atomic_t nr_pages;
   struct work_struct destroy;
  
  friend class ::Introspect;
  friend class ::MyIntrospect;
};
 };

  friend class ::Introspect;
  friend class ::MyIntrospect;
};

int memcg_update_all_caches(int num_memcgs);

struct seq_file;
int cache_show(struct kmem_cache *s, struct seq_file *m);
void print_slabinfo_header(struct seq_file *m);







static inline void *kmalloc_array(size_t n, size_t size, gfp_t flags)
{
 if (size != 0 && n > (~(size_t)0) / size)
  return 0;
 return __kmalloc(n * size, flags);
}







static inline void *kcalloc(size_t n, size_t size, gfp_t flags)
{
 return kmalloc_array(n, size, flags | (( gfp_t)0x8000u));
}
extern void *__kmalloc_track_caller(size_t, gfp_t, unsigned long);
extern void *__kmalloc_node_track_caller(size_t, gfp_t, int, unsigned long);
static inline void *kmem_cache_zalloc(struct kmem_cache *k, gfp_t flags)
{
 return kmem_cache_alloc(k, flags | (( gfp_t)0x8000u));
}






static inline void *kzalloc(size_t size, gfp_t flags)
{
 return kmalloc(size, flags | (( gfp_t)0x8000u));
}







static inline void *kzalloc_node(size_t size, gfp_t flags, int node)
{
 return kmalloc_node(size, flags | (( gfp_t)0x8000u), node);
}




static inline unsigned int kmem_cache_size(struct kmem_cache *s)
{
 return s->object_size;
}

void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) kmem_cache_init_late(void);











extern spinlock_t dma_spin_lock;

static inline unsigned long claim_dma_lock(void)
{
 unsigned long flags;
 ;
 return flags;
}

static inline void release_dma_lock(unsigned long flags)
{
 ;
}



static inline void enable_dma(unsigned int dmanr)
{
 if (dmanr <= 3)
  outb(dmanr, 0x0A);
 else
  outb(dmanr & 3, 0xD4);
}

static inline void disable_dma(unsigned int dmanr)
{
 if (dmanr <= 3)
  outb(dmanr | 4, 0x0A);
 else
  outb((dmanr & 3) | 4, 0xD4);
}
static inline void clear_dma_ff(unsigned int dmanr)
{
 if (dmanr <= 3)
  outb(0, 0x0C);
 else
  outb(0, 0xD8);
}


static inline void set_dma_mode(unsigned int dmanr, char mode)
{
 if (dmanr <= 3)
  outb(mode | dmanr, 0x0B);
 else
  outb(mode | (dmanr & 3), 0xD6);
}






static inline void set_dma_page(unsigned int dmanr, char pagenr)
{
 switch (dmanr) {
 case 0:
  outb(pagenr, 0x87);
  break;
 case 1:
  outb(pagenr, 0x83);
  break;
 case 2:
  outb(pagenr, 0x81);
  break;
 case 3:
  outb(pagenr, 0x82);
  break;
 case 5:
  outb(pagenr & 0xfe, 0x8B);
  break;
 case 6:
  outb(pagenr & 0xfe, 0x89);
  break;
 case 7:
  outb(pagenr & 0xfe, 0x8A);
  break;
 }
}





static inline void set_dma_addr(unsigned int dmanr, unsigned int a)
{
 set_dma_page(dmanr, a>>16);
 if (dmanr <= 3) {
  outb(a & 0xff, ((dmanr & 3) << 1) + 0x00);
  outb((a >> 8) & 0xff, ((dmanr & 3) << 1) + 0x00);
 } else {
  outb((a >> 1) & 0xff, ((dmanr & 3) << 2) + 0xC0);
  outb((a >> 9) & 0xff, ((dmanr & 3) << 2) + 0xC0);
 }
}
static inline void set_dma_count(unsigned int dmanr, unsigned int count)
{
 count--;
 if (dmanr <= 3) {
  outb(count & 0xff, ((dmanr & 3) << 1) + 1 + 0x00);
  outb((count >> 8) & 0xff,
    ((dmanr & 3) << 1) + 1 + 0x00);
 } else {
  outb((count >> 1) & 0xff,
    ((dmanr & 3) << 2) + 2 + 0xC0);
  outb((count >> 9) & 0xff,
    ((dmanr & 3) << 2) + 2 + 0xC0);
 }
}
static inline int get_dma_residue(unsigned int dmanr)
{
 unsigned int io_port;

 unsigned short count;

 io_port = (dmanr <= 3) ? ((dmanr & 3) << 1) + 1 + 0x00
  : ((dmanr & 3) << 2) + 2 + 0xC0;

 count = 1 + inb(io_port);
 count += inb(io_port) << 8;

 return (dmanr <= 3) ? count : (count << 1);
}




extern int request_dma(unsigned int dmanr, char *device_id);
extern void free_dma(unsigned int dmanr);





extern int isa_dma_bridge_buggy;





extern unsigned long max_low_pfn;
extern unsigned long min_low_pfn;




extern unsigned long max_pfn;
extern unsigned long bootmem_bootmap_pages(unsigned long);

extern unsigned long init_bootmem_node(pg_data_t *pgdat,
           unsigned long freepfn,
           unsigned long startpfn,
           unsigned long endpfn);
extern unsigned long init_bootmem(unsigned long addr, unsigned long memend);

extern unsigned long free_all_bootmem(void);
extern void reset_all_zones_managed_pages(void);

extern void free_bootmem_node(pg_data_t *pgdat,
         unsigned long addr,
         unsigned long size);
extern void free_bootmem(unsigned long physaddr, unsigned long size);
extern void free_bootmem_late(unsigned long physaddr, unsigned long size);
extern void __free_pages_bootmem(struct page *page, unsigned int order);
extern int reserve_bootmem(unsigned long addr,
      unsigned long size,
      int flags);
extern int reserve_bootmem_node(pg_data_t *pgdat,
    unsigned long physaddr,
    unsigned long size,
    int flags);

extern void *__alloc_bootmem(unsigned long size,
        unsigned long align,
        unsigned long goal);
extern void *__alloc_bootmem_nopanic(unsigned long size,
         unsigned long align,
         unsigned long goal);
extern void *__alloc_bootmem_node(pg_data_t *pgdat,
      unsigned long size,
      unsigned long align,
      unsigned long goal);
void *__alloc_bootmem_node_high(pg_data_t *pgdat,
      unsigned long size,
      unsigned long align,
      unsigned long goal);
extern void *__alloc_bootmem_node_nopanic(pg_data_t *pgdat,
      unsigned long size,
      unsigned long align,
      unsigned long goal);
void *___alloc_bootmem_node_nopanic(pg_data_t *pgdat,
      unsigned long size,
      unsigned long align,
      unsigned long goal,
      unsigned long limit);
extern void *__alloc_bootmem_low(unsigned long size,
     unsigned long align,
     unsigned long goal);
void *__alloc_bootmem_low_nopanic(unsigned long size,
     unsigned long align,
     unsigned long goal);
extern void *__alloc_bootmem_low_node(pg_data_t *pgdat,
          unsigned long size,
          unsigned long align,
          unsigned long goal);
static inline void *alloc_remap(int nid, unsigned long size)
{
 return 0;
}


extern void *alloc_large_system_hash( char *tablename,
         unsigned long bucketsize,
         unsigned long numentries,
         int scale,
         int flags,
         unsigned int *_hash_shift,
         unsigned int *_hash_mask,
         unsigned long low_limit,
         unsigned long high_limit);
extern int hashdist;


template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_510_0 {
  typedef TJP__ZN7cpumask4bitsE_510_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_510(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_510_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
int __first_cpu( cpumask_t *srcp)
{
 return ({ int __min1 = (256); int __min2 = (find_first_bit(__get__ZN7cpumask4bitsE_510(srcp->bits), 256)); __min1 < __min2 ? __min1: __min2; });
}
;


template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_511_0 {
  typedef TJP__ZN7cpumask4bitsE_511_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_511(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_511_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
int __next_cpu(int n, cpumask_t *srcp)
{
 return ({ int __min1 = (256); int __min2 = (find_next_bit(__get__ZN7cpumask4bitsE_511(srcp->bits), 256, n+1)); __min1 < __min2 ? __min1: __min2; });
}
;



template <typename TResult, typename TThat, typename TTarget> struct TJP_nr_cpu_ids_512_0 {
  typedef TJP_nr_cpu_ids_512_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline int __get_nr_cpu_ids_512(int *source) {
  int __result_buffer;
  typedef TJP_nr_cpu_ids_512_0< int , void *, int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (int &)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_513_0 {
  typedef TJP__ZN7cpumask4bitsE_513_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_513(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_513_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP_nr_cpu_ids_514_0 {
  typedef TJP_nr_cpu_ids_514_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline int __get_nr_cpu_ids_514(int *source) {
  int __result_buffer;
  typedef TJP_nr_cpu_ids_514_0< int , void *, int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (int &)__result_buffer;
}
int __next_cpu_nr(int n, cpumask_t *srcp)
{
 return ({ int __min1 = (__get_nr_cpu_ids_512(&nr_cpu_ids)); int __min2 = (find_next_bit(__get__ZN7cpumask4bitsE_513(srcp->bits), __get_nr_cpu_ids_514(&nr_cpu_ids), n+1)); __min1 < __min2 ? __min1: __min2; })
                                               ;
}
;

template <typename TResult, typename TThat, typename TTarget> struct TJP_nr_cpu_ids_515_0 {
  typedef TJP_nr_cpu_ids_515_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline int __get_nr_cpu_ids_515(int *source) {
  int __result_buffer;
  typedef TJP_nr_cpu_ids_515_0< int , void *, int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (int &)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_516_0 {
  typedef TJP__ZN7cpumask4bitsE_516_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_516(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_516_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}

template <typename TResult, typename TThat, typename TTarget> struct TJP__ZN7cpumask4bitsE_517_0 {
  typedef TJP__ZN7cpumask4bitsE_517_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return true;}
  inline int dimension() {return 4;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return sizeof(unsigned long int);}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline unsigned long int * __get__ZN7cpumask4bitsE_517(unsigned long int *source) {
  unsigned long int *__result_buffer;
  typedef TJP__ZN7cpumask4bitsE_517_0< unsigned long int *, ::cpumask , unsigned long int [4] > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (unsigned long int *&)__result_buffer;
}
int cpumask_next_and(int n, struct cpumask *src1p,
       struct cpumask *src2p)
{
 while ((n = cpumask_next(n, src1p)) < __get_nr_cpu_ids_515(&nr_cpu_ids))
  if ((__builtin_constant_p((cpumask_check(n))) ? constant_test_bit((cpumask_check(n)), ((__get__ZN7cpumask4bitsE_516(((src2p))->bits)))) : variable_test_bit((cpumask_check(n)), ((__get__ZN7cpumask4bitsE_517(((src2p))->bits))))))
   break;
 return n;
}
;

template <typename TResult, typename TThat, typename TTarget> struct TJP_nr_cpu_ids_518_0 {
  typedef TJP_nr_cpu_ids_518_0 __TJP;
  typedef TResult Result;
  typedef TThat   That;
  typedef TTarget Target;
  static const AC::JPType JPTYPE = (AC::JPType)33554432;
  struct Res {
    typedef TResult Type;
    typedef TResult ReferredType;
  };

  Result *_result;
  Result *_source;

  inline bool is_array() {return false;}
  inline int dimension() {return 0;}
  inline bool is_pointer() {return false;}
  inline bool with_index() {return false;}
  inline bool is_base_record() {return false;}
  inline int base_size() {return 0;}
  inline Result *result() {return (Result*)_result;}
  inline Result *source() {return (Result*)_source;}

};

inline int __get_nr_cpu_ids_518(int *source) {
  int __result_buffer;
  typedef TJP_nr_cpu_ids_518_0< int , void *, int  > __TJP;
  __TJP tjp;
  tjp._result = &(__TJP::Result&)__result_buffer;
  tjp._source =  (__TJP::Result*)source;
  AC::invoke_MyIntrospect_Introspect__a0_around<__TJP> (&tjp);
  return (int &)__result_buffer;
}
int cpumask_any_but( struct cpumask *mask, unsigned int cpu)
{
 unsigned int i;

 cpumask_check(cpu);
 for ((i) = -1; (i) = cpumask_next((i), (mask)), (i) < __get_nr_cpu_ids_518(&nr_cpu_ids);)
  if (i != cpu)
   break;
 return i;
}

#ifdef __ac_FIRST_FILE__usr_local_etc_transcallX453_5_1_orig_libos_3_13_11_lib_cpumask_cxx__
#ifdef __ac_need__usr_local_etc_transcallX453_5_1_orig_libos_3_13_11_MyIntrospect_ah__
#ifndef __ac_have__usr_local_etc_transcallX453_5_1_orig_libos_3_13_11_MyIntrospect_ah__
#define __ac_have__usr_local_etc_transcallX453_5_1_orig_libos_3_13_11_MyIntrospect_ah__
#include "addr.h"

class Introspect {public:
  template <typename, int = 0> struct __BYPASSIntrospect {};
  template <typename, int> friend struct __BYPASSIntrospect;
private:
    

    
public: template <typename JoinPoint> void __a0_around (JoinPoint *tjp) {
  typedef typename JoinPoint::That __JP_That;
  typedef typename JoinPoint::Target __JP_Target;
  typedef typename JoinPoint::Result __JP_Result;

        void *addr, *obj;
        bool is_array = tjp->is_array();
        int dim;
        unsigned long size;
        
        if (is_array && !tjp->with_index()) {
            dim = tjp->dimension();

            if (dim > 0) {
                // base[dim]
                size = tjp->base_size() * dim;
            }
            else {
                // base[]
                size = 4096; // XXX
            }
        }
        else {
            // primitive type, struct, and union
            size = sizeof(__JP_Result);
        }

        addr = g_map(tjp->source(), size);
        obj = is_array ? &addr : addr;

        // assume the pointer of a primitive type as an array
        // excect when it is used with an index
        if (tjp->is_pointer() && !tjp->with_index() &&
            !tjp->is_base_record()) {
            void *ptr = *(void **)obj;

            addr = g_map(ptr, 2048); // XXX
            obj = &addr;
        }

        *tjp->result() = *(__JP_Result *)obj;
    }
private:

};
class MyIntrospect : public Introspect {public:
  template <typename, int = 0> struct __BYPASSMyIntrospect {};
  template <typename, int> friend struct __BYPASSMyIntrospect;
private:
    


public:
  static MyIntrospect *aspectof () {
    static MyIntrospect __instance;
    return &__instance;
  }
  static MyIntrospect *aspectOf () {
    return aspectof ();
  }
private:
};
namespace AC {
  template <class JoinPoint>
  __attribute((always_inline)) inline void invoke_MyIntrospect_Introspect__a0_around (JoinPoint *tjp) {
    ((::Introspect*)::MyIntrospect::aspectof())->__a0_around (tjp);
  }
} 

#endif
#endif
#undef __ac_FIRST__usr_local_etc_transcallX453_5_1_orig_libos_3_13_11__
#undef __ac_FIRST_FILE__usr_local_etc_transcallX453_5_1_orig_libos_3_13_11_lib_cpumask_cxx__
#endif // __ac_FIRST_FILE__usr_local_etc_transcallX453_5_1_orig_libos_3_13_11_lib_cpumask_cxx__
